<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
<meta charset="UTF-8"/>
<title>Git et les autres systèmes</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git et les autres systèmes" epub:type="chapter" id="ch09-git-and-other-scms">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>et</b> <b>les</b> <b>autres</b> <b>systèmes</b></small></h1>
</div>
</header>
<p>Le monde n&#8217;est pas parfait.
Habituellement, vous ne pouvez pas basculer immédiatement sous Git tous les projets que vous pourriez rencontrer.
Quelques fois, vous êtes bloqué sur un projet utilisant un autre VCS et vous regrettez que ce ne soit pas Git.
Dans la première partie de ce chapitre, nous traiterons de la manière d&#8217;utiliser git comme client pour les projets utilisant un autre système.</p>
<p>À un moment, vous voudrez convertir votre projet à Git.
La seconde partie de ce chapitre traite la migration de votre projet dans Git depuis certains systèmes spécifiques et enfin par un script d&#8217;import personnalisé pour les cas non-standards.</p>
<section class="sect1" title="Git comme client">
<h2 id="_git_comme_client">Git comme client</h2>
<p>
Git fournit de si bonnes sensations aux développeurs que de nombreuses personnes ont cherché à l&#8217;utiliser sur leur station de travail, même si le reste de leur équipe utilise un VCS complètement différent.
Il existe un certain nombre d&#8217;adaptateurs appelés « passerelles ».
Nous allons en décrire certains des plus communs.</p>
<section class="sect2" title="Git et Subversion">
<h3 id="s_git_svn">Git et Subversion</h3>
<p>
Aujourd&#8217;hui, la majorité des projets de développement libre et un grand nombre de projets dans les sociétés utilisent Subversion pour gérer leur code source.
Il a été le VCS libre le plus populaire depuis une bonne décennie et a été considéré comme le choix <em>de facto</em> pour les projets open-source.
Il est aussi très similaire à CVS qui a été le grand chef des gestionnaires de source avant lui.</p>
<p>
Une des grandes fonctionnalités de Git est sa passerelle vers Subversion, <code class="literal">git svn</code>.
Cet outil vous permet d&#8217;utiliser Git comme un client valide d&#8217;un serveur Subversion pour que vous puissiez utiliser les capacités de Git en local puis pousser sur le serveur Subversion comme si vous utilisiez Subversion localement.
Cela signifie que vous pouvez réaliser localement les embranchements et les fusions, utiliser l&#8217;index, utiliser le rebasage et le picorage de <em>commits</em>, etc, tandis que vos collaborateurs continuent de travailler avec leurs méthodes ancestrales et obscures.
C&#8217;est une bonne manière d&#8217;introduire Git dans un environnement professionnel et d&#8217;aider vos collègues développeurs à devenir plus efficaces tandis que vous ferez pression pour une modification de l&#8217;infrastructure vers l&#8217;utilisation massive de Git.
La passerelle Subversion n&#8217;est que la première dose vers la drogue du monde des DVCS.</p>
<section class="sect3" title="git svn">
<h4 id="_code_class_literal_git_svn_code"><code class="literal">git svn</code></h4>
<p>La commande de base dans Git pour toutes les commandes de passerelle est <code class="literal">git svn</code>.
Vous préfixerez tout avec cette paire de mots.
Les possibilités étant nombreuses, nous traiterons des plus communes pendant que nous détaillerons quelques petits modes de gestion.</p>
<p>Il est important de noter que lorsque vous utilisez <code class="literal">git svn</code>, vous interagissez avec Subversion qui est un système fonctionnant très différemment de Git.
Bien que vous <strong>puissiez</strong> réaliser des branches locales et les fusionner, il est généralement conseillé de conserver votre historique le plus linéaire possible en rebasant votre travail et en évitant des activités telles qu&#8217;interagir dans le même temps avec un dépôt Git distant.</p>
<p>Ne réécrivez pas votre historique avant d&#8217;essayer de pousser à nouveau et ne poussez pas en parallèle dans un dépôt Git pour collaborer avec vos collègues développant avec Git.
Subversion ne supporte qu&#8217;un historique linéaire et il est très facile de l&#8217;égarer.
Si vous travaillez avec une équipe dont certains membres utilisent SVN et d&#8217;autres utilisent Git, assurez-vous que tout le monde n&#8217;utilise que le serveur SVN pour collaborer, cela vous rendra service.</p>
</section>
<section class="sect3" title="Installation">
<h4 id="_installation">Installation</h4>
<p>Pour montrer cette fonctionnalité, il faut un serveur SVN sur lequel vous avez des droits en écriture.
Pour copier ces exemples, vous avez besoin de faire une copie inscriptible d&#8217;un dépôt SVN de test accessible.
Dans cette optique, vous pouvez utiliser un outil appelé <code class="literal">svnsync</code> qui est livré avec les versions les plus récentes de Subversion — il devrait être distribué avec les versions à partir de 1.4.</p>
<p>En préparation, créez un nouveau dépôt local Subversion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> mkdir /tmp/test-svn
<span style="font-weight: bold">$</span> svnadmin create /tmp/test-svn</code></pre>
</figure>
<p>Ensuite, autorisez tous les utilisateurs à changer les revprops — le moyen le plus simple consiste à ajouter un script <code class="literal">pre-revprop-change</code> qui renvoie toujours 0 :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /tmp/test-svn/hooks/pre-revprop-change
<span style="font-weight: bold">#</span>!/bin/sh
exit 0;
<span style="font-weight: bold">$</span> chmod +x /tmp/test-svn/hooks/pre-revprop-change</code></pre>
</figure>
<p>Vous pouvez à présent synchroniser ce projet sur votre machine locale en lançant <code class="literal">svnsync init</code> avec les dépôts source et cible.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> svnsync init file:///tmp/test-svn http://votre-serveur-svn.org/svn/</code></pre>
</figure>
<p>Cela initialise les propriétés nécessaires à la synchronisation.
Vous pouvez ensuite cloner le code en lançant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]</code></pre>
</figure>
<p>Bien que cette opération ne dure que quelques minutes, si vous essayez de copier le dépôt original sur un autre dépôt distant au lieu d&#8217;un dépôt local, le processus durera près d&#8217;une heure, en dépit du fait qu&#8217;il y a moins de 100 <em>commits</em>.
Subversion doit cloner révision par révision puis pousser vers un autre dépôt — c&#8217;est ridiculement inefficace mais c&#8217;est la seule possibilité.</p>
</section>
<section class="sect3" title="Démarrage">
<h4 id="_démarrage">Démarrage</h4>
<p>Avec des droits en écriture sur un dépôt Subversion, vous voici prêt à expérimenter une méthode typique.
Commençons par la commande <code class="literal">git svn clone</code> qui importe un dépôt Subversion complet dans un dépôt Git local.
Souvenez-vous que si vous importez depuis un dépôt Subversion hébergé sur Internet, il faut remplacer l&#8217;URL <code class="literal">file://tmp/test-svn</code> ci-dessous par l&#8217;URL de votre dépôt Subversion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75</code></pre>
</figure>
<p>Cela équivaut à lancer <code class="literal">git svn init</code> suivi de <code class="literal">git svn fetch</code> sur l&#8217;URL que vous avez fournie.
Cela peut prendre un certain temps.
Le projet de test ne contient que 75 <em>commits</em> et la taille du code n&#8217;est pas extraordinaire, ce qui prend juste quelques minutes.
Cependant, Git doit extraire chaque version, une par une et les valider individuellement.
Pour un projet contenant des centaines ou des milliers de <em>commits</em>, cela peut prendre littéralement des heures ou même des jours à terminer.</p>
<p>La partie <code class="literal">-T trunk -b branches -t tags</code> indique à Git que ce dépôt Subversion suit les conventions de base en matière d&#8217;embranchement et d&#8217;étiquetage.
Si vous nommez votre trunk, vos branches ou vos étiquettes différemment, vous pouvez modifier ces options.
Comme cette organisation est la plus commune, ces options peuvent être simplement remplacées par <code class="literal">-s</code> qui signifie structure standard.
La commande suivante est équivalente :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn clone file:///tmp/test-svn -s</code></pre>
</figure>
<p>À présent, vous disposez d&#8217;un dépôt Git valide qui a importé vos branches et vos étiquettes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk</code></pre>
</figure>
<p>Il est important de remarquer comment cet outil sous-classe vos références distantes différemment.

Voyons de plus près avec la commande Git de plomberie <code class="literal">show-ref</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</code></pre>
</figure>
<p>Git ne fait pas cela quand il clone depuis un serveur Git ; voici à quoi ressemble un dépôt avec des étiquettes juste après le clonage :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</code></pre>
</figure>
<p>Git entrepose les étiquettes directement dans <code class="literal">refs/tags</code>, plutôt que de les traiter comme des branches distantes.</p>
</section>
<section class="sect3" title="Valider en retour sur le serveur Subversion">
<h4 id="_valider_en_retour_sur_le_serveur_subversion">Valider en retour sur le serveur Subversion</h4>
<p>Comme vous disposez d&#8217;un dépôt en état de marche, vous pouvez commencer à travailler sur le projet et pousser vos <em>commits</em> en utilisant efficacement Git comme client SVN.
Si vous éditez un des fichiers et le validez, vous créez un <em>commit</em> qui existe localement dans Git mais qui n&#8217;existe pas sur le serveur Subversion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;Adding git-svn instructions to the README&#39;</span>
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)</code></pre>
</figure>
<p>Ensuite, vous avez besoin de pousser vos modifications en amont.
Remarquez que cela modifie la manière de travailler par rapport à Subversion — vous pouvez réaliser plusieurs validations en mode déconnecté pour ensuite les pousser toutes en une fois sur le serveur Subversion.
Pour pousser sur un serveur Subversion, il faut lancer la commande <code class="literal">git svn dcommit</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</figure>
<p>Cette commande rassemble tous les <em>commits</em> que vous avez validés par-dessus le code du serveur Subversion et réalise un <em>commit</em> sur le serveur pour chacun, puis réécrit l&#8217;historique Git local pour y ajouter un identifiant unique.
Cette étape est à souligner car elle signifie que toutes les sommes de contrôle SHA-1 de vos <em>commits</em> locaux ont changé.
C&#8217;est en partie pour cette raison que c&#8217;est une idée très périlleuse de vouloir travailler dans le même temps avec des serveurs Git distants.
L&#8217;examen du dernier <em>commit</em> montre que le nouveau <code class="literal">git-svn-id</code> a été ajouté :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben &lt;ben@0b684db3-b064-4277-89d1-21af03df0a68&gt;
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</code></pre>
</figure>
<p>Remarquez que la somme de contrôle SHA qui commençait par <code class="literal">4af61fd</code> quand vous avez validé commence à présent par <code class="literal">95e0222</code>.
Si vous souhaitez pousser à la fois sur un serveur Git et un serveur Subversion, il faut obligatoirement pousser (<code class="literal">dcommit</code>) sur le serveur Subversion en premier, car cette action va modifier vos données des <em>commits</em>.</p>
</section>
<section class="sect3" title="Tirer des modifications">
<h4 id="_tirer_des_modifications">Tirer des modifications</h4>
<p>Quand vous travaillez avec d&#8217;autres développeurs, il arrive à certains moments que ce qu&#8217;un développeur a poussé provoque un conflit lorsqu&#8217;un autre voudra pousser à son tour.
Cette modification sera rejetée jusqu&#8217;à ce qu&#8217;elle soit fusionnée.
Dans <code class="literal">git svn</code>, cela ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File &#39;/trunk/README.txt&#39; is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</figure>
<p>Pour résoudre cette situation, vous pouvez lancer la commande <code class="literal">git svn rebase</code> qui tire depuis le serveur toute modification apparue entre temps et rebase votre travail sur le sommet de l&#8217;historique du serveur :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File &#39;/trunk/README.txt&#39; is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</figure>
<p>À présent, tout votre travail se trouve au-delà de l&#8217;historique du serveur et vous pouvez effectivement réaliser un <code class="literal">dcommit</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</figure>
<p>Il est important de se souvenir qu&#8217;à la différence de Git qui requiert une fusion avec les modifications distantes non présentes localement avant de pouvoir pousser, <code class="literal">git svn</code> ne vous y contraint que si vos modifications provoquent un conflit (de la même manière que <code class="literal">svn</code>).
Si une autre personne pousse une modification à un fichier et que vous poussez une modification à un autre fichier, votre <code class="literal">dcommit</code> passera sans problème :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...</code></pre>
</figure>
<p>Il faut s&#8217;en souvenir car le résultat de ces actions est un état du dépôt qui n&#8217;existait pas sur aucun des ordinateurs quand vous avez poussé.
Si les modifications sont incompatibles mais ne créent pas de conflits, vous pouvez créer des défauts qui seront très difficiles à diagnostiquer.
C&#8217;est une grande différence avec un serveur Git — dans Git, vous pouvez tester complètement l&#8217;état du projet sur votre système client avant de le publier, tandis qu&#8217;avec SVN, vous ne pouvez jamais être totalement certain que les états avant et après validation sont identiques.</p>
<p>Vous devrez aussi lancer cette commande pour tirer les modifications depuis le serveur Subversion, même si vous n&#8217;êtes pas encore prêt à valider.
Vous pouvez lancer <code class="literal">git svn fetch</code> pour tirer les nouveaux <em>commits</em>, mais <code class="literal">git svn rebase</code> tire non seulement les <em>commits</em> distants mais rebase aussi vos <em>commits</em> locaux.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.</code></pre>
</figure>
<p>Lancer <code class="literal">git svn rebase</code> de temps en temps vous assure que votre travail est toujours synchronisé avec le serveur.
Vous devrez cependant vous assurer que votre copie de travail est propre quand vous la lancez.
Si vous avez des modifications locales, il vous faudra soit remiser votre travail, soit valider temporairement vos modifications avant de lancer <code class="literal">git svn rebase</code>, sinon la commande s&#8217;arrêtera si elle détecte que le rebasage provoquerait un conflit de fusion.</p>
</section>
<section class="sect3" title="Le problème avec les branches Git">
<h4 id="_le_problème_avec_les_branches_git">Le problème avec les branches Git</h4>
<p>Après vous être habitué à la manière de faire avec Git, vous souhaiterez sûrement créer des branches thématiques, travailler dessus, puis les fusionner.
Si vous poussez sur un serveur Subversion via <code class="literal">git svn</code>, vous souhaiterez à chaque fois rebaser votre travail sur une branche unique au lieu de fusionner les branches ensemble.
La raison principale en est que Subversion gère un historique linéaire et ne gère pas les fusions comme Git y excelle.
De ce fait, <code class="literal">git svn</code> suit seulement le premier parent lorsqu&#8217;il convertit les instantanés en <em>commits</em> Subversion.</p>
<p>Supposons que votre historique ressemble à ce qui suit. Vous avez créé une branche <code class="literal">experience</code>, avez réalisé deux validations puis les avez fusionnées dans <code class="literal">master</code>.
Lors du <code class="literal">dcommit</code>, vous voyez le résultat suivant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</figure>
<p>Lancer <code class="literal">dcommit</code> sur une branche avec un historique fusionné fonctionne correctement, à l&#8217;exception que l&#8217;examen de l&#8217;historique du projet Git indique qu&#8217;il n&#8217;a réécrit aucun des <em>commits</em> réalisés sur la branche <code class="literal">experience</code>, mais que toutes les modifications introduites apparaissent dans la version SVN de l&#8217;unique <em>commit</em> de fusion.</p>
<p>Quand quelqu&#8217;un d&#8217;autre clone ce travail, tout ce qu&#8217;il voit, c&#8217;est le <em>commit</em> de la fusion avec toutes les modifications injectées en une fois, comme si vous aviez lancé <code class="literal">git merge --squash</code>.
Il ne voit aucune information sur son origine ni sur sa date de validation.</p>
</section>
<section class="sect3" title="Les embranchements dans Subversion">
<h4 id="_les_embranchements_dans_subversion">Les embranchements dans Subversion</h4>
<p>La gestion de branches dans Subversion n&#8217;a rien à voir avec celle de Git.
Évitez de l&#8217;utiliser autant que possible.
Cependant vous pouvez créer des branches et valider dessus dans Subversion en utilisant <code class="literal">git svn</code>.</p>
</section>
<section class="sect3" title="Créer une nouvelle branche SVN">
<h4 id="_créer_une_nouvelle_branche_svn">Créer une nouvelle branche SVN</h4>
<p>Pour créer une nouvelle branche dans Subversion, vous pouvez utiliser la commande <code class="literal">git svn branch [nom de la branche]</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</code></pre>
</figure>
<p>Cela est équivalent à la commande Subversion <code class="literal">svn copy trunk branches/opera</code> et réalise l&#8217;opération sur le serveur Subversion.
Remarquez que cette commande ne vous bascule pas sur cette branche ; si vous validez, le <em>commit</em> s&#8217;appliquera à <code class="literal">trunk</code> et non à la branche <code class="literal">opera</code>.</p>
</section>
<section class="sect3" title="Basculer de branche active">
<h4 id="_basculer_de_branche_active">Basculer de branche active</h4>
<p>Git devine la branche cible des <code class="literal">dcommits</code> en se référant au sommet des branches Subversion dans votre historique — vous ne devriez en avoir qu&#8217;un et celui-ci devrait être le dernier possédant un <code class="literal">git-svn-id</code> dans l&#8217;historique actuel de votre branche.</p>
<p>Si vous souhaitez travailler simultanément sur plusieurs branches, vous pouvez régler vos branches locales pour que le <code class="literal">dcommit</code> arrive sur une branche Subversion spécifique en les démarrant sur le <em>commit</em> de cette branche importée depuis Subversion.
Si vous voulez une branche <code class="literal">opera</code> sur laquelle travailler séparément, vous pouvez lancer :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch opera remotes/origin/opera</code></pre>
</figure>
<p>À présent, si vous voulez fusionner votre branche <code class="literal">opera</code> dans <code class="literal">trunk</code> (votre branche <code class="literal">master</code>), vous pouvez le faire en réalisant un <code class="literal">git merge</code> normal.
Mais vous devez préciser un message de validation descriptif (via <code class="literal">-m</code>), ou la fusion indiquera simplement « Merge branch opera » au lieu d&#8217;un message plus informatif.</p>
<p>Souvenez-vous que bien que vous utilisez <code class="literal">git merge</code> qui facilitera l&#8217;opération de fusion par rapport à Subversion (Git détectera automatiquement l&#8217;ancêtre commun pour la fusion), ce n&#8217;est pas un <em>commit</em> de fusion normal de Git.
Vous devrez pousser ces données finalement sur le serveur Subversion qui ne sait pas tracer les <em>commits</em> possédant plusieurs parents.
Donc, ce sera un <em>commit</em> unique qui englobera toutes les modifications de l&#8217;autre branche.
Après avoir fusionné une branche dans une autre, il est difficile de continuer à travailler sur cette branche, comme vous le feriez normalement dans Git.
La commande <code class="literal">dcommit</code> qui a été lancée efface toute information sur la branche qui a été fusionnée, ce qui rend faux tout calcul d&#8217;antériorité pour la fusion.
<code class="literal">dcommit</code> fait ressembler le résultat de <code class="literal">git merge</code> à celui de <code class="literal">git merge --squash</code>.
Malheureusement, il n&#8217;y a pas de moyen efficace de remédier à ce problème — Subversion ne stocke pas cette information et vous serez toujours contraints par ses limitations si vous l&#8217;utilisez comme serveur.
Pour éviter ces problèmes, le mieux reste d&#8217;effacer la branche locale (dans notre cas, <code class="literal">opera</code>) dès qu&#8217;elle a été fusionnée dans <code class="literal">trunk</code>.</p>
</section>
<section class="sect3" title="Commandes Subversion">
<h4 id="_commandes_subversion">Commandes Subversion</h4>
<p>La boîte à outil <code class="literal">git svn</code> fournit des commandes de nature à faciliter la transition vers Git en mimant certaines commandes disponibles avec Subversion.
Voici quelques commandes qui vous fournissent les mêmes services que Subversion.</p>
<section class="sect4" title="L&#8217;historique dans le style Subversion">
<h5 id="_l_historique_dans_le_style_subversion">L&#8217;historique dans le style Subversion</h5>
<p>Si vous êtes habitué à Subversion, vous pouvez lancer <code class="literal">git svn log</code> pour visualiser votre historique dans un format SVN :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch &#39;experiment&#39;

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog</code></pre>
</figure>
<p>Deux choses importantes à connaître sur <code class="literal">git svn log</code>.
Premièrement, à la différence de la véritable commande <code class="literal">svn log</code> qui interroge le serveur, cette commande fonctionne hors connexion.
Deuxièmement, elle ne montre que les <em>commits</em> qui ont été effectivement remontés sur le serveur Subversion.
Les <em>commits</em> locaux qui n&#8217;ont pas encore été remontés via <code class="literal">dcommit</code> n&#8217;apparaissent pas, pas plus que ceux qui auraient été poussés sur le serveur par des tiers entre-temps.
Cela donne plutôt le dernier état connu des <em>commits</em> sur le serveur Subversion.</p>
</section>
<section class="sect4" title="Annotations SVN">
<h5 id="_annotations_svn">Annotations SVN</h5>
<p>De la même manière que <code class="literal">git svn log</code> simule une commande <code class="literal">svn log</code> déconnectée, vous pouvez obtenir l&#8217;équivalent de <code class="literal">svn annotate</code> en lançant <code class="literal">git svn blame [fichier]</code>.
Le résultat ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn blame README.txt
 2   temporal Protocol Buffers - Google&#39;s data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal</code></pre>
</figure>
<p>Ici aussi, tous les <em>commits</em> locaux dans Git ou ceux poussés sur Subversion dans l&#8217;intervalle n&#8217;apparaissent pas.</p>
</section>
<section class="sect4" title="Information sur le serveur SVN">
<h5 id="_information_sur_le_serveur_svn">Information sur le serveur SVN</h5>
<p>Vous pouvez aussi obtenir le même genre d&#8217;information que celle fournie par <code class="literal">svn info</code> en lançant <code class="literal">git svn info</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</code></pre>
</figure>
<p>Comme <code class="literal">blame</code> et <code class="literal">log</code>, cette commande travaille hors connexion et n&#8217;est à jour qu&#8217;à la dernière date à laquelle vous avez communiqué avec le serveur Subversion.</p>
</section>
<section class="sect4" title="Ignorer ce que Subversion ignore">
<h5 id="_ignorer_ce_que_subversion_ignore">Ignorer ce que Subversion ignore</h5>
<p>Si vous clonez un dépôt Subversion contenant des propriétés <code class="literal">svn:ignore</code>, vous souhaiterez sûrement paramétrer les fichiers <code class="literal">.gitignore</code> en correspondance pour vous éviter de valider accidentellement des fichiers qui ne devraient pas l&#8217;être.
<code class="literal">git svn</code> dispose de deux commandes pour le faire.</p>
<p>La première est <code class="literal">git svn create-ignore</code> qui crée automatiquement pour vous les fichiers <code class="literal">.gitignore</code> prêts pour l&#8217;inclusion dans votre prochaine validation.</p>
<p>La seconde commande est <code class="literal">git svn show-ignore</code> qui affiche sur <code class="literal">stdout</code> les lignes nécessaires à un fichier <code class="literal">.gitignore</code> qu&#8217;il suffira de rediriger  dans votre fichier d&#8217;exclusion de projet :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn show-ignore &gt; .git/info/exclude</code></pre>
</figure>
<p>De cette manière, vous ne parsemez pas le projet de fichiers <code class="literal">.gitignore</code>.
C&#8217;est une option optimale si vous êtes le seul utilisateur de Git dans une équipe Subversion et que vos coéquipiers ne veulent pas voir de fichiers <code class="literal">.gitignore</code> dans le projet.</p>
</section>
</section>
<section class="sect3" title="Résumé sur Git-Svn">
<h4 id="_résumé_sur_git_svn">Résumé sur Git-Svn</h4>
<p>Les outils <code class="literal">git svn</code> sont utiles si vous êtes bloqué avec un serveur Subversion pour le moment ou si vous devez travailler dans un environnement de développement qui nécessite un serveur Subversion.
Il faut cependant les considérer comme une version estropiée de Git ou vous pourriez rencontrer des problèmes de conversion qui vous embrouilleront vous et vos collaborateurs.
Pour éviter tout problème, essayez de suivre les principes suivants :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">Gardez un historique Git linéaire qui ne contient pas de <em>commits</em> de fusion issus de <code class="literal">git merge</code>.</span>
</li>
<li>
<span class="principal">Rebasez tout travail réalisé en dehors de la branche principale sur celle-ci ; ne la fusionnez pas.</span>
</li>
<li>
<span class="principal">Ne mettez pas en place et ne travaillez pas en parallèle sur un serveur Git. Si nécessaire, montez-en un pour accélérer les clones pour de nouveaux développeurs mais n&#8217;y poussez rien qui n&#8217;ait déjà une entrée <code class="literal">git-svn-id</code>. Vous devriez même y ajouter un crochet <code class="literal">pre-receive</code> qui vérifie la présence de <code class="literal">git-svn-id</code> dans chaque message de validation et rejette les remontées dont un des <em>commits</em> n&#8217;en contiendrait pas.</span>
</li>
</ul>
</div>
<p>Si vous suivez ces principes, le travail avec un serveur Subversion peut être supportable.
Cependant, si le basculement sur un vrai serveur Git est possible, votre équipe y gagnera beaucoup.</p>
</section>
</section>
<section class="sect2" title="Git et Mercurial">
<h3 id="_git_et_mercurial">Git et Mercurial</h3>
<p>

L&#8217;univers des systèmes de gestion de version distribués ne se limite pas à Git.
En fait, il existe de nombreux autres systèmes, chacun avec sa propre approche sur la gestion distribuée des versions.
À part Git, le plus populaire est Mercurial, et ces deux-ci sont très ressemblants par de nombreux aspects.</p>
<p>La bonne nouvelle si vous préférez le comportement de Git côté client mais que vous devez travailler sur un projet géré sous Mercurial, c&#8217;est que l&#8217;on peut utiliser Git avec un dépôt géré sous Mercurial.
Du fait que Git parle avec les dépôts distants au moyen de greffons de protocole distant, il n&#8217;est pas surprenant que cette passerelle prenne la forme d&#8217;un greffon de protocole distant.
Le projet s&#8217;appelle git-remote-hg et peut être trouvé à l&#8217;adresse <a href="https://github.com/felipec/git-remote-hg" class="link">https://github.com/felipec/git-remote-hg</a>.</p>
<section class="sect3" title="git-remote-hg">
<h4 id="_git_remote_hg">git-remote-hg</h4>
<p>Premièrement, vous devez installer git-remote-hg.
Cela revient simplement à copier ce fichier quelque part dans votre chemin de recherche, comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl -o ~/bin/git-remote-hg <span style="font-weight: bold; font-style: italic">\</span>
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
<span style="font-weight: bold">$</span> chmod +x ~/bin/git-remote-hg</code></pre>
</figure>
<p>…en supposant que <code class="literal">~/bin</code> est présent dans votre <code class="literal">$PATH</code>.
git-remote-hg est aussi dépendant de la bibliothèque <code class="literal">Mercurial</code> pour Python.
Si Python est déjà installé, c&#8217;est aussi simple que :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> pip install mercurial</code></pre>
</figure>
<p>Si Python n&#8217;est pas déjà installé, visitez <a href="https://www.python.org/" class="link">https://www.python.org/</a> et récupérez-le.</p>
<p>La dernière dépendance est le client Mercurial.
Rendez-vous sur <a href="https://www.mercurial-scm.org/" class="link">https://www.mercurial-scm.org/</a> et installez-le si ce n&#8217;est pas déjà fait.</p>
<p>Maintenant, vous voilà prêt.
Vous n&#8217;avez besoin que d&#8217;un dépôt Mercurial où pousser.
Heureusement, tous les dépôts Mercurial peuvent servir et nous allons donc simplement utiliser le dépôt "hello world" dont tout le monde se sert pour apprendre Mercurial :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg clone http://selenic.com/repo/hello /tmp/hello</code></pre>
</figure>
</section>
<section class="sect3" title="Démarrage">
<h4 id="_démarrage_2">Démarrage</h4>
<p>Avec un dépôt « côté serveur » maintenant disponible, détaillons un flux de travail typique.
Comme vous le verrez, ces deux systèmes sont suffisamment similaires pour qu&#8217;il y ait peu de friction.</p>
<p>Comme toujours avec Git, commençons par cloner :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone hg::/tmp/hello /tmp/hello-git
<span style="font-weight: bold">$</span> cd /tmp/hello-git
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate
* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>Notez bien que pour travailler avec un dépôt Mercurial, on utilise la commande standard <code class="literal">git clone</code>.
C&#8217;est dû au fait que git-remote-hg travaille à un niveau assez bas, en utilisant un mécanisme similaire à celui du protocole HTTP/S de Git.
Comme Git et Mercurial sont tous les deux organisés pour que chaque client récupère une copie complète de l&#8217;historique du dépôt, cette commande réalise rapidement un clone complet, incluant tout l&#8217;historique du projet.</p>
<p>La commande log montre deux <em>commits</em>, dont le dernier est pointé par une ribambelle de refs.
En fait, certaines d&#8217;entre elles n&#8217;existent par vraiment.
Jetons un œil à ce qui est réellement présent dans le répertoire <code class="literal">.git</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tree .git/refs
.git/refs
├── heads
│   └── master
├── hg
│   └── origin
│       ├── bookmarks
│       │   └── master
│       └── branches
│           └── default
├── notes
│   └── hg
├── remotes
│   └── origin
│       └── HEAD
└── tags

9 directories, 5 files</code></pre>
</figure>
<p>Git-remote-hg essaie de rendre les choses plus idiomatiquement Git-esques, mais sous le capot, il gère la correspondance conceptuelle entre deux systèmes légèrement différents.
Par exemple, le fichier <code class="literal">refs/hg/origin/branches/default</code> est un fichier Git de références, qui contient le SHA-1 commençant par « ac7955c », qui est le <em>commit</em> pointé par <code class="literal">master</code>.
Donc le répertoire <code class="literal">refs/hg</code> est en quelque sorte un faux <code class="literal">refs/remotes/origin</code>, mais il contient la distinction entre les marque-pages et les branches.</p>
<p>Le fichier <code class="literal">notes/hg</code> est le point de départ pour comprendre comment git-remote-hg fait correspondre les empreintes des <em>commits</em> Git avec les IDs de modification de Mercurial.
Explorons-le un peu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat notes/hg
d4c10386...

<span style="font-weight: bold">$</span> git cat-file -p d4c10386...
tree 1781c96...
author remote-hg &lt;&gt; 1408066400 -0800
committer remote-hg &lt;&gt; 1408066400 -0800

Notes for master

<span style="font-weight: bold">$</span> git ls-tree 1781c96...
100644 blob ac9117f...	65bb417...
100644 blob 485e178...	ac7955c...

<span style="font-weight: bold">$</span> git cat-file -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9</code></pre>
</figure>
<p>Donc, <code class="literal">refs/notes/hg</code> pointe sur un arbre qui correspond dans la base de données des objets de Git à une liste des autres objets avec des noms.
<code class="literal">git-ls-tree</code> affiche le mode, le type, l&#8217;empreinte de l&#8217;objet et le nom de fichier des articles d&#8217;un arbre.
Quand nous creusons un de ces articles, nous trouvons à l&#8217;intérieur un blob appelé « ac9117f » (l&#8217;empreinte SHA-1 du <em>commit</em> pointé par <code class="literal">master</code>), avec le contenu « 0a04b98 » (qui est l&#8217;ID de la modification Mercurial au sommet de la branche <code class="literal">default</code>).</p>
<p>La bonne nouvelle est que nous n&#8217;avons quasiment pas à nous soucier de tout ceci.
Le mode de travail ne sera pas très différent de celui avec un serveur distant Git.</p>
<p>Il reste une chose à gérer avant de passer à la suite : les fichiers <code class="literal">ignore</code>.
Mercurial et Git utilisent un mécanisme très similaire pour cette fonctionnalité, mais il est très probable que vous ne souhaitez pas valider un fichier <code class="literal">.gitignore</code> dans un dépôt Mercurial.
Heureusement, Git dispose d&#8217;un moyen d&#8217;ignorer les fichiers d&#8217;un dépôt local et le format Mercurial est compatible avec Git.
Il suffit donc de le copier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp .hgignore .git/info/exclude</code></pre>
</figure>
<p>Le fichier <code class="literal">.git/info/exclude</code> se comporte simplement comme un fichier <code class="literal">.gitignore</code>, mais n&#8217;est pas inclus dans les <em>commits</em>.</p>
</section>
<section class="sect3" title="Déroulement">
<h4 id="_déroulement">Déroulement</h4>
<p>Supposons que nous avons travaillé et validé quelques <em>commits</em> sur la branche <code class="literal">master</code> et que nous sommes prêts à pousser ce travail sur un dépôt distant.
Notre dépôt ressemble actuellement à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --graph --decorate
* ba04a2a (HEAD, master) Update makefile
* d25d16f Goodbye
* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>Notre branche <code class="literal">master</code> est en avance de deux <em>commits</em> par rapport à <code class="literal">origin/master</code>, mais ces deux <em>commits</em> n&#8217;existent que sur notre machine locale.
Voyons si quelqu&#8217;un d&#8217;autre a poussé son travail dans le même temps :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
From hg::/tmp/hello
   ac7955c..df85e87  master     -&gt; origin/master
   ac7955c..df85e87  branches/default -&gt; origin/branches/default
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 7b07969 (refs/notes/hg) Notes for default
* d4c1038 Notes for master
* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
| * ba04a2a (HEAD, master) Update makefile
| * d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>Comme nous avons utilisé l&#8217;option <code class="literal">--all</code>, nous voyons les références « notes » qui sont utilisées en interne par git-remote-hg, mais nous pouvons les ignorer.
Le reste était attendu ; <code class="literal">origin/master</code> a avancé d&#8217;un <em>commit</em> et notre historique a divergé.
À la différence d&#8217;autres systèmes que nous décrivons dans ce chapitre, Mercurial est capable de gérer les fusions, donc ce que nous allons faire n&#8217;a rien d&#8217;extraordinaire.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Auto-merging hello.c
Merge made by the &#39;recursive&#39; strategy.
 hello.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate
*   0c64627 (HEAD, master) Merge remote-tracking branch &#39;origin/master&#39;
|\
| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
* | ba04a2a Update makefile
* | d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>Parfait.
Nous lançons les tests et tout passe, et nous voilà prêts à partager notre travail avec l&#8217;équipe :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push
To hg::/tmp/hello
   df85e87..0c64627  master -&gt; master</code></pre>
</figure>
<p>C&#8217;est fini !
Si vous inspectez le dépôt Mercurial, vous verrez que le résultat se présente comme attendu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg log -G --style compact
o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben
|\     Merge remote-tracking branch &#39;origin/master&#39;
| |
| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben
| |    Update makefile
| |
| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben
| |    Goodbye
| |
@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>La modification numérotée <em>2</em> a été faite par Mercurial et celles numérotées <em>3</em> et <em>4</em> ont été faites par git-remote-hg, en poussant les <em>commits</em> réalisés avec Git.</p>
</section>
<section class="sect3" title="Branches et marque-pages">
<h4 id="_branches_et_marque_pages">Branches et marque-pages</h4>
<p>Git n&#8217;a qu&#8217;un seul type de branche : une référence qui se déplace quand des <em>commits</em> sont ajoutés.
Dans Mercurial, ce type de référence est appelé « marque-page » et se comporte de la même manière qu&#8217;une branche Git.</p>
<p>Le concept de « branche » dans Mercurial est plus contraignant.
La branche sur laquelle une modification est réalisée est enregistrée <em>avec la modification</em>, ce qui signifie que cette dernière sera toujours présente dans l&#8217;historique du dépôt.
Voici un exemple d&#8217;un <em>commit</em> ajouté à la branche <code class="literal">develop</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg log -l 1
changeset:   6:8f65e5e02793
branch:      develop
tag:         tip
user:        Ben Straub &lt;ben@straub.cc&gt;
date:        Thu Aug 14 20:06:38 2014 -0700
summary:     More documentation</code></pre>
</figure>
<p>Notez la ligne qui commence par « branch ».
Git ne peut pas vraiment répliquer ce comportement (il n&#8217;en a pas besoin ; les deux types de branches peuvent être représentés par une ref Git), mais git-remote-hg a besoin de comprendre cette différence, puisque qu&#8217;elle a du sens pour Mercurial.</p>
<p>La création de marque-pages Mercurial est aussi simple que la création de branches Git.
Du côté Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b featureA
Switched to a new branch &#39;featureA&#39;
<span style="font-weight: bold">$</span> git push origin featureA
To hg::/tmp/hello
 * [new branch]      featureA -&gt; featureA</code></pre>
</figure>
<p>C&#8217;est tout ce qui est nécessaire.
Du côté Mercurial, cela ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg bookmarks
   featureA                  5:bd5ac26f11f9
<span style="font-weight: bold">$</span> hg log --style compact -G
@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben
|    More documentation
|
o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
|\     Merge remote-tracking branch &#39;origin/master&#39;
| |
| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| |    update makefile
| |
| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |    goodbye
| |
o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>Remarquez la nouvelle étiquette <code class="literal">[featureA]</code> sur la révision 5.
Elle se comporte exactement comme une branche Git du côté Git, avec une exception : vous ne pouvez pas effacer un marque-page depuis le côté Git (c&#8217;est une limitation des greffons de gestion distante).</p>
<p>Vous pouvez travailler aussi sur une branche « lourde » Mercurial : placez une branche dans l&#8217;espace de nom <code class="literal">branches</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b branches/permanent
Switched to a new branch &#39;branches/permanent&#39;
<span style="font-weight: bold">$</span> vi Makefile
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;A permanent change&#39;</span>
<span style="font-weight: bold">$</span> git push origin branches/permanent
To hg::/tmp/hello
 * [new branch]      branches/permanent -&gt; branches/permanent</code></pre>
</figure>
<p>Voici à quoi ça ressemble du côté Mercurial :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg branches
permanent                      7:a4529d07aad4
develop                        6:8f65e5e02793
default                        5:bd5ac26f11f9 (inactive)
<span style="font-weight: bold">$</span> hg log -G
o  changeset:   7:a4529d07aad4
|  branch:      permanent
|  tag:         tip
|  parent:      5:bd5ac26f11f9
|  user:        Ben Straub &lt;ben@straub.cc&gt;
|  date:        Thu Aug 14 20:21:09 2014 -0700
|  summary:     A permanent change
|
| @  changeset:   6:8f65e5e02793
|/   branch:      develop
|    user:        Ben Straub &lt;ben@straub.cc&gt;
|    date:        Thu Aug 14 20:06:38 2014 -0700
|    summary:     More documentation
|
o    changeset:   5:bd5ac26f11f9
|\   bookmark:    featureA
| |  parent:      4:0434aaa6b91f
| |  parent:      2:f098c7f45c4f
| |  user:        Ben Straub &lt;ben@straub.cc&gt;
| |  date:        Thu Aug 14 20:02:21 2014 -0700
| |  summary:     Merge remote-tracking branch &#39;origin/master&#39;
[...]</code></pre>
</figure>
<p>Le nom de branche « permanent » a été enregistré avec la modification marquée <em>7</em>.</p>
<p>Du côté Git, travailler avec les deux styles de branches revient au même : employez les commandes <code class="literal">checkout</code>, <code class="literal">commit</code>, <code class="literal">fetch</code>, <code class="literal">merge</code>, <code class="literal">pull</code> et <code class="literal">push</code> comme vous feriez normalement.
Une chose à savoir cependant est que Mercurial ne supporte pas la réécriture de l&#8217;historique mais seulement les ajouts.
Voici à quoi ressemble le dépôt Mercurial après un rebasage interactif et une poussée forcée :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg log --style compact -G
o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben
|    A permanent change
|
o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben
|    Add some documentation
|
o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben
|    goodbye
|
| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben
| |    A permanent change
| |
| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben
| |/     More documentation
| |
| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
| |\     Merge remote-tracking branch &#39;origin/master&#39;
| | |
| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| | |    update makefile
| | |
+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |      goodbye
| |
| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>Les modifications <em>8</em>, <em>9</em> et <em>10</em> ont été créées et appartiennent à la branche <code class="literal">permanent</code> mais les anciennes modifications sont toujours présentes.
Ça a toutes les chances de perdre vos collègues qui utilisent Mercurial, donc c&#8217;est à éviter à tout prix.</p>
</section>
<section class="sect3" title="Résumé Mercurial">
<h4 id="_résumé_mercurial">Résumé Mercurial</h4>
<p>Git et Mercurial sont suffisamment similaires pour que le travail pendulaire entre les deux se passe sans accroc.
Si vous évitez de modifier l&#8217;historique qui a déjà quitté votre machine (comme il l&#8217;est recommandé), vous pouvez tout simplement ignorer que le dépôt distant fonctionne avec Mercurial.</p>
</section>
</section>
<section class="sect2" title="Git et Bazaar">
<h3 id="_git_et_bazaar">Git et Bazaar</h3>
<p>Parmi tous les systèmes de contrôle de version distribués, un des plus connus est <a href="http://bazaar.canonical.com/" class="link">Bazaar</a>.
Bazaar est libre et open source, et fait partie du <a href="http://www.gnu.org/" class="link">Projet GNU</a>.
Il a un comportement très différent de Git.
Parfois, pour faire la même chose que Git, il vous faudra utiliser un mot-clé différent, et quelques mots-clés communs n&#8217;ont pas la même signification.
En particulier, la gestion des branches est très différente et peut être déroutante, surtout pour quelqu&#8217;un qui viendrait du monde de Git.
Toutefois, il est possible de travailler sur un dépôt Bazaar depuis un dépôt Git.</p>
<p>Il y a plein de projets qui permettent d&#8217;utiliser Git comme client d&#8217;un dépôt Bazaar.
Ici nous utiliserons le projet de Felipe Contreras que vous pouvez trouver à l&#8217;adresse <a href="https://github.com/felipec/git-remote-bzr" class="link">https://github.com/felipec/git-remote-bzr</a>.
Pour l&#8217;installer, il suffit de télécharger le fichier <code class="literal">git-remote-bzr</code> dans un dossier de votre <code class="literal">$PATH</code> et de le rendre exécutable :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> wget https://raw.github.com/felipec/git-remote-bzr/master/git-remote-bzr -O ~/bin/git-remote-bzr
<span style="font-weight: bold">$</span> chmod +x ~/bin/git-remote-bzr</code></pre>
</figure>
<p>Vous devez aussi avoir Bazaar installé.
C&#8217;est tout !</p>
<section class="sect3" title="Créer un dépôt Git depuis un dépôt Bazaar">
<h4 id="_créer_un_dépôt_git_depuis_un_dépôt_bazaar">Créer un dépôt Git depuis un dépôt Bazaar</h4>
<p>C&#8217;est simple à utiliser.
Il suffit de cloner un dépôt Bazaar en préfixant son nom par <code class="literal">bzr::</code>.
Puisque Git et Bazaar font des copies complètes sur votre machine, il est possible de lier un clone Git à votre clone Bazaar local, mais ce n&#8217;est pas recommandé.
Il est beaucoup plus facile de lier votre clone Git directement au même endroit que l&#8217;est votre clone Bazaar ‒ le dépôt central.</p>
<p>Supposons que vous travailliez avec un dépôt distant qui se trouve à l&#8217;adresse <code class="literal">bzr+ssh://developpeur@monserveurbazaar:monprojet</code>.
Alors vous devez le cloner de la manière suivante :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone bzr::bzr+ssh://developpeur@monserveurbazaar:monprojet monProjet-Git
<span style="font-weight: bold">$</span> cd monProjet-Git</code></pre>
</figure>
<p>A ce stade, votre dépôt Git est créé mais il n&#8217;est pas compacté pour un usage optimal de l&#8217;espace disque.
C&#8217;est pourquoi vous devriez aussi nettoyer et compacter votre dépôt Git, surtout si c&#8217;est un gros dépôt :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc --aggressive</code></pre>
</figure>
</section>
<section class="sect3" title="Les branches Bazaar">
<h4 id="_les_branches_bazaar">Les branches Bazaar</h4>
<p>Bazaar ne vous permet de cloner que des branches, mais un dépôt peut contenir plusieurs branches, et <code class="literal">git-remote-bzr</code> peut cloner les deux.
Par exemple, pour cloner une branche :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone bzr::bzr://bzr.savannah.gnu.org/emacs/trunk emacs-trunk</code></pre>
</figure>
<p>Et pour cloner le dépôt entier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone bzr::bzr:/bzr.savannah.gnu.org/emacs emacs</code></pre>
</figure>
<p>La seconde commande clone toutes les branches contenues dans le dépôt emacs ; néanmoins il est possible de spécifier quelques branches :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config remote-bzr.branches <span style="font-style: italic">&#39;trunk, xwindow&#39;</span></code></pre>
</figure>
<p>Certains dépôts ne permettent pas de lister leurs branches, auquel cas vous devez les préciser manuellement, et même si vous pourriez spécifier la configuration dans la commande de clonage, vous pourriez trouver ceci plus facile :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init emacs
<span style="font-weight: bold">$</span> git remote add origin bzr::bzr://bzr.savannah.gnu.org/emacs
<span style="font-weight: bold">$</span> git config remote-bzr.branches <span style="font-style: italic">&#39;trunk, xwindow&#39;</span>
<span style="font-weight: bold">$</span> git fetch</code></pre>
</figure>
</section>
<section class="sect3" title="Ignorer ce qui est ignoré avec .bzrignore">
<h4 id="_ignorer_ce_qui_est_ignoré_avec_bzrignore">Ignorer ce qui est ignoré avec .bzrignore</h4>
<p>Puisque vous travaillez sur un projet géré sous Bazaar, vous ne devriez pas créer de fichier <code class="literal">.gitignore</code> car vous pourriez le mettre accidentellement en gestion de version et les autres personnes travaillant sous Bazaar en seraient dérangées.
La solution est de créer le fichier <code class="literal">.git/info/exclude</code>, soit en tant que lien symbolique, soit en tant que véritable fichier.
Nous allons voir plus loin comment trancher cette question.</p>
<p>Bazaar utilise le même modèle que Git pour ignorer les fichiers, mais possède en plus deux particularités qui n&#8217;ont pas d&#8217;équivalent dans Git.
La description complète se trouve dans <a href="http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/ignore-help.html" class="link">la documentation</a>.
Les deux particularités sont :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">le "!!" en début de chaîne de caractères qui prévaut sur le "!" en début de chaîne, ce qui permet d&#8217;ignorer des fichiers qui auraient été inclus avec "!"</span>
</li>
<li>
<span class="principal">les chaînes de caractères commençant par "RE:".
Ce qui suit "RE:" est une <a href="http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/patterns-help.html" class="link">expression rationnelle</a>.
Git ne permet pas d&#8217;utiliser des expressions rationnelles, seulement les globs shell.</span>
</li>
</ol>
</div>
<p>Par conséquent, il y a deux situations différentes à envisager :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Si le fichier <code class="literal">.bzrignore</code> ne contient aucun de ces deux préfixes particuliers, alors vous pouvez simplement faire un lien symbolique vers celui-ci dans le dépôt.</span>
</li>
<li>
<span class="principal">Sinon, vous devez créer le fichier <code class="literal">.git/info/exclude</code> et l&#8217;adapter pour ignorer exactement les mêmes fichiers que dans <code class="literal">.bzrignore</code>.</span>
</li>
</ol>
</div>
<p>Quel que soit le cas de figure, vous devrez rester vigilant aux modifications du fichier <code class="literal">.bzrignore</code> pour faire en sorte que le fichier <code class="literal">.git/info/exclude</code> reflète toujours <code class="literal">.bzrignore</code>.
En effet, si le fichier <code class="literal">.bzrignore</code> venait à changer et comporter une ou plusieurs lignes commençant par "!!" ou "RE:", Git ne pouvant interpréter ces lignes, il vous faudra adapter le fichier <code class="literal">.git/info/exclude</code> pour ignorer les mêmes fichiers que ceux ignorés avec <code class="literal">.bzrignore</code>.
De surcroît, si le fichier <code class="literal">.git/info/exclude</code> était un lien symbolique vers <code class="literal">.bzrignore</code>, il vous faudra alors d&#8217;abord détruire le lien symbolique, copier le fichier <code class="literal">.bzrignore</code> dans <code class="literal">.git/info/exclude</code> puis adapter ce dernier.
Attention toutefois à son élaboration car avec Git il est impossible de ré-inclure un fichier dont l&#8217;un des dossiers parent a été exclu.</p>
</section>
<section class="sect3" title="Récupérer les changements du dépôt distant">
<h4 id="_récupérer_les_changements_du_dépôt_distant">Récupérer les changements du dépôt distant</h4>
<p>Pour récupérer les changements du dépôt distant, vous tirez les modifications comme d&#8217;habitude, en utilisant les commandes Git.
En supposant que vos modifications sont sur la branche <code class="literal">master</code>, vous fusionnez ou rebasez votre travail sur la branche <code class="literal">origin/master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git pull --rebase origin</code></pre>
</figure>
</section>
<section class="sect3" title="Pousser votre travail sur le dépôt distant">
<h4 id="_pousser_votre_travail_sur_le_dépôt_distant">Pousser votre travail sur le dépôt distant</h4>
<p>Comme Bazaar a lui aussi le concept de <em>commits</em> de fusion, il n&#8217;y aura aucun problème si vous poussez un <em>commit</em> de fusion.
Donc vous créez vos branches et travaillez dessus, vous testez et validez votre travail par l&#8217;intermédiaire de <em>commits</em> comme d&#8217;habitude, puis vous fusionnez vos modifications dans <code class="literal">master</code> et vous poussez votre travail sur le dépôt Bazaar :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master</code></pre>
</figure>
</section>
<section class="sect3" title="Mise en garde">
<h4 id="_mise_en_garde">Mise en garde</h4>
<p>Le cadriciel de l&#8217;assistant de dépôt distant de Git a des limitations qui s&#8217;imposent.
En particulier, les commandes suivantes ne fonctionnent pas :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">git push origin :branche-à-effacer (Bazaar n&#8217;accepte pas de supprimer une branche de cette façon)</span>
</li>
<li>
<span class="principal">git push origin ancien:nouveau (il poussera <em>ancien</em>)</span>
</li>
<li>
<span class="principal">git push --dry-run origin branch (il poussera)</span>
</li>
</ul>
</div>
</section>
<section class="sect3" title="Résumé">
<h4 id="_résumé">Résumé</h4>
<p>Comme les modèles de Git et de Bazaar sont similaires, il n&#8217;y a pas beaucoup de difficulté à travailler à la frontière.
Tant que vous faites attention aux limitations, et tant que vous êtes conscient que le dépôt distant n&#8217;est pas nativement Git, tout ira bien.</p>
</section>
</section>
<section class="sect2" title="Git et Perforce">
<h3 id="_git_et_perforce">Git et Perforce</h3>
<p>

Perforce est un système de version très populaire dans les environnements professionnels.
Il existe depuis 1995, ce qui en fait le système le plus ancien abordé dans ce chapitre.
Avec cette information en tête, il apparaît construit avec les contraintes de cette époque ; il considère que vous êtes toujours connecté à un serveur central et une seule version est conservée sur le disque dur local.
C&#8217;est certain, ses fonctionnalités et ses contraintes correspondent à quelques problèmes spécifiques, mais de nombreux projets utilisent Perforce là où Git fonctionnerait réellement mieux.</p>
<p>Il y a deux options pour mélanger l&#8217;utilisation de Perforce et de Git.
La première que nous traiterons est le pont « Git Fusion » créé par les développeurs de Perforce, qui vous permet d&#8217;exposer en lecture-écriture des sous-arbres de votre dépôt Perforce en tant que dépôts Git.
La seconde s&#8217;appelle git-p4, un pont côté client qui permet d&#8217;utiliser Git comme un client Perforce, sans besoin de reconfigurer le serveur Perforce.</p>
<section class="sect3" title="Git Fusion">
<h4 id="s_p4_git_fusion">Git Fusion</h4>
<p>
Perforce fournit un produit appelé Git Fusion (disponible sur <a href="http://www.perforce.com/git-fusion" class="link">http://www.perforce.com/git-fusion</a>), qui synchronise un serveur Perforce avec des dépôts Git du côté serveur.</p>
<section class="sect4" title="Installation">
<h5 id="_installation_2">Installation</h5>
<p>Pour nos exemples, nous utiliserons la méthode d&#8217;installation de Git Fusion la plus facile qui consiste à télécharger une machine virtuelle qui embarque le <em>daemon</em> Perforce et Git Fusion.
Vous pouvez obtenir la machine virtuelle depuis <a href="http://www.perforce.com/downloads/Perforce/20-User" class="link">http://www.perforce.com/downloads/Perforce/20-User</a>, et une fois téléchargée, importez-la dans votre logiciel favori de virtualisation (nous utiliserons VirtualBox).</p>
<p>Au premier lancement de la machine, il vous sera demandé de personnaliser quelques mots de passe pour trois utilisateurs Linux (<code class="literal">root</code>, <code class="literal">perforce</code> et <code class="literal">git</code>), et de fournir un nom d&#8217;instance qui peut être utilisé pour distinguer cette installation des autres sur le même réseau.
Quand tout est terminé, vous verrez ceci :</p>
<figure class="image">
<div class="content">
<img src="images/git-fusion-boot.png" alt="L'écran de démarrage de la machine virtuelle Git Fusion."/>
</div>
<figcaption>Figure 1. L’écran de démarrage de la machine virtuelle Git Fusion.</figcaption>
</figure>
<p>Prenez note de l&#8217;adresse IP qui est indiquée ici, car nous en aurons besoin plus tard.
Ensuite, nous allons créer l&#8217;utilisateur Perforce.
Sélectionnez l&#8217;option « Login » en bas de l&#8217;écran et appuyez sur <em>Entrée</em> (ou connectez-vous en SSH à la machine), puis identifiez-vous comme <code class="literal">root</code>.
Ensuite, utilisez ces commandes pour créer un utilisateur :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> p4 -p localhost:1666 -u super user -f john
<span style="font-weight: bold">$</span> p4 -p localhost:1666 -u john passwd
<span style="font-weight: bold">$</span> exit</code></pre>
</figure>
<p>La première commande va ouvrir un éditeur VI pour personnaliser l&#8217;utilisateur, mais vous pouvez accepter les valeurs par défaut en tapant <code class="literal">:wq</code> et en appuyant sur <em>Entrée</em>.
La seconde vous demandera d&#8217;entrer le mot de passe deux fois.
C&#8217;est tout ce qu&#8217;il faut faire depuis une invite de commande, et on peut quitter la session.</p>
<p>L&#8217;action suivante consiste à indiquer à Git de ne pas vérifier les certificats SSL.
L&#8217;image Git Fusion contient un certificat, mais celui-ci ne correspond pas au domaine de l&#8217;adresse IP de votre machine virtuelle, donc Git va rejeter la connexion HTTPS.
Pour une installation permanente, consultez le manuel Perforce Git Fusion pour installer un certificat différent ; pour l&#8217;objet de notre exemple, ceci suffira :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> export GIT_SSL_NO_VERIFY=true</code></pre>
</figure>
<p>Maintenant, nous pouvons tester que tout fonctionne correctement.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://10.0.1.254/Talkhouse
Cloning into &#39;Talkhouse&#39;...
Username for &#39;https://10.0.1.254&#39;: john
Password for &#39;https://john@10.0.1.254&#39;:
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.</code></pre>
</figure>
<p>La machine virtuelle contient un projet exemple que vous pouvez cloner.
Ici, nous clonons via HTTPS, avec l&#8217;utilisateur <code class="literal">john</code> que nous avons créé auparavant ; Git demande le mot de passe pour cette connexion, mais le cache d&#8217;identifiant permettra de sauter cette étape par la suite.</p>
</section>
<section class="sect4" title="Configuration de Fusion">
<h5 id="_configuration_de_fusion">Configuration de Fusion</h5>
<p>Une fois que Git Fusion est installé, vous désirerez sûrement modifier la configuration.
C&#8217;est assez facile à faire via votre client Perforce favori ; rapatriez simplement le répertoire <code class="literal">//.git-fusion</code> du serveur Perforce dans votre espace de travail.
La structure du fichier ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files</code></pre>
</figure>
<p>Le répertoire <code class="literal">objects</code> est utilisé en interne par Git Fusion pour faire correspondre les objets Perforce avec Git et vice versa et il n&#8217;y a pas lieu d&#8217;y toucher.
Il y a un fichier <code class="literal">p4gf_config</code> global dans ce répertoire, ainsi qu&#8217;un fichier pour chaque dépôt.
Ce sont les fichiers de configuration qui déterminent comment Git Fusion se comporte.
Examinons le fichier à la racine :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[repo-creation]</span>
charset = <span style="font-style: italic">utf8</span>

<span style="font-weight: bold">[git-to-perforce]</span>
change-owner = <span style="font-style: italic">author</span>
enable-git-branch-creation = <span style="font-style: italic">yes</span>
enable-swarm-reviews = <span style="font-style: italic">yes</span>
enable-git-merge-commits = <span style="font-style: italic">yes</span>
enable-git-submodules = <span style="font-style: italic">yes</span>
preflight-commit = <span style="font-style: italic">none</span>
ignore-author-permissions = <span style="font-style: italic">no</span>
read-permission-check = <span style="font-style: italic">none</span>
git-merge-avoidance-after-change-num = <span style="font-style: italic">12107</span>

<span style="font-weight: bold">[perforce-to-git]</span>
http-url = <span style="font-style: italic">none</span>
ssh-url = <span style="font-style: italic">none</span>

<span style="font-weight: bold">[@features]</span>
imports = <span style="font-style: italic">False</span>
chunked-push = <span style="font-style: italic">False</span>
matrix2 = <span style="font-style: italic">False</span>
parallel-push = <span style="font-style: italic">False</span>

<span style="font-weight: bold">[authentication]</span>
email-case-sensitivity = <span style="font-style: italic">no</span></code></pre>
</figure>
<p>Nous ne nous étendrons pas sur les significations des différents paramètres, mais on voit que c&#8217;est un simple fichier INI, du même style que ceux utilisés par Git.
Ce fichier spécifie les options globales, qui peuvent être surchargées par chaque fichier de configuration spécifique à un dépôt, tel que <code class="literal">repos/Talkhouse/p4gf_config</code>.
Si vous ouvrez ce fichier, vous verrez une section <code class="literal">[@repo]</code> contenant des paramétrages différents des paramètres globaux par défaut.
Vous verrez aussi des sections ressemblant à ceci :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[Talkhouse-master]</span>
git-branch-name = <span style="font-style: italic">master</span>
view = <span style="font-style: italic">//depot/Talkhouse/main-dev/... ...</span></code></pre>
</figure>
<p>C&#8217;est la correspondance entre une branche Perforce et une branche Git.
Le nom de la section est libre, du moment qu&#8217;il est unique.
<code class="literal">git-branch-name</code> vous permet de convertir un chemin du dépôt qui serait encombrant sous Git en quelque chose de plus utilisable.
L&#8217;entrée <code class="literal">view</code> contrôle comment les fichiers Perforce sont transformés en dépôts Git, en utilisant la syntaxe standard de description de vue.
Des correspondances multiples peuvent être indiquées, comme dans cet exemple :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[multi-project-mapping]</span>
git-branch-name = <span style="font-style: italic">master</span>
view = <span style="font-style: italic">//depot/project1/main/... project1/...</span>
<span style="font-style: italic">       //depot/project2/mainline/... project2/...</span></code></pre>
</figure>
<p>De cette manière, si votre montage d&#8217;espace de travail normal change de structure de répertoires, vous pouvez répliquer cette modification dans le dépôt Git.</p>
<p>Le dernier fichier que nous examinerons est <code class="literal">users/p4gf_usermap</code>, qui fait correspondre les utilisateurs Perforce avec les utilisateurs Git, et qui n&#8217;est même pas nécessaire.
Quand une modification Perforce est convertie en <em>commit</em> Git, le comportement par défaut de Git Fusion consiste à rechercher l&#8217;utilisateur Perforce et à utiliser son adresse de courriel et son nom complet comme champs d&#8217;auteur/validateur dans Git.
Dans l&#8217;autre sens, le comportement par défaut consiste à rechercher l&#8217;utilisateur Perforce correspondant à l&#8217;adresse de courriel stockée dans le champ auteur du <em>commit</em> Git et de soumettre une modification avec cet identifiant (si les permissions l&#8217;accordent).
Dans la plupart des cas, ce comportement suffira, mais considérons tout de même le fichier de correspondance suivant :</p>
<figure class="listing">
<pre class="source language-"><code>john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"</code></pre>
</figure>
<p>Chaque ligne est de la forme <code class="literal">&lt;utilisateur&gt; &lt;courriel&gt; &lt;nom complet&gt;</code> et crée une correspondance unique.
Les deux premières lignes font correspondre deux adresses de courriel distinctes avec le même utilisateur Perforce.
C&#8217;est utile si vous avez créé des <em>commits</em> Git sous plusieurs adresses de courriel (ou modifié votre adresse de courriel), mais que vous voulez les faire correspondre au même utilisateur Perforce.
À la création d&#8217;un <em>commit</em> Git depuis une modification Perforce, la première ligne correspondant à l&#8217;utilisateur Perforce est utilisée pour fournir l&#8217;information d&#8217;auteur à Git.</p>
<p>Les deux dernières lignes masquent les noms réels de Bob et Joe dans les <em>commits</em> Git créés.
C&#8217;est très utile si vous souhaitez ouvrir les sources d&#8217;un projet interne, mais que vous ne souhaitez pas rendre public le répertoire de vos employés.
Notez que les adresses de courriel et les noms complets devraient être uniques, à moins que vous ne souhaitiez publier tous les <em>commits</em> Git avec un auteur unique fictif.</p>
</section>
<section class="sect4" title="Utilisation">
<h5 id="_utilisation">Utilisation</h5>
<p>Perforce Git Fusion est une passerelle à double-sens entre les contrôles de version Perforce et Git.
Voyons comment cela se passe du côté Git.
Nous supposerons que nous avons monté le projet « Jam » en utilisant le fichier de configuration ci-dessus, et que nous pouvons le cloner comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://10.0.1.254/Jam
Cloning into &#39;Jam&#39;...
Username for &#39;https://10.0.1.254&#39;: john
Password for &#39;https://ben@10.0.1.254&#39;:
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
<span style="font-weight: bold">$</span> git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
  remotes/origin/rel2.1
<span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam&#39;s NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone&#39;s lynx port.
[...]</code></pre>
</figure>
<p>La première fois que vous le faites, cela peut durer un certain temps.
Ce qui se passe, c&#8217;est que Git Fusion convertit toutes les modifications concernées de l&#8217;historique Perforce en <em>commits</em> Git.
Cela se passe localement sur le serveur, donc c&#8217;est plutôt rapide, mais si votre historique est long, ce n&#8217;est pas immédiat.
Les récupérations subséquentes ne lancent que des conversions incrémentales, ce qui devrait correspondre à la vitesse native de Git.</p>
<p>Comme vous pouvez le voir, notre dépôt ressemble complètement à un autre dépôt Git.
Il y a trois branches et Git a utilement créé une branche <code class="literal">master</code> locale qui suit la branche <code class="literal">origin/master</code>.
Travaillons un peu et créons une paire de <em>commits</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> ...
<span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam&#39;s NT handle leak.
[...]</code></pre>
</figure>
<p>Nous avons deux nouveaux <em>commits</em>.
Maintenant, vérifions si quelqu&#8217;un d&#8217;autre a aussi travaillé :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -&gt; origin/master
<span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam&#39;s NT handle leak.
[...]</code></pre>
</figure>
<p>Il semble bien !
Ça n&#8217;apparaît pas sur cette vue, mais le <em>commit</em> <code class="literal">6afeb15</code> a en fait été créé en utilisant un client Perforce.
Il ressemble juste à un commit normal du point de vue de Git, ce qui est exactement l&#8217;effet recherché.
Voyons comment le serveur Perforce gère le <em>commit</em> de fusion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Auto-merging README
Merge made by the &#39;recursive&#39; strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
<span style="font-weight: bold">$</span> git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -&gt; master</code></pre>
</figure>
<p>Git pense que ça a marché.
Voyons l&#8217;historique du fichier <code class="literal">README</code> du point de vue de Perforce, en utilisant la fonctionnalité de graphe de révision de <code class="literal">p4v</code> :</p>
<figure class="image">
<div class="content">
<img src="images/git-fusion-perforce-graph.png" alt="Graphe de révision de Perforce résultant d'une poussée depuis Git."/>
</div>
<figcaption>Figure 2. Graphe de révision de Perforce résultant d&#8217;une poussée depuis Git.</figcaption>
</figure>
<p>Si vous n&#8217;avez jamais vu ceci auparavant, cela peut dérouter, mais c&#8217;est une vue similaire à la vue graphique de l&#8217;historique Git.
Nous visualisons l&#8217;historique du fichier <code class="literal">README</code>, donc l&#8217;arbre de répertoire en haut à gauche ne montre que ce fichier, aux endroits où il apparaît dans différentes branches.
En haut à droite, nous avons le graphe visuel des relations entre les différentes révisions du fichier et la vue en grand du graphe en bas à droite.
Le reste de l&#8217;écran concerne la visualisation des détails pour la révision sélectionnée (<code class="literal">2</code> dans ce cas).</p>
<p>Une chose à noter est que le graphe ressemble exactement à celui de l&#8217;historique Git.
Perforce n&#8217;avait pas de branche nommée pour stocker les <em>commits</em> <code class="literal">1</code> et <code class="literal">2</code>, il a donc créé une branche « anonymous » dans le répertoire <code class="literal">.git-fusion</code> pour la gérer.
Cela arrivera aussi pour des branches Git nommées qui ne correspondent pas à une branche Perforce nommée (et que vous pouvez plus tard faire correspondre à une branche Perforce en utilisant le fichier de configuration).</p>
<p>Tout ceci se passe en coulisse, mais le résultat final est qu&#8217;une personne dans l&#8217;équipe peut utiliser Git, une autre Perforce et aucune des deux n&#8217;a à se soucier du choix de l&#8217;autre.</p>
</section>
<section class="sect4" title="Résumé Git-Fusion">
<h5 id="_résumé_git_fusion">Résumé Git-Fusion</h5>
<p>Si vous avez accès (ou pouvez avoir accès) à un votre serveur Perforce, Git Fusion est un excellent moyen de faire parler Git et Perforce ensemble.
Cela nécessite un peu de configuration, mais la courbe d&#8217;apprentissage n&#8217;est pas très raide.
C&#8217;est une des rares sections de ce chapitre où il est inutile de faire spécifiquement attention à ne pas utiliser toute la puissance de Git.
Cela ne signifie pas que Perforce sera ravi de tout ce que vous lui enverrez — si vous réécrivez l&#8217;historique qui a déjà été poussé, Git Fusion va le rejeter — Git Fusion cherche vraiment à sembler naturel.
Vous pouvez même utiliser les sous-modules Git (bien qu&#8217;ils paraîtront étranges pour les utilisateurs Perforce), et fusionner les branches (ce qui sera enregistré comme une intégration du côté Perforce).</p>
<p>Si vous ne pouvez pas convaincre un administrateur de votre serveur d&#8217;installer Git Fusion, il existe encore un moyen d&#8217;utiliser ces outils ensemble.</p>
</section>
</section>
<section class="sect3" title="Git-p4">
<h4 id="_git_p4">Git-p4</h4>
<p>
Git-p4 est une passerelle à double sens entre Git et Perforce.
Il fonctionne intégralement au sein de votre dépôt Git, donc vous n&#8217;avez besoin d&#8217;aucun accès au serveur Perforce (autre que les autorisations d&#8217;utilisateur, bien sûr).
Git-p4 n&#8217;est pas une solution aussi flexible ou complète que Git Fusion, mais il permet tout de même de réaliser la plupart des activités sans être invasif dans l&#8217;environnement serveur.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Vous aurez besoin de l&#8217;outil <code class="literal">p4</code> dans votre de chemin de recherche pour travailler avec <code class="literal">git-p4</code>.
À la date d&#8217;écriture du livre, il est disponible à <a href="http://www.perforce.com/downloads/Perforce/20-User" class="link">http://www.perforce.com/downloads/Perforce/20-User</a>.</p>
</div>
</aside>
<section class="sect4" title="Installation">
<h5 id="_installation_3">Installation</h5>
<p>Pour l&#8217;exemple, nous allons lancer le serveur Perforce depuis l&#8217;image Git Fusion, comme indiqué ci-dessus, mais nous n&#8217;utiliserons pas le serveur Git Fusion et nous dialoguerons avec la gestion de version Perforce directement.</p>
<p>Pour utiliser le client <code class="literal">p4</code> en ligne de commande (dont <code class="literal">git-p4</code> dépend), vous devrez définir quelques variables d&#8217;environnement :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> export P4PORT=10.0.1.254:1666
<span style="font-weight: bold">$</span> export P4USER=john</code></pre>
</figure>
</section>
<section class="sect4" title="Démarrage">
<h5 id="_démarrage_3">Démarrage</h5>
<p>Comme d&#8217;habitude avec Git, la première commande est un clonage :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</code></pre>
</figure>
<p>Cela crée ce qui en parlé Git s&#8217;appelle un clone « superficiel » (<strong>shallow</strong>) ; seule la toute dernière révision Perforce est importée dans Git ; souvenez-vous que Perforce n&#8217;a pas été pensé pour fournir toutes les révisions à chaque utilisateur.
C&#8217;est suffisant pour utiliser Git comme client Perforce, mais pour d&#8217;autres utilisations, ce n&#8217;est pas assez.</p>
<p>Une fois que c&#8217;est terminé, nous avons un dépôt Git complètement fonctionnel.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd myproject
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Notez le dépôt <code class="literal">p4</code> distant pour le serveur Perforce, mais tout le reste ressemble à un clone standard.
En fait, c&#8217;est trompeur ; ce n&#8217;est pas réellement dépôt distant.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote -v</code></pre>
</figure>
<p>Il n&#8217;y a pas du tout de dépôt distant.
Git-p4 a créé des références qui représentent l&#8217;état du serveur et celles-ci ressemblent à des références de dépôts distants dans <code class="literal">git log</code>, mais elles ne sont pas gérées par Git lui-même et vous ne pouvez pas pousser dessus.</p>
</section>
<section class="sect4" title="Utilisation">
<h5 id="_utilisation_2">Utilisation</h5>
<p>Donc, travaillons un peu.
Supposons que vous avez progressé sur une fonctionnalité très importante et que vous êtes prêt à la montrer au reste de votre équipe.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Nous avons réalisé deux nouveaux <em>commits</em> qui sont prêts à être soumis au serveur Perforce.
Vérifions si quelqu&#8217;un d&#8217;autre a poussé son travail entre temps.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Il semblerait que ce soit le cas, et <code class="literal">master</code> et <code class="literal">p4/master</code> ont divergé.
Le système de branchement de Perforce ne ressemble en rien à celui de Git, donc soumettre des <em>commits</em> de fusion n&#8217;a aucun sens.
Git-p4 recommande de rebaser vos <em>commits</em> et fournit même un raccourci pour le faire :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</figure>
<p>Vous pouvez déjà le deviner aux messages affichés, mais <code class="literal">git p4 rebase</code> est un raccourci pour <code class="literal">git p4 sync</code> suivi de <code class="literal">git rebase p4/master</code>.
C&#8217;est légèrement plus intelligent que cela, spécifiquement lors de la gestion de branches multiples, mais ça correspond bien.</p>
<p>À présent, notre historique est linéaire à nouveau et nous sommes prêts à remonter nos modifications sur Perforce.
La commande <code class="literal">git p4 submit</code> va essayer de créer une nouvelle révision Perforce pour chaque <em>commit</em> Git entre <code class="literal">p4/master</code> et <code class="literal">master</code>.
Son lancement ouvre notre éditeur favori et le contenu du fichier ouvert ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> A Perforce Change Specification.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span>  Change:      The change number. <span style="font-style: italic">&#39;new&#39;</span> on a new changelist.
<span style="font-weight: bold">#</span>  Date:        The date this specification was last modified.
<span style="font-weight: bold">#</span>  Client:      The client on which the changelist was created.  Read-only.
<span style="font-weight: bold">#</span>  User:        The user who created the changelist.
<span style="font-weight: bold">#</span>  Status:      Either <span style="font-style: italic">&#39;pending&#39;</span> or <span style="font-style: italic">&#39;submitted&#39;</span>. Read-only.
<span style="font-weight: bold">#</span>  Type:        Either <span style="font-style: italic">&#39;public&#39;</span> or <span style="font-style: italic">&#39;restricted&#39;</span>. Default is <span style="font-style: italic">&#39;public&#39;</span>.
<span style="font-weight: bold">#</span>  Description: Comments about the changelist.  Required.
<span style="font-weight: bold">#</span>  Jobs:        What opened jobs are to be closed by this changelist.
<span style="font-weight: bold">#</span>               You may delete jobs from this list.  (New changelists only.)
<span style="font-weight: bold">#</span>  Files:       What opened files from the default changelist are to be added
<span style="font-weight: bold">#</span>               to this changelist.  You may delete files from this list.
<span style="font-weight: bold">#</span>               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


<span style="font-weight: bold">#</span><span style="font-style: italic">####### git author ben@straub.cc does not match your p4 account.</span>
<span style="font-weight: bold">#</span><span style="font-style: italic">####### Use option --preserve-user to modify authorship.</span>
<span style="font-weight: bold">#</span><span style="font-style: italic">####### Variable git-p4.skipUserNameCheck hides this message.</span>
<span style="font-weight: bold">#</span><span style="font-style: italic">####### everything below this line is just the diff #######</span>
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 &lt;/td&gt;
 &lt;td valign=top&gt;
 Source and documentation for
-&lt;a href=&quot;http://www.perforce.com/jam/jam.html&quot;&gt;
+&lt;a href=&quot;jam.html&quot;&gt;
 Jam/MR&lt;/a&gt;,
 a software build tool.
 &lt;/td&gt;</code></pre>
</figure>
<p>C&#8217;est quasiment le même contenu qu&#8217;on verrait en lançant <code class="literal">p4 submit</code>, mis à part le bloc à la fin que git-p4 a utilement inclus.
Git-p4 essaye d&#8217;honorer vos réglages Git et Perforce individuellement quand il doit fournir un nom pour un <em>commit</em> ou une modification, mais dans certains cas, vous voudrez le modifier.
Par exemple, si le <em>commit</em> Git que vous importez a été écrit par un contributeur qui n&#8217;a pas de compte utilisateur dans Perforce, vous voudrez tout de même que la modification résultante ait l&#8217;air d&#8217;avoir été écrite par lui, et non par vous.</p>
<p>Git-p4 a importé le message du <em>commit</em> Git comme contenu de la modification Perforce, donc tout ce qu&#8217;il nous reste à faire et de sauvegarder et de quitter, deux fois (une fois par <em>commit</em>).
La sortie qui en résulte ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>À la sortie, c&#8217;est comme si nous avions fait un <code class="literal">git push</code>, ce qui est l&#8217;analogie la plus proche avec ce qui s&#8217;est réellement passé.</p>
<p>Notez aussi que durant ce processus, les <em>commits</em> Git sont transformés en modifications Perforce ; si vous voulez les comprimer en une seule modification, vous pouvez le faire avec un rebasage interactif avant de lancer <code class="literal">git p4 submit</code>.
Notez aussi que les empreintes SHA-1 de tous les <em>commits</em> qui ont été soumis comme modifications ont changé ; c&#8217;est parce que git-p4 ajoute une ligne à la fin de chaque message de validation qu&#8217;il convertit :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe &lt;john@example.com&gt;
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = &quot;//depot/www/live/&quot;: change = 12144]</code></pre>
</figure>
<p>Que se passe-t-il si vous essayez de soumettre un <em>commit</em> de fusion ?
Essayons pour voir.
Voici la situation dans laquelle nous sommes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch &#39;p4/master&#39;
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Les historiques Git et Perforce divergent à partir de 775a46f.
Le côté Git contient deux <em>commits</em>, puis un <em>commit</em> de fusion avec la tête Perforce, puis un autre <em>commit</em>.
Nous allons essayer de les soumettre au sommet d&#8217;un seul changement côté Perforce.
Voyons ce qui se passerait si nous essayions de soumettre cet historique maintenant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address</code></pre>
</figure>
<p>L&#8217;option <code class="literal">-n</code> est un raccourci pour <code class="literal">--dry-run</code> qui essaie d&#8217;afficher ce qui se passerait si la commande <code class="literal">submit</code> était réellement lancée.
Dans ce cas, il semble que nous créerions trois modifications Perforce, ce qui correspond aux trois <em>commits</em> sans fusion qui n&#8217;existent pas encore sur le serveur Perforce.
Cela ressemble exactement à ce que nous souhaitons, voyons comment cela se passe :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 submit
[…]
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Notre historique est devenu linéaire, comme si nous avions rebasé avant de soumettre (ce qui est exactement ce qui s&#8217;est passé).
Cela signifie que vous êtes libre de créer, modifier, jeter et fusionner les branches du côté Git sans crainte que votre historique deviennent à un moment incompatible avec Perforce.
Si vous pouvez le rebaser, vous pourrez le reporter dans le serveur Perforce.</p>
</section>
<section class="sect4" title="Branche">
<h5 id="s_git_p4_branches">Branche</h5>
<p>Si votre projet Perforce a de multiples branches, vous n&#8217;êtes pas malchanceux ; <code class="literal">git-p4</code> peut gérer cette configuration d&#8217;une manière similaire à Git.
Supposons que votre dépôt Perforce ait la forme suivante :</p>
<figure class="listing">
<pre class="source language-"><code>//depot
  └── project
      ├── main
      └── dev</code></pre>
</figure>
<p>Et supposons que vous ayez une branche <code class="literal">dev</code> qui contient une <em>view spec</em> qui ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-"><code>//depot/project/main/... //depot/project/dev/...</code></pre>
</figure>
<p>Git-p4 peut détecter automatiquement cette situation et faire ce qu&#8217;il faut :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
<span style="font-weight: bold">$</span> cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init</code></pre>
</figure>
<p>Notez le déterminant « <code class="literal">@all</code> » ; il indique à <code class="literal">git-p4</code> de cloner non seulement la dernière modification pour ce sous-arbre, mais aussi toutes les modifications qui ont déjà touché à ces chemins.
C&#8217;est plus proche du concept de clone dans Git, mais si vous travaillez sur un projet avec un long historique, cela peut prendre du temps à se terminer.</p>
<p>L&#8217;option <code class="literal">--detect-branches</code> indique à <code class="literal">git-p4</code> d&#8217;utiliser les spécifications de branche de Perforce pour faire correspondre aux références Git.
Si ces correspondances ne sont pas présentes sur le serveur Perforce (ce qui est une manière tout à fait valide d&#8217;utiliser Perforce), vous pouvez dire à <code class="literal">git-p4</code> ce que sont les correspondances de branches, et vous obtiendrez le même résultat :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init project
Initialized empty Git repository in /tmp/project/.git/
<span style="font-weight: bold">$</span> cd project
<span style="font-weight: bold">$</span> git config git-p4.branchList main:dev
<span style="font-weight: bold">$</span> git clone --detect-branches //depot/project@all .</code></pre>
</figure>
<p>Renseigner la variable de configuration <code class="literal">git-p4.branchList</code> à <code class="literal">main:dev</code> indique à <code class="literal">git-p4</code> que <code class="literal">main</code> et <code class="literal">dev</code> sont toutes deux des branches et que la seconde est la fille de la première.</p>
<p>Si nous lançons maintenant <code class="literal">git checkout -b dev p4/project/dev</code> et ajoutons quelques <em>commits</em>, git-p4 est assez intelligent pour cibler la bonne branche quand nous lançons <code class="literal">git-p4 submit</code>.
Malheureusement, <code class="literal">git-p4</code> ne peut pas mélanger les clones superficiels et les branches multiples ; si vous avez un projet gigantesque et que vous voulez travailler sur plus d&#8217;une branche, vous devrez lancer <code class="literal">git p4 clone</code> une fois pour chaque branche à laquelle vous souhaitez soumettre.</p>
<p>Pour créer ou intégrer des branches, vous devrez utiliser un client Perforce.
Git-p4 ne peut synchroniser et soumettre que sur des branches préexistantes, et il ne peut le faire qu&#8217;avec une modification linéaire à la fois.
Si vous fusionnez deux branches dans Git et que vous essayez de soumettre la nouvelle modification, tout ce qui sera enregistré sera une série de modifications de fichiers ; les métadonnées relatives aux branches impliquées dans cette intégration seront perdues.</p>
</section>
</section>
<section class="sect3" title="Résumé Git et Perforce">
<h4 id="_résumé_git_et_perforce">Résumé Git et Perforce</h4>
<p>Git-p4 rend possible l&#8217;usage des modes d&#8217;utilisation de Git avec un serveur Perforce, et ce, de manière plutôt réussie.
Cependant, il est important de se souvenir que Perforce gère les sources et qu&#8217;on ne travaille avec Git que localement.
Il faut rester vraiment attentif au partage de <em>commits</em> Git ; si vous avez un dépôt distant que d&#8217;autres personnes utilisent, ne poussez aucun <em>commit</em> qui n&#8217;a pas déjà été soumis au serveur Perforce.</p>
<p>Si vous souhaitez mélanger l&#8217;utilisation de Git et de Perforce comme clients pour la gestion de source sans restriction et si vous arrivez à convaincre un administrateur de l&#8217;installer, Git Fusion fait de Git un client de premier choix pour un serveur Perforce.</p>
</section>
</section>
<section class="sect2" title="Git et TFS">
<h3 id="_git_et_tfs">Git et TFS</h3>
<p>

Git est en train de devenir populaire chez les développeurs Windows et si vous écrivez du code pour Windows, il y a de fortes chances que vous utilisiez <em>Team Foundation Server</em> (TFS) de Microsoft.
TFS est une suite collaborative qui inclut le suivi de tickets et de tâches, le support de modes de développement Scrum et autres, la revue de code et la gestion de version.
Pour éviter toute confusion ultérieure, <strong>TFS</strong> est en fait le serveur, qui supporte la gestion de version de sources en utilisant à la fois Git et son propre gestionnaire de version, appelé <strong>TFVC</strong> (<em>Team Fundation Version Control</em>).
Le support de Git est une fonctionnalité assez nouvelle pour TFS (introduite dans la version 2013), donc tous les outils plus anciens font référence à la partie gestion de version comme « TFS », même s&#8217;ils ne fonctionnent réellement qu&#8217;avec TFVC.</p>
<p>Si vous vous trouvez au sein d&#8217;une équipe qui utilise TFVC mais que vous préférez utiliser Git comme client de gestionnaire de version, il y a un projet pour votre cas.</p>
<section class="sect3" title="Quel outil">
<h4 id="_quel_outil">Quel outil</h4>
<p>
En fait, il y en a deux : git-tf et git-tfs.</p>
<p>Git-tfs (qu&#8217;on peut trouver à <a href="http://git-tfs.com" class="link">http://git-tfs.com</a>) est un projet .NET et ne fonctionne que sous Windows (à l&#8217;heure de la rédaction du livre).
Pour travailler avec des dépôts Git, il utilise les liaisons .NET pour libgit2, une implémentation de Git orientée bibliothèque, qui est très performante et qui permet de manipuler avec beaucoup de flexibilité un dépôt Git à bas niveau.
Libgit2 n&#8217;est pas une implantation complète de Git, donc pour couvrir la différence, git-tfs va en fait appeler directement le client Git en ligne de commande pour certaines opérations de manière à éliminer les limites artificielles de ce qui est réalisable sur des dépôts Git.
Son support des fonctionnalités de TFVC est très mature, puisqu&#8217;il utilise les assemblages de Visual Studio pour les opérations avec les serveurs.
Cela implique que vous devez avoir accès à ces assemblages, ce qui signifie que vous devez installer une version récente de Visual Studio (n&#8217;importe quelle version depuis la version 2010, y compris la version Express depuis la version 2012), ou le SDK (Software Development Kit) Visual Studio.</p>
<p>Git-tf (dont le site est <a href="https://gittfs.codeplex.com" class="link">https://gittfs.codeplex.com</a>) est un projet Java et en tant que tel peut fonctionner sur tout ordinateur supportant l&#8217;environnement d&#8217;exécution Java.
Il s&#8217;interface avec les dépôts Git à travers JGit (une implantation sur JVM de Git), ce qui signifie qu&#8217;il n&#8217;y a virtuellement aucune limitation en termes de fonctionnalités Git.
Cependant, le support pour TFVC est plus limité comparé à git-tfs - il ne supporte pas les branches par exemple.</p>
<p>Donc chaque outil a ses avantages et ses défauts, et de nombreuses situations favorisent l&#8217;un par rapport à l&#8217;autre.
Nous décrirons l&#8217;utilisation de base de chaque outil.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Vous aurez besoin d&#8217;un accès à un dépôt TFVC pour pouvoir suivre les instructions qui vont suivre.
Il n&#8217;y en a pas beaucoup disponibles sur internet comme Git ou Subversion, et il se peut que vous deviez en créer un par vous-même.
Codeplex (<a href="https://www.codeplex.com" class="link">https://www.codeplex.com</a>) ou Visual Studio Online (<a href="http://www.visualstudio.com" class="link">http://www.visualstudio.com</a>) sont tous deux de bons choix.</p>
</div>
</aside>
</section>
<section class="sect3" title="Démarrage : git-tf">
<h4 id="_démarrage_code_class_literal_git_tf_code">Démarrage : <code class="literal">git-tf</code></h4>
<p>La première chose à faire, comme toujours avec Git, c&#8217;est de cloner.
Voici à quoi cela ressemble avec <code class="literal">git-tf</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git</code></pre>
</figure>
<p>Le premier argument est l&#8217;URL de la collection TFVC, le deuxième est de la forme <code class="literal">/projet/branche</code> et le troisième est le chemin vers le dépôt local Git à créer (celui-ci est optionnel).
Git-tf ne peut fonctionner qu&#8217;avec une branche à la fois ; si vous voulez valider sur une branche TFVC différente, vous devrez faire un nouveau clone de cette branche.</p>
<p>Cela crée un dépôt Git complètement fonctionnel :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd project_git
<span style="font-weight: bold">$</span> git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message</code></pre>
</figure>
<p>Ceci s&#8217;appelle un clone <em>superficiel</em>, ce qui signifie que seule la dernière révision a été téléchargée.
TFVC n&#8217;est pas conçu pour que chaque client ait une copie complète de l&#8217;historique, donc git-tf ne récupère que la dernière révision par défaut, ce qui est plus rapide.</p>
<p>Si vous avez du temps, il vaut peut-être le coup de cloner l&#8217;intégralité de l&#8217;historique du projet, en utilisant l&#8217;option <code class="literal">--deep</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main <span style="font-weight: bold; font-style: italic">\</span>
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
<span style="font-weight: bold">$</span> cd project_git
<span style="font-weight: bold">$</span> git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard</code></pre>
</figure>
<p>Remarquez les étiquettes comprenant des noms tels que <code class="literal">TFS_C35189</code> ; c&#8217;est une fonctionnalité qui vous aide à reconnaître quels <em>commits</em> Git sont associés à des modifications TFVC.
C&#8217;est une façon élégante de les représenter, puisque vous pouvez voir avec une simple commande <code class="literal">log</code> quels <em>commits</em> sont associés avec un instantané qui existe aussi dans TFVC.
Elles ne sont pas nécessaires (en fait, on peut les désactiver avec <code class="literal">git config git-tf.tag false</code>) – git-tf conserve les correspondances <em>commit</em>-modification dans le fichier <code class="literal">.git/git-tf</code>.</p>
</section>
<section class="sect3" title="Démarrage : git-tfs">
<h4 id="_démarrage_code_class_literal_git_tfs_code">Démarrage : <code class="literal">git-tfs</code></h4>
<p>Le clonage via Git-tfs se comporte légèrement différemment.
Observons :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs clone --with-branches \
    https<span style="border: 1px solid #FF0000">:</span>//username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository <span style="font-weight: bold">in</span> C<span style="border: 1px solid #FF0000">:</span>/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found<span style="border: 1px solid #FF0000">:</span>
- $/tfvc-test/featureA
The name of the local branch will be <span style="border: 1px solid #FF0000">:</span> featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674</code></pre>
</figure>
<p>Notez l&#8217;option <code class="literal">--with-branches</code>.
Git-tfs est capable de faire correspondre les branches de TFVC et Git, et cette option indique de créer une branche Git locale pour chaque branche TFVC.
C&#8217;est hautement recommandé si vous avez déjà fait des branches et des fusions dans TFS, mais cela ne fonctionnera pas avec un serveur plus ancien que TFS 2010 – avant cette version, les « branches » n&#8217;étaient que des répertoires et git-tfs ne peut pas les différencier de répertoires normaux.</p>
<p>Visitons le dépôt Git résultant :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/<span style="font-weight: bold">default</span>, master) Hello
* b75da1a New project
PS&gt; git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author<span style="border: 1px solid #FF0000">:</span> Ben Straub &lt;ben@straub.cc&gt;
Date<span style="border: 1px solid #FF0000">:</span>   Fri Aug 1 03<span style="border: 1px solid #FF0000">:</span>41<span style="border: 1px solid #FF0000">:</span>59 2014 +0000

    Hello

    git-tfs-id<span style="border: 1px solid #FF0000">:</span> [https<span style="border: 1px solid #FF0000">:</span>//username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16</code></pre>
</figure>
<p>Il y a deux branches locales, <code class="literal">master</code> et <code class="literal">featureA</code>, ce qui correspond au point de départ du clone (<code class="literal">Trunk</code> dans TFVC) et à une branche enfant (<code class="literal">featureA</code> dans TFVC).
Vous pouvez voir que le « dépôt distant » <code class="literal">tfs</code> contient aussi des références : <code class="literal">default</code> et <code class="literal">featureA</code> qui représentent les branches TFVC.
Git-tfs fait correspondre la branche que vous avez clonée depuis <code class="literal">tfs/default</code>, et les autres récupèrent leur propre nom.</p>
<p>Une autre chose à noter concerne les lignes <code class="literal">git-tfs-id:</code> dans les messages de validation.
Au lieu d&#8217;étiquettes, git-tfs utilise ces marqueurs pour faire le lien entre les modifications TFVC et les <em>commits</em> Git.
Cela implique que les <em>commits</em> Git vont avoir une empreinte SHA-1 différente entre avant et après avoir été poussés sur TFVC.</p>
</section>
<section class="sect3" title="Travail avec Git-tf[s]">
<h4 id="_travail_avec_git_tf_s">Travail avec Git-tf[s]</h4>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Indépendamment de chaque outil que vous utilisez, vous devriez renseigner quelques paramètres de configuration Git pour éviter les ennuis.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config set --local core.ignorecase=true
<span style="font-weight: bold">$</span> git config set --local core.autocrlf=false</code></pre>
</figure>
</div>
</aside>
<p>Evidemment, vous souhaitez ensuite travailler sur le projet.
TFVC et TFS ont des caractéristiques qui peuvent complexifier votre travail :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Les branches thématiques qui ne sont pas représentées dans TFVC ajoutent un peu de complexité.
Cela est dû à la manière <strong>très</strong> différente dont TFVC et Git représentent les branches.</span>
</li>
<li>
<span class="principal">Soyez conscient que TFVC permet aux utilisateurs d'« extraire » des fichiers depuis le serveur en les verrouillant pour qu&#8217;aucun autre utilisateur ne puisse les éditer.
Cela ne vous empêchera évidemment pas de les éditer dans votre dépôt local, mais cela pourrait être un obstacle au moment de pousser vos modifications sur le serveur TFVC.</span>
</li>
<li>
<span class="principal">TFS a le concept de validations « gardées », où un cycle de compilation/test TFS doit se terminer avec succès pour que la validation soit acceptée.
Cela utilise la fonction « enterrement » (<em>shelve</em>) dans TFVC, que nous ne détaillons pas en détail ici.
Vous pouvez simuler ceci manuellement avec git-tf, et git-tfs fournit la commande <code class="literal">checkintool</code> qui connaît le concept de garde.</span>
</li>
</ol>
</div>
<p>Pour abréger, nous n&#8217;allons traiter que le cas sans erreur, qui contourne ou évite quasiment tous les problèmes.</p>
</section>
<section class="sect3" title="Travail avec git-tf">
<h4 id="_travail_avec_code_class_literal_git_tf_code">Travail avec <code class="literal">git-tf</code></h4>
<p>Supposons que vous ayez travaillé et validé quelques <em>commits</em> sur <code class="literal">master</code> et que vous êtes prêt à partager votre progression sur le serveur TFVC.
Voici notre dépôt Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>Nous voulons prendre l&#8217;instantané qui est dans le <em>commit</em> <code class="literal">4178a82</code> et le pousser sur le serveur TFVC.</p>
<p>Tout d&#8217;abord, vérifions si un de nos collègues a fait quelque chose depuis notre dernière connexion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>Il semble que c&#8217;est le cas et nous avons maintenant un historique divergent.
C&#8217;est là où Git brille, mais nous avons deux options :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Faire un <em>commit</em> de fusion semble naturel pour un utilisateur Git (après tout, c&#8217;est ce que <code class="literal">git pull</code> réalise), et git-tf peut faire cela pour vous avec un simple <code class="literal">git tf pull</code>.
Gardez cependant à l&#8217;esprit que TFVC n&#8217;est pas conçu de cette manière et si vous poussez des <em>commits</em> de fusion, votre historique va commencer à être différent entre les deux côtés, ce qui peut être déroutant.
Cependant, si vous comptez soumettre tout votre travail comme une modification unique, c&#8217;est sûrement le choix le plus simple.</span>
</li>
<li>
<span class="principal">Rebaser pour rendre votre historique linéaire, ce qui signifie que nous avons l&#8217;option de convertir chaque <em>commit</em> Git en modification TFVC.
Comme c&#8217;est l&#8217;option qui laisse le plus de possibilités ouvertes, c&#8217;est la méthode recommandée ; <code class="literal">git-tf̀  facilite même cette méthode avec la commande `git tf pull --rebase</code>.</span>
</li>
</ol>
</div>
<p>Le choix reste le vôtre.
Pour cet exemple, nous rebaserons :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>À présent, nous sommes prêt à valider dans le serveur TFVC.
Git-tf vous laisse le choix de faire un changement unique qui représente toutes les modifications depuis le dernier réalisé (<code class="literal">--shallow</code>, par défaut) ou de créer une nouvelle modification pour chaque <em>commit</em> Git (<code class="literal">--deep</code>).
Pour cet exemple, nous allons créer une modification unique :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf checkin -m <span style="font-style: italic">&#39;Updating readme and code&#39;</span>
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>Il y a une nouvelle étiquette <code class="literal">TFS_C35348</code> qui indique que TFVC stocke le même instantané que le <em>commit</em> <code class="literal">5a0e25e</code>.
Il est important de noter que chaque <em>commit</em> Git n&#8217;a pas besoin d&#8217;avoir une contrepartie exacte dans TFVC ; le <em>commit</em> <code class="literal">6eb3eb5</code>, par exemple, n&#8217;existe pas sur le serveur.</p>
<p>C&#8217;est le style de gestion principal.
Gardez en tête les quelques autres aspects de cette utilisation :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">Il est impossible d&#8217;utiliser les branches.
Git-tf ne peut créer des dépôts Git qu&#8217;à partir d&#8217;une branche de TFVC à la fois.</span>
</li>
<li>
<span class="principal">Le serveur central est TFVC ou Git, pas les deux.
Différents clones git-tf du même dépôt TFVC peuvent avoir des empreintes SHA-1 différentes, ce qui sera un casse-tête sans fin.</span>
</li>
<li>
<span class="principal">Si la gestion dans votre équipe consiste à collaborer par Git et à synchroniser périodiquement avec TFVC, ne connectez TFVC qu&#8217;à un seul dépôt Git.</span>
</li>
</ul>
</div>
</section>
<section class="sect3" title="Travailler avec git-tfs">
<h4 id="_travailler_avec_code_class_literal_git_tfs_code">Travailler avec <code class="literal">git-tfs</code></h4>
<p>Déroulons le même scénario en utilisant <code class="literal">git-tfs</code>.
Voici les nouveaux <em>commits</em> que nous avons ajoutés à la branche <code class="literal">master</code> dans notre dépôt Git :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/<span style="font-weight: bold">default</span>) Hello
* b75da1a New project</code></pre>
</figure>
<p>Maintenant, voyons si quelqu&#8217;un a avancé pendant que nous travaillions de notre côté :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS&gt; git log --all --oneline --graph --decorate
* aea74a0 (tfs/<span style="font-weight: bold">default</span>) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>Oui, un collègue a ajouté une nouvelle modification TFVC, qui prend la forme du nouveau <em>commit</em> <code class="literal">aea74a0</code>, ce qui a fait avancer la branche <code class="literal">tfs/default</code>.</p>
<p>De la même manière qu&#8217;avec <code class="literal">git-tf</code>, nous avons deux options pour résoudre l&#8217;historique divergent :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Rebaser pour préserver l&#8217;historique linéaire,</span>
</li>
<li>
<span class="principal">fusionner pour préserver ce qui s&#8217;est réellement passé.</span>
</li>
</ol>
</div>
<p>Dans cet exemple, nous allons réaliser une validation « profonde » où chaque <em>commit</em> Git devient une modification TFVC, ce qui implique que nous rebasions.</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git rebase tfs/<span style="font-weight: bold">default</span>
First, rewinding head to replay your work on top of it...
Applying<span style="border: 1px solid #FF0000">:</span> update readme
Applying<span style="border: 1px solid #FF0000">:</span> update code
PS&gt; git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/<span style="font-weight: bold">default</span>) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>Nous voici prêts à réintégrer notre code dans le serveur TFVC.
Nous utiliserons la commande <code class="literal">rcheckin</code> pour créer des modifications TFVC pour chaque <em>commit</em> Git dans le parcours entre HEAD et la première branche distante <code class="literal">tfs</code> trouvée (la commande <code class="literal">checkin</code> ne créerait qu&#8217;une modification, comme si on compressait tous les <em>commits</em>).</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs rcheckin
Working with tfs remote<span style="border: 1px solid #FF0000">:</span> <span style="font-weight: bold">default</span>
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 <span style="font-style: italic">&#39;update readme&#39;</span>
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 <span style="font-style: italic">&#39;update code&#39;</span>
 edit .git\tfs\<span style="font-weight: bold">default</span>\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS&gt; git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/<span style="font-weight: bold">default</span>, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>Remarquez comment après chaque enregistrement réussi dans le serveur TFVC, git-tfs rebase le travail restant sur ce qui vient d&#8217;être intégré.
C&#8217;est dû à l&#8217;addition du champ <code class="literal">git-tfs-id</code> au bas du message de validation, qui modifie l&#8217;empreinte SHA-1 du <em>commit</em> dernièrement enregistré.
Cela se passe comme prévu et il n&#8217;y a pas lieu de s&#8217;en inquiéter, mais il faut garder à l&#8217;esprit cette transformation, spécialement si vous partagez des <em>commits</em> Git avec d&#8217;autres développeurs.</p>
<p>TFS a de nombreuses fonctionnalités intégrées avec le système de gestion de version, telles que les tâches, les revues, les enregistrements gardés, etc.
Travailler avec ces fonctionnalités à partir de la ligne de commande peut être lourd mais heureusement, git-tfs permet de lancer très facilement un outil d&#8217;enregistrement graphique :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs checkintool
PS&gt; git tfs ct</code></pre>
</figure>
<p>L&#8217;outil ressemble à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/git-tfs-ct.png" alt="L'outil d'enregistrement git-tfs."/>
</div>
<figcaption>Figure 3. L&#8217;outil d&#8217;enregistrement git-tfs.</figcaption>
</figure>
<p>Les utilisateurs de TFS le connaissent, puisque c&#8217;est la même boîte de dialogue que celle lancée depuis Visual Studio.</p>
<p>Git-tfs vous laisse aussi gérer vos branches TFVC depuis votre dépôt Git.
Par exemple, nous allons en créer une :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs branch $/tfvc-test/featureBee
The name of the local branch will be <span style="border: 1px solid #FF0000">:</span> featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS&gt; git lga
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/<span style="font-weight: bold">default</span>, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>Créer une branche dans TFVC signifie ajouter une modification où cette branche existe à présent, ce qui se traduit par un <em>commit</em> Git.
Notez aussi que git-tfs a <strong>créé</strong> la branche distante <code class="literal">tfs/featureBee</code>, mais <code class="literal">HEAD</code> pointe toujours sur <code class="literal">master</code>.
Si vous voulez travailler sur la toute nouvelle branche, vous souhaiterez baser vos nouveaux <em>commits</em> sur <code class="literal">1d54865</code>, peut-être en créant une branche thématique sur ce <em>commit</em>.</p>
</section>
<section class="sect3" title="Résumé Git et TFS">
<h4 id="_résumé_git_et_tfs">Résumé Git et TFS</h4>
<p>Git-tf et Git-tfs sont tous deux des grands outils pour s&#8217;interfacer avec un serveur TFVC.
Ils vous permettent d&#8217;utiliser la puissance de Git localement, vous évitant d&#8217;avoir sans arrêt à faire des aller-retours avec le serveur central TFVC et simplifie votre vie de développeur, sans forcer toute l&#8217;équipe à passer sous Git.
Si vous travaillez sous Windows (ce qui est très probable si votre équipe utilise TFS), vous souhaiterez utiliser git-tfs car ses fonctionnalités sont les plus complètes, mais si vous travaillez avec une autre plate-forme, vous utiliserez git-tf qui est plus limité.
Comme avec la plupart des outils vus dans ce chapitre, vous avez intérêt à vous standardiser sur un de ces systèmes de gestion de version et à utiliser l&#8217;autre comme miroir ‒ soit Git, soit TFVC doivent être le centre de collaboration, pas les deux.</p>
</section>
</section>
</section>
<section class="sect1" title="Migration vers Git">
<h2 id="s_migrating">Migration vers Git</h2>
<p>
Si vous avez une base de code existant dans un autre Système de Contrôle de Version (SCV) mais que vous avez décidé de commencer à utiliser Git, vous devez migrer votre projet d&#8217;une manière ou d&#8217;une autre.
Cette section passe en revue quelques importateurs pour des systèmes communs, et ensuite démontre comment développer votre propre importateur personnalisé.
Vous apprendrez comment importer les données depuis plusieurs des plus gros systèmes de gestion de configuration logicielle (<em>SCM</em>, <em>Software Configuration Management</em>) utilisés professionnellement, parce qu&#8217;ils comportent la majorité des utilisateurs qui basculent, et parce que des outils de haute qualité dédiés sont faciles à se procurer.</p>
<section class="sect2" title="Subversion">
<h3 id="_subversion">Subversion</h3>
<p>
</p>
<p>Si vous avez lu la section précédente concernant l&#8217;utilisation de <code class="literal">git svn</code>, vous pouvez utiliser facilement ces instructions pour <code class="literal">git svn clone</code> un dépôt ; ensuite, vous pouvez arrêter d&#8217;utiliser le serveur Subversion, pousser vers un nouveau serveur Git, et commencer à l&#8217;utiliser.
Si vous voulez l&#8217;historique, vous pouvez obtenir cela aussi rapidement que vous pouvez tirer les données hors du serveur Subversion (ce qui peut prendre un bout de temps).</p>
<p>Cependant, l&#8217;import n&#8217;est pas parfait ; et comme ça prendra tant de temps, autant le faire correctement.
Le premier problème est l&#8217;information d&#8217;auteur.
Dans Subversion, chaque personne qui crée un <em>commit</em> a un utilisateur sur le système qui est enregistré dans l&#8217;information de <em>commit</em>.
Les exemples dans la section précédente montrent <code class="literal">schacon</code> à quelques endroits, comme la sortie de <code class="literal">blame</code> et <code class="literal">git svn log</code>.
Si vous voulez faire correspondre cela à une meilleure donnée d&#8217;auteur Git, vous avez besoin d&#8217;une transposition des utilisateurs Subversion vers les auteurs Git.
Créez un fichier appelé <code class="literal">users.txt</code> qui a cette correspondance dans un format tel que celui-ci :</p>
<figure class="listing">
<pre class="source language-"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</figure>
<p>Pour obtenir une liste des noms d&#8217;auteur que SVN utilise, vous pouvez lancer ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> svn log --xml | grep author | sort -u | <span style="font-weight: bold; font-style: italic">\</span>
  perl -pe <span style="font-style: italic">&#39;s/.*&gt;(.*?)&lt;.*/$1 = /&#39;</span></code></pre>
</figure>
<p>Cela génère la sortie log dans le format XML, puis garde seulement les lignes avec l&#8217;information d&#8217;auteur, rejette les doublons, enlève les étiquettes XML.
(Bien sûr, cela ne marche que sur une machine ayant <code class="literal">grep</code>, <code class="literal">sort</code> et <code class="literal">perl</code> installés.)
Ensuite, redirigez cette sortie dans votre fichier users.txt afin que vous puissiez ajouter l&#8217;information d&#8217;utilisateur Git équivalente près de chaque entrée.</p>
<p>Vous pouvez fournir ce fichier à <code class="literal">git svn</code> pour l&#8217;aider à faire correspondre la donnée d&#8217;auteur plus précisément.
Vous pouvez aussi demander à <code class="literal">git svn</code> de ne pas inclure les metadonnées que Subversion importe normalement, en passant <code class="literal">--no-metadata</code> à la commande <code class="literal">clone</code> ou <code class="literal">init</code>.
Ceci fait ressembler votre commande <code class="literal">import</code> à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git-svn clone http://my-project.googlecode.com/svn/ <span style="font-weight: bold; font-style: italic">\</span>
      --authors-file=users.txt --no-metadata -s my_project</code></pre>
</figure>
<p>Maintenant vous devriez avoir un import Subversion plus joli dans votre dossier <code class="literal">my_project</code>.
Au lieu de <em>commits</em> qui ressemblent à ceci</p>
<figure class="listing">
<pre class="source language-"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</figure>
<p>ils ressemblent à ceci :</p>
<figure class="listing">
<pre class="source language-"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</figure>
<p>Non seulement le champ Auteur a l&#8217;air beaucoup mieux, mais le <code class="literal">git-svn-id</code> n&#8217;est plus là non plus.</p>
<p>Vous devriez aussi faire un peu de ménage post-import.
D&#8217;abord, vous devriez nettoyer les références bizarres que <code class="literal">git svn</code> a installées.
Premièrement vous déplacerez les étiquettes afin qu&#8217;elles soient de véritables étiquettes plutôt que d&#8217;étranges branches distantes, et ensuite vous déplacerez le reste des branches afin qu&#8217;elles soient locales.</p>
<p>Pour déplacer les étiquettes pour qu&#8217;elles soient des étiquettes Git propres, lancez</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/
<span style="font-weight: bold">$</span> rm -Rf .git/refs/remotes/origin/tags</code></pre>
</figure>
<p>Ceci prend les références qui étaient des branches distantes qui commençaient par <code class="literal">remotes/origin/tags</code> et en fait de vraies étiquettes (légères).</p>
<p>Ensuite, déplacez le reste des références sous <code class="literal">refs/remotes</code> pour qu&#8217;elles soient des branches locales :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp -Rf .git/refs/remotes/origin/* .git/refs/heads/
<span style="font-weight: bold">$</span> rm -Rf .git/refs/remotes/origin</code></pre>
</figure>
<p>Il peut arriver que vous voyiez quelques autres branches qui sont suffixées par <code class="literal">@xxx</code> (où xxx est un nombre), alors que dans Subversion vous ne voyez qu&#8217;une seule branche.
C&#8217;est en fait une fonctionnalité Subversion appelée « peg-revisions », qui est quelque chose pour laquelle Git n&#8217;a tout simplement pas d&#8217;équivalent syntaxique.
Donc, <code class="literal">git svn</code> ajoute simplement le numéro de version svn au nom de la branche de la même façon que vous l&#8217;auriez écrit dans svn pour adresser la « peg-revision » de cette branche.
Si vous ne vous souciez plus des « peg-revisions », supprimez-les simplement en utilisant <code class="literal">git branch -d</code>.</p>
<p>Maintenant toutes les vieilles branches sont de vraies branches Git et toutes les vieilles étiquettes sont de vraies étiquettes Git.</p>
<p>Il y a une dernière chose à nettoyer.
Malheureusement, <code class="literal">git svn</code> crée une branche supplémentaire appelée <code class="literal">trunk</code>, qui correspond à la branche par défaut de Subversion, mais la ref <code class="literal">trunk</code> pointe au même endroit que <code class="literal">master</code>.
Comme <code class="literal">master</code> est plus idiomatiquement Git, voici comment supprimer la branche supplémentaire :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -d trunk</code></pre>
</figure>
<p>La dernière chose à faire est d&#8217;ajouter votre nouveau serveur Git en tant que serveur distant et pousser vers lui.
Voici un exemple d&#8217;ajout de votre serveur en tant que serveur distant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@my-git-server:myrepository.git</code></pre>
</figure>
<p>Puisque vous voulez que vos branches et étiquettes montent, vous pouvez maintenant lancer :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin --all
<span style="font-weight: bold">$</span> git push origin --tags</code></pre>
</figure>
<p>Toutes vos branches et étiquettes devraient être sur votre nouveau serveur Git dans un import joli et propre.</p>
</section>
<section class="sect2" title="Mercurial">
<h3 id="_mercurial">Mercurial</h3>
<p>
Puisque Mercurial et Git ont des modèles assez similaires pour représenter les versions, et puisque Git est un peu plus flexible, convertir un dépôt depuis Mercurial vers Git est assez simple, en utilisant un outil appelé "hg-fast-export", duquel vous aurez besoin d&#8217;une copie :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</code></pre>
</figure>
<p>La première étape dans la conversion est d&#8217;obtenir un clone complet du dépôt Mercurial que vous voulez convertir :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</figure>
<p>L&#8217;étape suivante est de créer un fichier d&#8217;association d&#8217;auteur.
Mercurial est un peu plus indulgent que Git pour ce qu&#8217;il mettra dans le champ auteur pour les modifications, donc c&#8217;est le bon moment pour faire le ménage.
La génération de ceci tient en une ligne de commande dans un shell <code class="literal">bash</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd /tmp/hg-repo
<span style="font-weight: bold">$</span> hg log | grep user: | sort | uniq | sed <span style="font-style: italic">&#39;s/user: *//&#39;</span> &gt; ../authors</code></pre>
</figure>
<p>Cela prendra quelques secondes, en fonction de la longueur de l&#8217;historique de votre projet, et ensuite le fichier <code class="literal">/tmp/authors</code> ressemblera à quelque chose comme ceci :</p>
<figure class="listing">
<pre class="source language-"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</figure>
<p>Dans cet exemple, la même personne (Bob) a créé des modifications sous différents noms, dont l&#8217;un est correct, et dont un autre est complètement invalide pour un <em>commit</em> Git.
Hg-fast-import nous laisse régler cela en ajoutant <code class="literal">={nouveau nom et adresse de courriel}</code> à la fin de chaque ligne que l&#8217;on veut changer, et en enlevant les lignes pour les noms d&#8217;utilisateur auxquels on ne veut pas toucher.
Si tous les noms d&#8217;utilisateur ont l&#8217;air bien, nous n&#8217;aurons pas du tout besoin de ce fichier.
Dans cet exemple, nous voulons que notre fichier ressemble à cela :</p>
<figure class="listing">
<pre class="source language-"><code>bob=Bob Jones &lt;bob@company.com&gt;
bob@localhost=Bob Jones &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;
bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;</code></pre>
</figure>
<p>L&#8217;étape suivante consiste à créer notre nouveau dépôt Git, et à lancer le script d&#8217;export :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init /tmp/converted
<span style="font-weight: bold">$</span> cd /tmp/converted
<span style="font-weight: bold">$</span> /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</figure>
<p>L&#8217;option <code class="literal">-r</code> indique à hg-fast-export où trouver le dépôt Mercurial que l&#8217;on veut convertir, et l&#8217;option <code class="literal">-A</code> lui indique où trouver le fichier de correspondance d&#8217;auteur.
Le script analyse les modifications Mercurial et les convertit en un script pour la fonctionnalité "fast-import" de Git (que nous détaillerons un peu plus tard).
Cela prend un peu de temps (bien que ce soit <em>beaucoup plus</em> rapide que si c&#8217;était à travers le réseau), et la sortie est assez verbeuse :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc&#39;d objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

<span style="font-weight: bold">$</span> git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</figure>
<p>C&#8217;est à peu près tout ce qu&#8217;il y a.
Toutes les étiquettes Mercurial ont été converties en étiquettes Git, et les branches et marques-page Mercurial ont été convertis en branches Git.
Maintenant vous êtes prêt à pousser le dépôt vers son nouveau serveur d&#8217;hébergement :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@my-git-server:myrepository.git
<span style="font-weight: bold">$</span> git push origin --all</code></pre>
</figure>
</section>
<section class="sect2" title="Bazaar">
<h3 id="_bazaar">Bazaar</h3>
<p></p>
<p>Bazaar est un système de contrôle de version distribué tout comme Git, en conséquence de quoi il est assez facile de convertir un dépôt Bazaar en un dépôt Git.
Pour cela, vous aurez besoin d&#8217;importer le plugin <code class="literal">bzr-fastimport</code>.</p>
<section class="sect3" title="Obtenir le plugin bzr-fastimport">
<h4 id="_obtenir_le_plugin_bzr_fastimport">Obtenir le plugin bzr-fastimport</h4>
<p>La procédure d&#8217;installation du plugin <code class="literal">bzr-fastimport</code> est différente sur les systèmes type UNIX et sur Windows.</p>
<p>Dans le premier cas, le plus simple est d&#8217;installer le paquet <code class="literal">bzr-fastimport</code> avec toutes les dépendances requises.</p>
<p>Par exemple, sur Debian et dérivés, vous feriez comme cela :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo apt-get install bzr-fastimport</code></pre>
</figure>
<p>Avec RHEL, vous feriez ainsi :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo yum install bzr-fastimport</code></pre>
</figure>
<p>Avec Fedora, depuis la sortie de la version 22, le nouveau gestionnaire de paquets est dnf :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo dnf install bzr-fastimport</code></pre>
</figure>
<p>Si le paquet n&#8217;est pas disponible, vous pouvez l&#8217;installer en tant que plugin :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> mkdir --parents ~/.bazaar/plugins/   <span style="font-style: italic"># crée les dossiers nécessaires aux plugins</span>
<span style="font-weight: bold">$</span> cd ~/.bazaar/plugins/
<span style="font-weight: bold">$</span> bzr branch lp:bzr-fastimport fastimport   <span style="font-style: italic"># importe le plugin bzr-fastimport</span>
<span style="font-weight: bold">$</span> cd fastimport
<span style="font-weight: bold">$</span> sudo python setup.py install --record=files.txt   <span style="font-style: italic"># installe le plugin</span></code></pre>
</figure>
<p>Pour que ce plugin fonctionne, vous aurez aussi besoin du module Python <code class="literal">fastimport</code>.
Vous pouvez vérifier s&#8217;il est présent ou non et l&#8217;installer avec les commandes suivantes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> python -c <span style="font-style: italic">&quot;import fastimport&quot;</span>
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot; , line 1, in &lt;module&gt;
ImportError: No module named fastimport
<span style="font-weight: bold">$</span> pip install fastimport</code></pre>
</figure>
<p>S&#8217;il n&#8217;est pas disponible, vous pouvez le télécharger à l&#8217;adresse <a href="https://pypi.python.org/pypi/fastimport/" class="link">https://pypi.python.org/pypi/fastimport/</a>.</p>
<p>Dans le second cas (sous Windows), <code class="literal">bzr-fastimport</code> est automatiquement installé avec la version <em>standalone</em> et l&#8217;installation par défaut (laisser toutes les cases à cocher cochées).
Alors, vous n&#8217;avez rien à faire.</p>
<p>À ce stade, la façon d&#8217;importer un dépôt Bazaar diffère selon que vous n&#8217;avez qu&#8217;une seule branche ou que vous travaillez avec un dépôt qui a plusieurs branches.</p>
</section>
<section class="sect3" title="Projet avec une seule branche">
<h4 id="_projet_avec_une_seule_branche">Projet avec une seule branche</h4>
<p>Maintenant positionnez-vous dans le dossier qui contient votre dépôt Bazaar et initialisez le dépôt Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd /chemin/vers/le/depot/bzr
<span style="font-weight: bold">$</span> git init</code></pre>
</figure>
<p>Vous pouvez exporter simplement votre dépôt Bazaar et le convertir en un dépôt Git avec la commande suivante :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> bzr fast-export --plain . | git fast-import</code></pre>
</figure>
<p>Selon la taille du projet, votre dépôt Git est constitué dans un délai allant de quelques secondes à plusieurs minutes.</p>
</section>
<section class="sect3" title="Cas d&#8217;un projet avec une branche principale et une branche de travail">
<h4 id="_cas_d_un_projet_avec_une_branche_principale_et_une_branche_de_travail">Cas d&#8217;un projet avec une branche principale et une branche de travail</h4>
<p>Vous pouvez aussi importer un dépôt Bazaar qui contient plusieurs branches.
Supposons que vous avez deux branches : l&#8217;une représente la branche principale (monProjet.trunk), l&#8217;autre est la branche de travail (monProjet.travail).</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls
monProjet.trunk monProjet.travail</code></pre>
</figure>
<p>Créez le dépôt Git et placez-vous-y :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init depot-git
<span style="font-weight: bold">$</span> cd depot-git</code></pre>
</figure>
<p>Tirez la branche principale dans le dépôt git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> bzr fast-export --marks=../marks.bzr --plain ../monProjet.trunk | <span style="font-weight: bold; font-style: italic">\</span>
git fast-import --export-marks=../marks.git</code></pre>
</figure>
<p>Tirez la branche de travail dans le dépôt git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> bzr fast-export --marks=../marks.bzr --plain --git-branch=travail ../monProjet.travail | <span style="font-weight: bold; font-style: italic">\</span>
git fast-import --import-marks=../marks.git --export-marks=../marks.git</code></pre>
</figure>
<p>Maintenant, <code class="literal">git branch</code> vous montre la branche <code class="literal">master</code> tout comme la branche <code class="literal">travail</code>.
Vérifiez les logs pour vous assurer qu&#8217;ils sont complets et supprimez les fichiers <code class="literal">marks.bzr</code> et <code class="literal">marks.git</code>.</p>
</section>
<section class="sect3" title="Synchroniser l&#8217;index">
<h4 id="_synchroniser_l_index">Synchroniser l&#8217;index</h4>
<p>Quel que soit le nombre de branches que vous aviez et la méthode d&#8217;importation, votre index n&#8217;est pas synchronisé avec HEAD, et avec l&#8217;import de plusieurs branches, votre répertoire de travail n&#8217;est pas synchronisé non plus.
Cette situation se résout simplement avec la commande suivante :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset --hard HEAD</code></pre>
</figure>
</section>
<section class="sect3" title="Ignorer les fichiers qui étaient ignorés avec .bzrignore">
<h4 id="_ignorer_les_fichiers_qui_étaient_ignorés_avec_bzrignore">Ignorer les fichiers qui étaient ignorés avec .bzrignore</h4>
<p>Occupons-nous maintenant des fichiers à ignorer.
Il faut tout d&#8217;abord renommer le fichier <code class="literal">.bzrignore</code> en <code class="literal">.gitignore</code>.
Si le fichier <code class="literal">.bzrignore</code> contient une ou des lignes commençant par "!!" ou "RE:", il vous faudra en plus le modifier et peut-être créer de multiples fichiers <code class="literal">.gitignore</code> afin d&#8217;ignorer exactement les mêmes fichiers que le permettait <code class="literal">.bzrignore</code>.</p>
<p>Finalement, vous devrez créer un <em>commit</em> qui contient cette modification pour la migration :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv .bzrignore .gitignore
<span style="font-weight: bold">$</span> <span style="font-style: italic"># modifier le fichier .gitignore au besoin</span>
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;Migration de Bazaar vers Git&#39;</span></code></pre>
</figure>
</section>
<section class="sect3" title="Envoyer votre dépôt git sur le serveur">
<h4 id="_envoyer_votre_dépôt_git_sur_le_serveur">Envoyer votre dépôt git sur le serveur</h4>
<p>Nous y sommes enfin !
Vous pouvez maintenant pousser votre dépôt sur son nouveau serveur d&#8217;hébergement :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@mon-serveur-git:mon-depot-git.git
<span style="font-weight: bold">$</span> git push origin --all
<span style="font-weight: bold">$</span> git push origin --tags</code></pre>
</figure>
<p>La migration de Bazaar vers Git est maintenant terminée, vous pouvez travailler sur votre dépôt git.</p>
</section>
</section>
<section class="sect2" title="Perforce">
<h3 id="s_perforce_import">Perforce</h3>
<p>
Le système suivant dont vous allez voir l&#8217;importation est Perforce.
Ainsi que nous l&#8217;avons dit plus haut, il y a deux façons de permettre de faire parler Git et Perforce l&#8217;un avec l&#8217;autre : git-p4 et Perforce Git Fusion.</p>
<section class="sect3" title="Perforce Git Fusion">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<p>Git Fusion rend ce processus assez indolore.
Configurez les paramètres de votre projet, les correspondances utilisateur et les branches en utilisant un fichier de configuration (comme discuté dans <a id="xref-s_p4_git_fusion" href="#s_p4_git_fusion" class="xref">Git Fusion</a>), et clonez le dépôt.
Git Fusion vous laisse avec ce qui ressemble à un dépôt Git natif, qui est alors prêt à être poussé vers un hôte Git natif si vous le désirez.
Vous pouvez même utiliser Perforce comme hôte Git si vous ça vous plaît.</p>
</section>
<section class="sect3" title="Git-p4">
<h4 id="s_sect_git_p4">Git-p4</h4>
<p>Git-p4 peut aussi agir comme outil d&#8217;import.
Comme exemple, nous importerons le projet Jam depuis le Dépôt Public Perforce.
Pour définir votre client, vous devez exporter la variable d&#8217;environnement P4PORT pour pointer vers le dépôt Perforce :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> export P4PORT=public.perforce.com:1666</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Pour suivre tout le long, vous aurez besoin d&#8217;un dépôt Perforce auquel vous connecter.
Nous utiliserons le dépôt public à public.perforce.com pour nos exemples, mais vous pouvez utiliser n&#8217;importe quel dépôt auquel vous avez accès.</p>
</div>
</aside>
<p>
Lancez la commande <code class="literal">git p4 clone</code> pour importer le projet Jam depuis le serveur Perforce, en fournissant le chemin vers le dépôt et le projet dans lequel vous voulez importer le projet :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</figure>
<p>Ce projet particulier a seulement une branche, mais si vous avez des branches configurées avec des vues de branche (ou juste un ensemble de dossiers), vous pouvez utiliser l&#8217;option <code class="literal">--detect-branches</code> avec <code class="literal">git p4 clone</code> pour importer aussi toutes les branches du projet.
Voyez <a id="xref-s_git_p4_branches" href="#s_git_p4_branches" class="xref">Branche</a> pour plus de détails sur ceci.</p>
<p>A ce point, vous avez presque terminé.
Si vous allez dans le dossier <code class="literal">p4import</code> et lancez <code class="literal">git log</code>, vous pouvez voir le travail importé :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = &quot;//public/jam/src/&quot;: change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = &quot;//public/jam/src/&quot;: change = 7304]</code></pre>
</figure>
<p>Vous pouvez voir que <code class="literal">git-p4</code> a laissé un identifiant dans chaque message de <em>commit</em>.
C&#8217;est bien de garder cet identifiant-là, au cas où vous auriez besoin de référencer le numéro de changement Perforce plus tard.
Cependant, si vous souhaitez enlever l&#8217;identifiant, c&#8217;est maintenant le moment de le faire – avant que vous ne commenciez à travailler sur le nouveau dépôt.

Vous pouvez utiliser <code class="literal">git filter-branch</code> pour enlever en masse les chaînes d&#8217;identifiant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --msg-filter <span style="font-style: italic">&#39;sed -e &quot;/^\[git-p4:/d&quot;&#39;</span>
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p>Si vous lancez <code class="literal">git log</code>, vous pouvez voir que toutes les sommes de vérification SHA-1 pour les <em>commits</em> ont changé, mais les chaînes <code class="literal">git-p4</code> ne sont plus dans les messages de <em>commit</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</figure>
<p>Votre import est prêt à être poussé vers votre nouveau serveur Git.</p>
</section>
</section>
<section class="sect2" title="TFS">
<h3 id="s_git_tfs">TFS</h3>
<p>
Si votre équipe est en train de convertir son code source de TFVC à Git, vous voudrez la conversion de la plus haute fidélité que vous puissiez obtenir.
Cela signifie que, tandis que nous couvrions à la fois git-tfs et git-tf pour la section interop, nous couvrirons seulement git-tfs dans cette partie, parce que git-tfs supporte les branches, et c&#8217;est excessivement difficile en utilisant git-tf.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Ceci est une conversion à sens unique.
Le dépôt Git résultant ne pourra pas se connecter au projet TFVC original.</p>
</div>
</aside>
<p>La première chose à faire est d&#8217;associer les noms d&#8217;utilisateur.
TFC est assez permissif pour ce qui va dans le champ auteur pour les changements, mais Git veut un nom et une adresse de courriel lisibles par un humain.
Vous pouvez obtenir cette information depuis la ligne de commande client <code class="literal">tf</code>, comme ceci :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</code></pre>
</figure>
<p>Cela récupère toutes les modifications de l&#8217;historique du projet et les insère dans le fichier AUTHORS_TMP que nous traiterons pour en extraire la donnée de la colonne <em>Utilisateur</em> (la deuxième).
Ouvrez le fichier et trouvez à quels caractères commence et finit la colonne et remplacez, dans la ligne de commande suivante, les paramètres <code class="literal">11-20</code> de la commande <code class="literal">cut</code> par ceux que vous avez trouvés :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | sort | uniq &gt; AUTHORS</code></pre>
</figure>
<p>La commande <code class="literal">cut</code> ignore tout sauf les caractères 11-20 de chaque ligne.
La commande <code class="literal">tail</code> saute les deux premières lignes, qui sont des champs d&#8217;en-tête et des soulignés dans le style ASCII.
Le résultat de tout ceci est envoyé à <code class="literal">sort</code> et <code class="literal">uniq</code> pour éliminer les doublons, et sauvé dans un fichier nommé <code class="literal">AUTHORS</code>.
L&#8217;étape suivante est manuelle ; afin que git-tfs fasse un usage effectif de ce fichier, chaque ligne doit être dans ce format :</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>DOMAIN\username = User Name &lt;email@address.com&gt;</code></pre>
</figure>
<p>La partie gauche est le champ “utilisateur” de TFVC, et la partie droite du signe égal est le nom d&#8217;utilisateur qui sera utilisé pour les <em>commits</em> Git.</p>
<p>Une fois que vous avez ce fichier, la chose suivante à faire est de faire un clone complet du projet TFVC par lequel vous êtes intéressé :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs clone --with-branches --authors=AUTHORS https<span style="border: 1px solid #FF0000">:</span>//username.visualstudio.com/DefaultCollection $/project/Trunk project_git</code></pre>
</figure>
<p>Ensuite vous voudrez nettoyer les sections <code class="literal">git-tfs-id</code> du bas des messages de commit.
La commande suivante le fera :</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git <span style="font-weight: bold">filter</span>-branch -f --msg-filter <span style="font-style: italic">&#39;sed &quot;s/^git-tfs-id:.*$//g&quot;&#39;</span> <span style="font-style: italic">&#39;--&#39;</span> --all</code></pre>
</figure>
<p>Cela utilise la commande <code class="literal">sed</code> de l&#8217;environnement Git-bash pour remplacer n&#8217;importe quelle ligne commençant par "git-tfs-id:" par du vide que Git ignorera ensuite.</p>
<p>Une fois cela fait, vous êtes prêt à ajouter un nouveau serveur distant, y pousser toutes les branches, et vous avez votre équipe prête à commencer à travailler depuis Git.</p>
</section>
<section class="sect2" title="Un importateur personnalisé">
<h3 id="s_custom_importer">Un importateur personnalisé</h3>
<p>

Si votre système n&#8217;est pas un de ceux ci-dessus, vous devriez chercher un importateur en ligne – des importateurs de qualité sont disponibles pour plein d&#8217;autres systèmes, incluant CVS, Clear Case, Visual Source Safe, même un dossier d&#8217;archives.
Si aucun de ces outils ne fonctionne pour vous, vous avez un outil plus obscur, ou alors vous avez besoin d&#8217;un procédé d&#8217;importation personnalisé, vous devriez utiliser <code class="literal">git fast-import</code>.
Cette commande lit des instructions simples depuis l&#8217;entrée standard pour écrire des données Git spécifiques.
Il est bien plus facile de créer des objets Git de cette façon que de lancer des commandes Git brutes ou que d&#8217;essayer d&#8217;écrire les objets bruts (voir <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Les tripes de Git</a> pour plus d&#8217;informations).
De cette façon, vous pouvez écrire un script d&#8217;importation qui lit l&#8217;information nécessaire hors du système duquel vous importez et qui affiche les instructions directement dans la sortie standard.
Vous pouvez alors lancer ce programme et envoyer sa sortie à travers un tube dans <code class="literal">git fast-import</code>.</p>
<p>Pour démontrer rapidement, vous écrirez un importateur simple.
Supposez que vous travaillez dans <code class="literal">current</code>, vous sauvegardez votre projet en copiant occasionnellement le dossier dans un dossier de sauvegarde estampillé de la date <code class="literal">back_YYYY_MM_DD</code>, et vous voulez importer cela dans Git.
Votre structure de dossier ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</figure>
<p>Pour importer un dossier Git, vous devez passer en revue comment Git stocke ses données.
Comme vous vous le rappelez, Git est fondamentalement une liste liée d&#8217;objets <em>commit</em> qui pointent sur un instantané de contenu.
Tout ce que vous avez à faire est de dire à <code class="literal">fast-import</code> ce que sont les instantanés de contenu, quelles données de <em>commit</em> pointent sur eux, et l&#8217;ordre dans lequel ils vont.
Votre stratégie sera d&#8217;explorer les instantanés un à un et créer les <em>commits</em> avec les contenus dans chaque dossier, en liant chaque <em>commit</em> avec le précédent.</p>
<p>Comme nous l&#8217;avons fait dans <a id="xref--ch08-customizing-git--s_an_example_git_enforced_policy" href="ch08-customizing-git.xhtml#s_an_example_git_enforced_policy" class="xref">Exemple de politique gérée par Git</a>, nous écrirons ceci en Ruby, parce que c&#8217;est ce avec quoi nous travaillons généralement et ça a tendance à être facile à lire.
Vous pouvez écrire cet exemple assez facilement avec n&#8217;importe quel langage de programmation auquel vous êtes familier – il faut seulement afficher l&#8217;information appropriée dans <code class="literal">stdout</code>.
Et, si vous travaillez sous Windows, cela signifie que vous devrez prendre un soin particulier à ne pas introduire de retour chariot (carriage return, CR) à la fin de vos lignes – <code class="literal">git fast-import</code> est très exigeant ; il accepte seulement la fin de ligne (Line Feed, LF) et pas le retour chariot fin de ligne (CRLF) que Windows utilise.</p>
<p>Pour commencer, vous vous placerez dans le dossier cible et identifierez chaque sous-dossier, chacun étant un instantané que vous voulez importer en tant que <em>commit</em>.
Vous vous placerez dans chaque sous-dossier et afficherez les commandes nécessaires pour l&#8217;exporter.
Votre boucle basique principale ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>last_mark = <span style="font-weight: bold">nil</span>

<span style="font-style: italic"># boucle sur les dossiers</span>
Dir.chdir(ARGV[0]) <span style="font-weight: bold">do</span>
  Dir.glob(<span style="font-style: italic">&quot;*&quot;</span>).each <span style="font-weight: bold">do</span> |dir|
    <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> File.file?(dir)

    <span style="font-style: italic"># rentre dans chaque dossier cible</span>
    Dir.chdir(dir) <span style="font-weight: bold">do</span>
      last_mark = print_export(dir, last_mark)
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Vous lancez <code class="literal">print_export</code> à l&#8217;intérieur de chaque dossier, qui prend le manifeste et la marque de l&#8217;instantané précédent et retourne la marque et l&#8217;empreinte de celui-ci ; de cette façon, vous pouvez les lier proprement.
“Marque” est le terme de <code class="literal">fast-import</code> pour un identifiant que vous donnez à un <em>commit</em> ; au fur et à mesure que vous créez des <em>commits</em>, vous donnez à chacun une marque que vous pouvez utiliser pour le lier aux autres <em>commits</em>.
Donc, la première chose à faire dans votre méthode <code class="literal">print_export</code> est de générer une marque à partir du nom du dossier :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>mark = convert_dir_to_mark(dir)</code></pre>
</figure>
<p>Vous ferez ceci en créant un tableau de dossiers et en utilisant la valeur d&#8217;index comme marque, car une marque doit être un nombre entier.
Votre méthode ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$marks = []
<span style="font-weight: bold">def</span> convert_dir_to_mark(dir)
  <span style="font-weight: bold">if</span> !$marks.include?(dir)
    $marks &lt;&lt; dir
  <span style="font-weight: bold">end</span>
  ($marks.index(dir) + 1).to_s
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Maintenant que vous avez une représentation par un entier de votre <em>commit</em>, vous avez besoin d&#8217;une date pour les métadonnées du <em>commit</em>.
Puisque la date est exprimée dans le nom du dossier, vous l&#8217;analyserez.
La ligne suivante dans votre fichier <code class="literal">print_export</code> est</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>date = convert_dir_to_date(dir)</code></pre>
</figure>
<p>où <code class="literal">convert_dir_to_date</code> est définie comme</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> convert_dir_to_date(dir)
  <span style="font-weight: bold">if</span> dir == <span style="font-style: italic">&#39;current&#39;</span>
    <span style="font-weight: bold">return</span> Time.now().to_i
  <span style="font-weight: bold">else</span>
    dir = dir.gsub(<span style="font-style: italic">&#39;back_&#39;</span>, <span style="font-style: italic">&#39;&#39;</span>)
    (year, month, day) = dir.split(<span style="font-style: italic">&#39;_&#39;</span>)
    <span style="font-weight: bold">return</span> Time.local(year, month, day).to_i
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Cela retourne une valeur entière pour la date de chaque dossier.
Le dernier bout de méta-information dont vous avez besoin pour chaque <em>commit</em> est la donnée de l&#8217;auteur, que vous codez en dur dans une variable globale :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$author = <span style="font-style: italic">&#39;John Doe &lt;john@example.com&gt;&#39;</span></code></pre>
</figure>
<p>Maintenant vous êtes prêt à commencer à publier l&#8217;information de <em>commit</em> pour votre importateur.
L&#8217;information initiale déclare que vous êtes en train de définir un objet <em>commit</em> et sur quelle branche il est, suivi de la marque que vous avez générée, l&#8217;information d&#8217;auteur et le message de <em>commit</em>, et ensuite le précédent <em>commit</em>, s&#8217;il y en a un.
Le code ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic"># affiche l&#39;information d&#39;import</span>
puts <span style="font-style: italic">&#39;commit refs/heads/master&#39;</span>
puts <span style="font-style: italic">&#39;mark :&#39;</span> + mark
puts <span style="font-style: italic">&quot;committer </span><span style="font-weight: bold; font-style: italic">#{</span>$author<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>date<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> -0700&quot;</span>
export_data(<span style="font-style: italic">&#39;imported from &#39;</span> + dir)
puts <span style="font-style: italic">&#39;from :&#39;</span> + last_mark <span style="font-weight: bold">if</span> last_mark</code></pre>
</figure>
<p>Vous codez en dur le fuseau horaire (-0700) parce que c&#8217;est facile de faire ainsi.
Si vous importez depuis un autre système, vous devez spécifier le fuseau horaire comme décalage.
Le message de <em>commit</em> doit être exprimé dans un format spécial :</p>
<figure class="listing">
<pre class="source language-"><code>data (taille)\n(contenu)</code></pre>
</figure>
<p>Le format est constitué du mot data, de la taille de la donnée à lire, d&#8217;une nouvelle ligne et finalement de la donnée.
Comme vous avez besoin d&#8217;utiliser le même format pour spécifier le contenu du fichier plus tard, vous créez une méthode assistante, <code class="literal">export_data</code> :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> export_data(string)
  print <span style="font-style: italic">&quot;data </span><span style="font-weight: bold; font-style: italic">#{</span>string.size<span style="font-weight: bold; font-style: italic">}\n#{</span>string<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Tout ce qui reste à faire est de spécifier le contenu du fichier pour chaque instantané.
C&#8217;est facile, car vous les avez dans un dossier – vous pouvez imprimer la commande <code class="literal">deleteall</code> suivie par le contenu de chaque fichier du dossier.
Git enregistrera ensuite chaque instantané de manière appropriée :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>puts <span style="font-style: italic">&#39;deleteall&#39;</span>
Dir.glob(<span style="font-style: italic">&quot;**/*&quot;</span>).each <span style="font-weight: bold">do</span> |file|
  <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> !File.file?(file)
  inline_data(file)
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Note : Comme beaucoup de systèmes conçoivent leurs révisions comme des changements d&#8217;un <em>commit</em> à l&#8217;autre, fast-import peut aussi prendre des commandes avec chaque <em>commit</em> pour spécifier quels fichiers ont été ajoutés, supprimés ou modifiés et ce qu&#8217;est le nouveau contenu.
Vous pourriez calculer les différences entre instantanés et fournir seulement cette donnée, mais faire ainsi est plus complexe – vous pouvez aussi bien donner à Git toutes les données et le laisser faire.
Si cela convient mieux pour vos données, référez-vous à la page de manuel <code class="literal">fast-import</code> pour les détails sur la manière de fournir les données de cette façon.</p>
<p>Le format pour lister le contenu d&#8217;un nouveau fichier ou pour spécifier un fichier modifié avec le nouveau contenu est le suivant :</p>
<figure class="listing">
<pre class="source language-"><code>M 644 inline path/to/file
data (taille)
(contenu du fichier)</code></pre>
</figure>
<p>Ici, 644 est le mode (si vous avez des fichiers exécutables, vous devez le détecter et spécifier 755 à la place), et <code class="literal">inline</code> dit que vous listerez le contenu immédiatement après cette ligne.
Votre méthode <code class="literal">inline_data</code> ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> inline_data(file, code = <span style="font-style: italic">&#39;M&#39;</span>, mode = <span style="font-style: italic">&#39;644&#39;</span>)
  content = File.read(file)
  puts <span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">#{</span>code<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>mode<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> inline </span><span style="font-weight: bold; font-style: italic">#{</span>file<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
  export_data(content)
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Vous réutilisez la méthode <code class="literal">export_data</code> que vous avez définie plus tôt, parce que c&#8217;est de la même façon que vous avez spécifié vos données du message de <em>commit</em>.</p>
<p>La dernière chose que vous avez besoin de faire est de retourner la marque courante pour qu&#8217;elle soit passée à la prochaine itération :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">return</span> mark</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Si vous êtes sous Windows, vous devrez vous assurer d&#8217;ajouter une étape supplémentaire.
Comme mentionné précédemment, Windows utilise CRLF comme caractères de fin de ligne alors que <code class="literal">git fast-import</code> ne s&#8217;attend qu&#8217;à LF.
Pour contourner ce problème et satisfaire <code class="literal">git fast-import</code>, vous devez indiquer à Ruby d&#8217;utiliser LF au lieu de CRLF :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$stdout.binmode</code></pre>
</figure>
</div>
</aside>
<p>Et voilà.
Voici le script dans son intégralité :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

$stdout.binmode
$author = <span style="font-style: italic">&quot;John Doe &lt;john@example.com&gt;&quot;</span>

$marks = []
<span style="font-weight: bold">def</span> convert_dir_to_mark(dir)
    <span style="font-weight: bold">if</span> !$marks.include?(dir)
        $marks &lt;&lt; dir
    <span style="font-weight: bold">end</span>
    ($marks.index(dir)+1).to_s
<span style="font-weight: bold">end</span>


<span style="font-weight: bold">def</span> convert_dir_to_date(dir)
    <span style="font-weight: bold">if</span> dir == <span style="font-style: italic">&#39;current&#39;</span>
        <span style="font-weight: bold">return</span> Time.now().to_i
    <span style="font-weight: bold">else</span>
        dir = dir.gsub(<span style="font-style: italic">&#39;back_&#39;</span>, <span style="font-style: italic">&#39;&#39;</span>)
        (year, month, day) = dir.split(<span style="font-style: italic">&#39;_&#39;</span>)
        <span style="font-weight: bold">return</span> Time.local(year, month, day).to_i
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> export_data(string)
    print <span style="font-style: italic">&quot;data </span><span style="font-weight: bold; font-style: italic">#{</span>string.size<span style="font-weight: bold; font-style: italic">}\n#{</span>string<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> inline_data(file, code=<span style="font-style: italic">&#39;M&#39;</span>, mode=<span style="font-style: italic">&#39;644&#39;</span>)
    content = File.read(file)
    puts <span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">#{</span>code<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>mode<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> inline </span><span style="font-weight: bold; font-style: italic">#{</span>file<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
    export_data(content)
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts <span style="font-style: italic">&#39;commit refs/heads/master&#39;</span>
    puts <span style="font-style: italic">&quot;mark :</span><span style="font-weight: bold; font-style: italic">#{</span>mark<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
    puts <span style="font-style: italic">&quot;committer </span><span style="font-weight: bold; font-style: italic">#{</span>$author<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>date<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> -0700&quot;</span>
    export_data(<span style="font-style: italic">&quot;imported from </span><span style="font-weight: bold; font-style: italic">#{</span>dir<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>)
    puts <span style="font-style: italic">&quot;from :</span><span style="font-weight: bold; font-style: italic">#{</span>last_mark<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span> <span style="font-weight: bold">if</span> last_mark

    puts <span style="font-style: italic">&#39;deleteall&#39;</span>
    Dir.glob(<span style="font-style: italic">&quot;**/*&quot;</span>).each <span style="font-weight: bold">do</span> |file|
        <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> !File.file?(file)
        inline_data(file)
    <span style="font-weight: bold">end</span>
    mark
<span style="font-weight: bold">end</span>


<span style="font-style: italic"># explore les dossiers</span>
last_mark = <span style="font-weight: bold">nil</span>
Dir.chdir(ARGV[0]) <span style="font-weight: bold">do</span>
    Dir.glob(<span style="font-style: italic">&quot;*&quot;</span>).each <span style="font-weight: bold">do</span> |dir|
        <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> File.file?(dir)

        <span style="font-style: italic"># move into the target directory</span>
        Dir.chdir(dir) <span style="font-weight: bold">do</span>
            last_mark = print_export(dir, last_mark)
        <span style="font-weight: bold">end</span>
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Si vous lancez ce script, vous obtiendrez un contenu qui ressemble à peu près à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
<span style="font-weight: bold">#</span> Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
<span style="font-weight: bold">#</span>!/bin/env ruby

puts &quot;Hey there&quot;
M 644 inline README.md
(...)</code></pre>
</figure>
<p>Pour lancer l&#8217;importateur, envoyez à travers un tube cette sortie à <code class="literal">git fast-import</code> pendant que vous êtes dans le dossier Git dans lequel vous voulez importer.
Vous pouvez créer un nouveau dossier et ensuite exécuter <code class="literal">git init</code> à l&#8217;intérieur de celui-ci comme point de départ, et ensuite exécuter votre script :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init
Initialized empty Git repository in /opt/import_to/.git/
<span style="font-weight: bold">$</span> ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc&#39;d objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</figure>
<p>Comme vous pouvez le voir, lorsque c&#8217;est terminé avec succès, il vous donne un lot de statistiques sur ce qu&#8217;il a fait.
Dans ce cas-ci, vous avez importé un total de 13 objets pour 4 <em>commits</em> dans une branche.
Maintenant, vous pouvez lancer <code class="literal">git log</code> pour voir votre nouvel historique :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</figure>
<p>Vous y voilà — un dépôt Git beau et propre.
Il est important de noter que rien n&#8217;est extrait – vous n&#8217;avez d&#8217;abord aucun fichier dans votre répertoire de travail.
Pour les obtenir, vous devez réinitialiser votre branche là où <code class="literal">master</code> est maintenant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls
<span style="font-weight: bold">$</span> git reset --hard master
HEAD is now at 3caa046 imported from current
<span style="font-weight: bold">$</span> ls
README.md main.rb</code></pre>
</figure>
<p>Vous pouvez faire beaucoup plus avec l&#8217;outil <code class="literal">fast-import</code> – manipuler différents modes, les données binaires, les branches multiples et la fusion, les étiquettes, les indicateurs de progression, et plus encore.
Nombre d&#8217;exemples de scénarios plus complexes sont disponibles dans le dossier <code class="literal">contrib/fast-import</code> du code source Git.</p>
</section>
</section>
<section class="sect1" title="Résumé">
<h2 id="_résumé_2">Résumé</h2>
<p>Vous devriez être à l&#8217;aise en utilisant Git comme client pour d&#8217;autres systèmes de contrôle de version, ou en important presque n&#8217;importe quel dépôt existant dans Git sans perdre de donnée.
Dans le prochain chapitre, nous couvrirons les tripes brutes de Git afin que vous puissiez travailler chaque octet, si besoin est.</p>
</section>
</section>
</body>
</html>