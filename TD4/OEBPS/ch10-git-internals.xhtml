<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
<meta charset="UTF-8"/>
<title>Les tripes de Git</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Les tripes de Git" epub:type="chapter" id="ch10-git-internals">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Les</b> <b>tripes</b> <b>de</b> <b>Git</b></small></h1>
</div>
</header>
<p>Vous êtes peut-être arrivé à ce chapitre en en sautant certains autres ou après avoir parcouru tout le reste du livre.
Dans tous les cas, c&#8217;est ici que le fonctionnement interne et la mise en œuvre de Git sont abordés.
Pour nous, leur apprentissage a été fondamental pour comprendre à quel point Git est utile et puissant, mais d&#8217;autres soutiennent que cela peut être source de confusion et peut être trop complexe pour les débutants.
Nous en avons donc fait le dernier chapitre de ce livre pour que vous puissiez le lire tôt ou tard lors de votre apprentissage.
Nous vous laissons le choix.</p>
<p>Maintenant que vous êtes ici, commençons.
Tout d&#8217;abord, si ce n&#8217;est pas encore clair, Git est fondamentalement un système de fichiers adressable par contenu avec l&#8217;interface utilisateur d&#8217;un VCS au-dessus.
Vous en apprendrez plus sur ce que cela signifie dans quelques instants.</p>
<p>Aux premiers jours de Git (surtout avant la version 1.5), l&#8217;interface utilisateur était beaucoup plus complexe, car elle était centrée sur le système de fichiers plutôt que sur l&#8217;aspect VCS.
Ces dernières années, l&#8217;interface utilisateur a été peaufinée jusqu&#8217;à devenir aussi cohérente et facile à utiliser que n&#8217;importe quel autre système.
Pour beaucoup, l&#8217;image du Git des débuts avec son interface utilisateur complexe et difficile à apprendre est toujours présente.</p>
<p>La couche système de fichiers adressable par contenu est vraiment géniale et nous l&#8217;aborderons dans ce chapitre.
Ensuite, vous apprendrez les mécanismes de transfert ainsi que les tâches que vous serez amené à accomplir pour maintenir un dépôt.</p>
<section class="sect1" title="Plomberie et porcelaine">
<h2 id="s_plumbing_porcelain">Plomberie et porcelaine</h2>
<p>Ce livre couvre l&#8217;utilisation de Git avec une trentaine de verbes comme <code class="literal">checkout</code>, <code class="literal">branch</code>, <code class="literal">remote</code>&#8230;&#8203;
Mais, puisque Git était initialement une boîte à outils (<em>toolkit</em>) pour VCS, plutôt qu&#8217;un VCS complet et convivial, il dispose de tout un ensemble d&#8217;actions pour les tâches bas niveau qui étaient conçues pour être liées dans le style UNIX ou appelées depuis des scripts.
Ces commandes sont dites commandes de « plomberie » (<em>plumbing</em>) et les autres, plus conviviales sont appelées « la porcelaine » (<em>porcelain</em>).</p>
<p>Les neuf premiers chapitres du livre concernent presque exclusivement les commandes de porcelaine.
Par contre, dans ce chapitre, vous serez principalement confronté aux commandes de plomberie bas niveau, car elles vous donnent accès au fonctionnement interne de Git et aident à montrer comment et pourquoi Git fonctionne comme il le fait.
Beaucoup de ces commandes ne sont pas faites pour être utilisées à la main sur une ligne de commande, mais sont plutôt utilisées comme briques de base pour écrire de nouveaux outils et scripts personnalisés.</p>
<p>Quand vous exécutez <code class="literal">git init</code> dans un nouveau répertoire ou un répertoire existant, Git crée un répertoire <code class="literal">.git</code> qui contient presque tout ce que Git stocke et manipule.
Si vous voulez sauvegarder ou cloner votre dépôt, copier ce seul répertoire suffirait presque.
Ce chapitre traite principalement de ce que contient ce répertoire.
Voici à quoi il ressemble :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls -F1
HEAD
config*
description
hooks/
info/
objects/
refs/</code></pre>
</figure>
<p>Vous y verrez sans doute d&#8217;autres fichiers, mais ceci est un dépôt qui vient d&#8217;être créé avec <code class="literal">git init</code> et c&#8217;est ce que vous verrez par défaut.
Le fichier <code class="literal">description</code> est utilisé uniquement par le programme GitWeb, il ne faut donc pas s&#8217;en soucier.
Le fichier <code class="literal">config</code> contient les options de configuration spécifiques à votre projet et le répertoire <code class="literal">info</code> contient un fichier d&#8217;exclusions   listant les motifs que vous souhaitez ignorer et que vous ne voulez pas mettre dans un fichier <code class="literal">.gitignore</code>.
Le répertoire <code class="literal">hooks</code> contient les scripts de procédures automatiques côté client ou serveur, ils sont décrits en détail dans <a id="xref--ch08-customizing-git--s_git_hooks" href="ch08-customizing-git.xhtml#s_git_hooks" class="xref">Crochets Git</a>.</p>
<p>Il reste quatre éléments importants : les fichiers <code class="literal">HEAD</code> et (pas encore créé) <code class="literal">index</code>, ainsi que les répertoires <code class="literal">objects</code> et <code class="literal">refs</code>.
Ce sont les composants principaux d&#8217;un dépôt Git.
Le répertoire <code class="literal">objects</code> stocke le contenu de votre base de données, le répertoire <code class="literal">refs</code> stocke les pointeurs vers les objets <em>commit</em> de ces données (branches), le fichier <code class="literal">HEAD</code> pointe sur la branche qui est en cours dans votre répertoire de travail et le fichier <code class="literal">index</code> est l&#8217;endroit où Git stocke les informations sur la zone d&#8217;attente.
Vous allez maintenant plonger en détail dans chacune de ces sections et voir comment Git fonctionne.</p>
</section>
<section class="sect1" title="Les objets de Git">
<h2 id="s_objects">Les objets de Git</h2>
<p>Git est un système de fichier adressables par contenu.
Super !
Mais qu&#8217;est-ce que ça veut dire ?
Ça veut dire que le cœur de Git est une simple base de paires clé/valeur.
Vous pouvez y insérer n&#8217;importe quelle sorte de données et il vous retournera une clé que vous pourrez utiliser à n&#8217;importe quel moment pour récupérer ces données.
Pour illustrer cela, vous pouvez utiliser la commande de plomberie <code class="literal">hash-object</code>, qui prend des données, les stocke dans votre répertoire <code class="literal">.git</code>, puis retourne la clé sous laquelle les données sont stockées.
Tout d&#8217;abord, créez un nouveau dépôt Git et vérifiez que rien ne se trouve dans le répertoire <code class="literal">objects</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init test
Initialized empty Git repository in /tmp/test/.git/
<span style="font-weight: bold">$</span> cd test
<span style="font-weight: bold">$</span> find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
<span style="font-weight: bold">$</span> find .git/objects -type f</code></pre>
</figure>
<p>Git a initialisé le répertoire <code class="literal">objects</code> et y a créé les sous-répertoires <code class="literal">pack</code> et <code class="literal">info</code>, mais ils ne contiennent pas de fichier régulier.
Maintenant, stockez du texte dans votre base de données Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;test content&#39;</span> | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</figure>
<p>L&#8217;option <code class="literal">-w</code> spécifie à <code class="literal">hash-object</code> de stocker l&#8217;objet, sinon la commande répondrait seulement quelle serait la clé.
<code class="literal">--stdin</code> spécifie à la commande de lire le contenu depuis l&#8217;entrée standard, sinon <code class="literal">hash-object</code> s&#8217;attend à trouver un chemin vers un fichier.
La sortie de la commande est une empreinte de 40 caractères.
C&#8217;est l&#8217;empreinte SHA-1 ‒ une somme de contrôle du contenu du fichier que vous stockez plus un en-tête, que vous apprendrez sous peu.
Voyez maintenant comment Git a stocké vos données :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</figure>
<p>Vous pouvez voir un fichier dans le répertoire <code class="literal">objects</code>.
C&#8217;est comme cela que Git stocke initialement du contenu ‒ un fichier par contenu, nommé d&#8217;après la somme de contrôle SHA-1 du contenu et de son en-tête.
Le sous-répertoire est nommé d&#8217;après les 2 premiers caractères de l&#8217;empreinte et le fichier d&#8217;après les 38 caractères restants.</p>
<p>Vous pouvez récupérer le contenu avec la commande <code class="literal">cat-file</code>.
Cette commande est un peu le couteau suisse pour l&#8217;inspection des objets Git.
Lui passer l&#8217;option <code class="literal">-p</code> ordonne à la commande <code class="literal">cat-file</code> de déterminer le type de contenu et de vous l&#8217;afficher joliment :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</code></pre>
</figure>
<p>Vous pouvez maintenant ajouter du contenu à Git et le récupérer à nouveau.
Vous pouvez faire de même avec le contenu de fichiers.
Par exemple, vous pouvez mettre en œuvre une gestion de version simple d&#8217;un fichier.
D&#8217;abord, créez un nouveau fichier et enregistrez son contenu dans la base de données :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;version 1&#39;</span> &gt; test.txt
<span style="font-weight: bold">$</span> git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30</code></pre>
</figure>
<p>Puis, modifiez le contenu du fichier et enregistrez-le à nouveau :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;version 2&#39;</span> &gt; test.txt
<span style="font-weight: bold">$</span> git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>
</figure>
<p>Votre base de données contient les 2 versions du fichier, ainsi que le premier contenu que vous avez stocké ici :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</figure>
<p>Vous pouvez maintenant restaurer le fichier à sa première version :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
<span style="font-weight: bold">$</span> cat test.txt
version 1</code></pre>
</figure>
<p>ou à sa seconde version :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
<span style="font-weight: bold">$</span> cat test.txt
version 2</code></pre>
</figure>
<p>Mais se rappeler de la clé SHA-1 de chaque version de votre fichier n&#8217;est pas pratique.
En plus, vous ne stockez pas le nom du fichier dans votre système ‒ seulement le contenu.
Ce type d&#8217;objet est appelé un blob (<em>Binary Large OBject</em>, soit en français : Gros Objet Binaire).
Git peut vous donner le type d&#8217;objet de n&#8217;importe quel objet Git, étant donné sa clé SHA-1, avec <code class="literal">cat-file -t</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</code></pre>
</figure>
<section class="sect2" title="Les objets arbres">
<h3 id="s_tree_objects">Les objets arbres</h3>
<p>Le prochain type que nous allons étudier est l&#8217;arbre (<em>tree</em>) qui résout le problème de stockage du nom du fichier et vous permet d&#8217;enregistrer un groupe de fichiers ensemble.
Git stocke du contenu de la même manière, mais plus simplement, qu&#8217;un système de fichier UNIX.
Tout le contenu est stocké comme des objets de type arbre ou blob : un arbre correspondant à un répertoire UNIX et un blob correspond à peu près aux inodes ou au contenu d&#8217;un fichier.
Un unique arbre contient une ou plusieurs entrées, chacune étant l&#8217;empreinte SHA-1 d&#8217;un blob ou d&#8217;un sous-arbre (<em>sub-tree</em>) avec ses droits d&#8217;accès (<em>mode</em>), son type et son nom de fichier associés.
L&#8217;arbre le plus récent d&#8217;un projet pourrait ressembler, par exemple, à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>
</figure>
<p>La syntaxe <code class="literal">master^{tree}</code> signifie l&#8217;objet arbre qui est pointé par le dernier <em>commit</em> de la branche <code class="literal">master</code>.
Remarquez que le sous-répertoire <code class="literal">lib</code> n&#8217;est pas un blob, mais un pointeur vers un autre arbre :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>
</figure>
<p>Conceptuellement, les données que Git stocke ressemblent ceci :</p>
<figure class="image">
<div class="content">
<img src="images/data-model-1.png" alt="Une version simple du modèle de données Git."/>
</div>
<figcaption>Figure 1. Une version simple du modèle de données Git.</figcaption>
</figure>
<p>Vous pouvez facilement créer votre propre arbre.
Git crée habituellement un arbre à partir de l&#8217;état de la zone d&#8217;attente ou index et écrit une série d&#8217;objets arbre à partir de là.
Donc, pour créer un objet arbre, vous devez d&#8217;abord mettre en place un index en mettant quelques fichiers en attente.
Pour créer un index contenant une entrée, la première version de votre fichier <code class="literal">test.txt</code> par exemple, utilisons la commande de plomberie <code class="literal">update-index</code>.
Vous pouvez utiliser cette commande pour ajouter artificiellement une version plus ancienne à une nouvelle zone d&#8217;attente.
Vous devez utiliser les options <code class="literal">--add</code> car le fichier n&#8217;existe pas encore dans votre zone d&#8217;attente (vous n&#8217;avez même pas encore mis en place une zone d&#8217;attente) et <code class="literal">--cacheinfo</code> car le fichier que vous ajoutez n&#8217;est pas dans votre répertoire, mais dans la base de données.
Vous pouvez ensuite préciser le mode, SHA-1 et le nom de fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-index --add --cacheinfo 100644 <span style="font-weight: bold; font-style: italic">\</span>
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>
</figure>
<p>Dans ce cas, vous précisez le mode <code class="literal">100644</code>, qui signifie que c&#8217;est un fichier normal.
Les alternatives sont <code class="literal">100755</code>, qui signifie que c&#8217;est un exécutable, et <code class="literal">120000</code>, qui précise que c&#8217;est un lien symbolique.
Le concept de « mode » a été repris des mode UNIX, mais est beaucoup moins flexible : ces trois modes sont les seuls valides pour Git, pour les fichiers (blobs) dans Git (bien que d&#8217;autres modes soient utilisés pour les répertoires et sous-modules).</p>
<p>Vous pouvez maintenant utiliser la commande <code class="literal">write-tree</code> pour écrire la zone d&#8217;attente dans un objet arbre.
L&#8217;option <code class="literal">-w</code> est inutile (appeler <code class="literal">write-tree</code> crée automatiquement un objet arbre à partir de l&#8217;état de l&#8217;index si cet arbre n&#8217;existe pas) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span style="font-weight: bold">$</span> git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>
</figure>
<p>Vous pouvez également vérifier que c&#8217;est un objet arbre :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</code></pre>
</figure>
<p>Vous allez créer maintenant un nouvel arbre avec la seconde version de <code class="literal">test.txt</code> et aussi un nouveau fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;new file&#39;</span> &gt; new.txt
<span style="font-weight: bold">$</span> git update-index test.txt
<span style="font-weight: bold">$</span> git update-index --add new.txt</code></pre>
</figure>
<p>Votre zone d&#8217;attente contient maintenant la nouvelle version de <code class="literal">test.txt</code> ainsi que le nouveau fichier <code class="literal">new.txt</code>.
Enregistrez cet arbre (c&#8217;est-à-dire enregistrez l&#8217;état de la zone d&#8217;attente ou index dans un objet arbre) et voyez à quoi il ressemble :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
<span style="font-weight: bold">$</span> git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</figure>
<p>Remarquez que cet arbre contient des entrées pour les deux fichiers et que l&#8217;empreinte SHA-1 de <code class="literal">test.txt</code> est l&#8217;empreinte de la « version 2 » de tout à l&#8217;heure (<code class="literal">1f7a7a</code>).
Pour le plaisir, ajoutez le premier arbre à celui-ci, en tant que sous-répertoire.
Vous pouvez récupérer un arbre de votre zone d&#8217;attente en exécutant <code class="literal">read-tree</code>.
Dans ce cas, vous pouvez récupérer un arbre existant dans votre zone d&#8217;attente comme étant un sous-arbre en utilisant l&#8217;option <code class="literal">--prefix</code> de <code class="literal">read-tree</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span style="font-weight: bold">$</span> git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
<span style="font-weight: bold">$</span> git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</figure>
<p>Si vous créiez un répertoire de travail à partir du nouvel arbre que vous venez d&#8217;enregistrer, vous auriez deux fichiers à la racine du répertoire de travail, ainsi qu&#8217;un sous-répertoire appelé <code class="literal">bak</code> qui contiendrait la première version du fichier <code class="literal">test.txt</code>.
Vous pouvez vous représenter les données que Git utilise pour ces structures comme ceci :</p>
<figure class="image">
<div class="content">
<img src="images/data-model-2.png" alt="Structure du contenu de vos données Git actuelles."/>
</div>
<figcaption>Figure 2. Structure du contenu de vos données Git actuelles.</figcaption>
</figure>
</section>
<section class="sect2" title="Les objets commit">
<h3 id="s_git_commit_objects">Les objets <em>commit</em></h3>
<p>Vous avez trois arbres qui définissent différents instantanés du projet que vous suivez, mais le problème précédent persiste : vous devez vous souvenir des valeurs des trois empreintes SHA-1 pour accéder aux instantanés.
Vous n&#8217;avez pas non plus d&#8217;information sur qui a enregistré les instantanés, quand et pourquoi.
Ce sont les informations élémentaires qu&#8217;un objet <em>commit</em> stocke pour vous.</p>
<p>Pour créer un objet <em>commit</em>, il suffit d&#8217;exécuter <code class="literal">commit-tree</code> et de préciser l&#8217;empreinte SHA-1 d&#8217;un seul arbre et quels objets <em>commit</em>, s&#8217;il y en a, le précèdent directement.
Commencez avec le premier arbre que vous avez créé :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;first commit&#39;</span> | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>
</figure>
<p>Vous obtiendrez une valeur de hashage différente à cause d&#8217;un moment de création et d&#8217;une information d&#8217;auteur différents.
Remplacez les valeurs de hashage de <em>commit</em> et d&#8217;étiquette par vos propres valeurs de somme de contrôle plus loin dans ce chapitre.
Vous pouvez voir votre nouvel objet <em>commit</em> avec <code class="literal">cat-file</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit</code></pre>
</figure>
<p>Le format d&#8217;un objet <em>commit</em> est simple : il contient l&#8217;arbre racine de l&#8217;instantané du projet à ce moment, les informations sur l&#8217;auteur et le validateur (qui utilisent vos variables de configuration <code class="literal">user.name</code> et <code class="literal">user.email</code> et un horodatage); une ligne vide et le message de validation.</p>
<p>Ensuite, vous enregistrez les deux autres objets <em>commit</em>, chacun référençant le <em>commit</em> dont il est issu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;second commit&#39;</span> | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
<span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;third commit&#39;</span>  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</figure>
<p>Chacun des trois objets <em>commit</em> pointe sur un des trois arbres d&#8217;instantané que vous avez créés.
Curieusement, vous disposez maintenant d&#8217;un historique Git complet que vous pouvez visualiser avec la commande <code class="literal">git log</code>, si vous la lancez sur le SHA-1 du dernier <em>commit</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Fantastique.
Vous venez d&#8217;effectuer les opérations bas niveau pour construire un historique Git sans avoir utilisé une seule des commandes de haut niveau.
C&#8217;est l&#8217;essence de ce que fait Git quand vous exécutez les commandes <code class="literal">git add</code> et <code class="literal">git commit</code>.
Il stocke les blobs correspondant aux fichiers modifiés, met à jour l&#8217;index, écrit les arbres et ajoute les objets <em>commit</em> qui référencent les arbres racines venant juste avant eux.
Ces trois objets principaux (le blob, l&#8217;arbre et le <em>commit</em>) sont initialement stockés dans des fichiers séparés du répertoire <code class="literal">.git/objects</code>.
Voici tous les objets contenus dans le répertoire exemple, commentés d&#8217;après leur contenu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &#39;test content&#39;
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</figure>
<p>Si vous suivez les pointeurs internes de ces objets, vous obtenez un graphe comme celui-ci :</p>
<figure class="image">
<div class="content">
<img src="images/data-model-3.png" alt="Tous les objets de votre répertoire Git."/>
</div>
<figcaption>Figure 3. Tous les objets de votre répertoire Git.</figcaption>
</figure>
</section>
<section class="sect2" title="Stockage des objets">
<h3 id="_stockage_des_objets">Stockage des objets</h3>
<p>Nous avons parlé plus tôt de l&#8217;en-tête présent avec le contenu.
Prenons un moment pour étudier la façon dont Git stocke les objets.
On verra comment stocker interactivement un objet blob (ici, la chaîne "what is up, doc?") avec le langage Ruby.</p>
<p>Vous pouvez démarrer Ruby en mode interactif avec la commande <code class="literal">irb</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> irb
<span style="font-weight: bold">&gt;</span>&gt; content = <span style="font-style: italic">&quot;what is up, doc?&quot;</span>
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;what is up, doc?&quot;</span></code></pre>
</figure>
<p>Git construit un en-tête qui commence avec le type de l&#8217;objet, ici un blob.
Ensuite, il ajoute un espace suivi de taille du contenu et enfin un octet nul :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; header = <span style="font-style: italic">&quot;blob #{content.length}\0&quot;</span>
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;blob 16\u0000&quot;</span></code></pre>
</figure>
<p>Git concatène l&#8217;en-tête avec le contenu original et calcule l&#8217;empreinte SHA-1 du nouveau contenu.
En Ruby, vous pouvez calculer l&#8217;empreinte SHA-1 d&#8217;une chaîne en incluant la bibliothèque « digest/SHA-1 » via la commande <code class="literal">require</code>, puis en appelant <code class="literal">Digest::SHA1.hexdigest()</code> sur la chaîne :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; store = header + content
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;blob 16\u0000what is up, doc?&quot;</span>
<span style="font-weight: bold">&gt;</span>&gt; require <span style="font-style: italic">&#39;digest/sha1&#39;</span>
<span style="font-weight: bold">&gt;</span> true
<span style="font-weight: bold">&gt;</span>&gt; sha1 = Digest::SHA1.hexdigest(store)
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span></code></pre>
</figure>
<p>Git compresse le nouveau contenu avec zlib, ce que vous pouvez faire avec la bibliothèque zlib de Ruby.
D&#8217;abord, vous devez inclure la bibliothèque et ensuite exécuter <code class="literal">Zlib::Deflate.deflate()</code> sur le contenu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; require <span style="font-style: italic">&#39;zlib&#39;</span>
<span style="font-weight: bold">&gt;</span> true
<span style="font-weight: bold">&gt;</span>&gt; zlib_content = Zlib::Deflate.deflate(store)
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D&quot;</span></code></pre>
</figure>
<p>Finalement, vous enregistrerez le contenu compressé dans un objet sur le disque.
Vous déterminerez le chemin de l&#8217;objet que vous voulez enregistrer (les deux premiers caractères de l&#8217;empreinte SHA-1 formeront le nom du sous-répertoire et les 38 derniers formeront le nom du fichier dans ce répertoire).
En Ruby, on peut utiliser la fonction <code class="literal">FileUtils.mkdir_p()</code> pour créer un sous-répertoire s&#8217;il n&#8217;existe pas.
Ensuite, ouvrez le fichier avec <code class="literal">File.open()</code> et enregistrez le contenu compressé en appelant la fonction <code class="literal">write()</code> sur la référence du fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; path = <span style="font-style: italic">&#39;.git/objects/&#39;</span> + sha1[0,2] + <span style="font-style: italic">&#39;/&#39;</span> + sha1[2,38]
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span>
<span style="font-weight: bold">&gt;</span>&gt; require <span style="font-style: italic">&#39;fileutils&#39;</span>
<span style="font-weight: bold">&gt;</span> true
<span style="font-weight: bold">&gt;</span>&gt; FileUtils.mkdir_p(File.dirname(path))
<span style="font-weight: bold">&gt;</span> <span style="font-style: italic">&quot;.git/objects/bd&quot;</span>
<span style="font-weight: bold">&gt;</span>&gt; File.open(path, <span style="font-style: italic">&#39;w&#39;</span>) { |f| f.write zlib_content }
<span style="font-weight: bold">&gt;</span> 32</code></pre>
</figure>
<p>C&#8217;est tout !
Vous venez juste de créer un objet blob valide.
Tout les objets Git sont stockés de la même façon, mais avec des types différents : l&#8217;en-tête commencera par « commit » ou « tree » au lieu de la chaîne « blob ».
De plus, alors que le contenu d&#8217;un blob peut être à peu près n&#8217;importe quoi, le contenu  d&#8217;un <em>commit</em> ou d&#8217;un arbre est formaté de façon très précise.</p>
</section>
</section>
<section class="sect1" title="Références Git">
<h2 id="s_git_refs">Références Git</h2>
<p>On peut exécuter quelque chose comme <code class="literal">git log 1a410e</code> pour visualiser tout l&#8217;historique, mais il faut se souvenir que <code class="literal">1a410e</code> est le dernier <em>commit</em> afin de parcourir l&#8217;historique et trouver tous ces objets.
Vous avez besoin d&#8217;un fichier dans lequel vous pouvez stocker l&#8217;empreinte SHA-1 sous un nom simple afin d&#8217;utiliser ce pointeur plutôt que l&#8217;empreinte SHA-1 elle-même.</p>
<p>Git appelle ces pointeurs des « références », ou « refs ».
On trouve les fichiers contenant des empreintes SHA-1 dans le répertoire <code class="literal">git/refs</code>.
Dans le projet actuel, ce répertoire ne contient aucun fichier, mais possède une structure simple :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
<span style="font-weight: bold">$</span> find .git/refs -type f</code></pre>
</figure>
<p>Pour créer une nouvelle référence servant à se souvenir du dernier <em>commit</em>, vous pouvez simplement faire ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot;</span> &gt; .git/refs/heads/master</code></pre>
</figure>
<p>Vous pouvez maintenant utiliser la référence principale que vous venez de créer à la place de l&#8217;empreinte SHA-1 dans vos commandes Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Il n&#8217;est pas conseillé d&#8217;éditer directement les fichiers des références.
Git propose une manière sûre de mettre à jour une référence, c&#8217;est la commande <code class="literal">update-ref</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</figure>
<p>C&#8217;est simplement ce qu&#8217;est une branche dans Git : un simple pointeur ou référence sur le dernier état d&#8217;une suite de travaux.
Pour créer une branche à partir du deuxième <em>commit</em>, vous pouvez faire ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-ref refs/heads/test cac0ca</code></pre>
</figure>
<p>Cette branche contiendra seulement le travail effectué jusqu&#8217;à ce <em>commit</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>La base de donnée Git ressemble maintenant à quelque chose comme ceci :</p>
<figure class="image">
<div class="content">
<img src="images/data-model-4.png" alt="Le répertoire d'objets de Git avec les références de branches incluses."/>
</div>
<figcaption>Figure 4. Le répertoire d&#8217;objets de Git avec les références de branches incluses.</figcaption>
</figure>
<p>Quand vous exécutez une commande comme  <code class="literal">git branch (nomdebranche)</code>, Git exécute simplement la commande <code class="literal">update-ref</code> pour ajouter l&#8217;empreinte SHA-1 du dernier <em>commit</em> de la branche sur laquelle vous êtes quelle que soit la nouvelle référence que vous voulez créer.</p>
<section class="sect2" title="La branche HEAD">
<h3 id="s_the_head">La branche HEAD</h3>
<p>On peut se poser la question : « Comment Git peut avoir connaissance de l&#8217;empreinte SHA-1 du dernier <em>commit</em> quand on exécute <code class="literal">git branch (branchname)</code> ? »
La réponse est dans le fichier HEAD (qui veut dire tête en français, soit, ici, l&#8217;état courant).</p>
<p>Le fichier HEAD est une référence symbolique à la branche courante.
Par référence symbolique, j&#8217;entends que contrairement à une référence normale, elle ne contient pas une empreinte SHA-1, mais plutôt un pointeur vers une autre référence.
Si vous regardez ce fichier, vous devriez voir quelque chose comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/HEAD
ref: refs/heads/master</code></pre>
</figure>
<p>Si vous exécutez <code class="literal">git checkout test</code>, Git met à jour ce fichier, qui ressemblera à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/HEAD
ref: refs/heads/test</code></pre>
</figure>
<p>Quand vous exécutez <code class="literal">git commit</code>, il crée l&#8217;objet <em>commit</em> en spécifiant le parent de cet objet <em>commit</em> quelle que soit l&#8217;empreinte SHA-1 pointée par la référence de HEAD.</p>
<p>On peut éditer manuellement ce fichier, mais encore une fois, il existe une commande plus sûre pour le faire : <code class="literal">symbolic-ref</code>.
Vous pouvez lire le contenu de votre fichier HEAD avec cette commande :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git symbolic-ref HEAD
refs/heads/master</code></pre>
</figure>
<p>Vous pouvez aussi définir la valeur de HEAD :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git symbolic-ref HEAD refs/heads/test
<span style="font-weight: bold">$</span> cat .git/HEAD
ref: refs/heads/test</code></pre>
</figure>
<p>Vous ne pouvez pas définir une référence symbolique à une valeur non contenu dans refs :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</figure>
</section>
<section class="sect2" title="Étiquettes">
<h3 id="_étiquettes">Étiquettes</h3>
<p>Nous venons de parcourir les trois types d&#8217;objets utilisés par Git, mais il en existe un quatrième.
L&#8217;objet étiquette (<em>tag</em> en anglais) ressemble beaucoup à un objet <em>commit</em>.
Il contient un étiqueteur, une date, un message et un pointeur.
La principale différence est que l&#8217;étiquette pointe en général vers un <em>commit</em> plutôt qu&#8217;un arbre.
C&#8217;est comme une référence à une branche, mais elle ne bouge jamais : elle pointe toujours vers le même <em>commit</em>, lui donnant un nom plus sympathique.</p>
<p>Comme présenté au <a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Les bases de Git</a>, il existe deux types d&#8217;étiquettes : annotée et légère.
Vous pouvez créer une étiquette légère comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</figure>
<p>C&#8217;est tout ce qu&#8217;est une étiquette légère : une référence qui n&#8217;est jamais modifiée.
Une étiquette annotée est plus complexe.
Quand on crée une étiquette annotée, Git crée un objet étiquette, puis enregistre une référence qui pointe vers lui plutôt que directement vers le <em>commit</em>.
Vous pouvez voir ceci en créant une étiquette annotée (<code class="literal">-a</code> spécifie que c&#8217;est une étiquette annotée) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span style="font-style: italic">&#39;test tag&#39;</span></code></pre>
</figure>
<p>Voici l&#8217;empreinte SHA-1 de l&#8217;objet créé :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</figure>
<p>Maintenant, exécutez la commande <code class="literal">cat-file</code> sur cette empreinte SHA-1 :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>
</figure>
<p>Remarquez que le contenu de l&#8217;objet pointe vers l&#8217;empreinte SHA-1 du <em>commit</em> que vous avez étiqueté.
Remarquez qu&#8217;il n&#8217;est pas nécessaire qu&#8217;il pointe vers un <em>commit</em>.
On peut étiqueter n&#8217;importe quel objet.
Par exemple, dans le code source de Git, le mainteneur a ajouté sa clé publique GPG dans un blob et a étiqueté ce blob.
Vous pouvez voir la clé publique en exécutant ceci sur un clone du dépôt Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file blob junio-gpg-pub</code></pre>
</figure>
<p>Le noyau Linux contient aussi une étiquette ne pointant pas vers un <em>commit</em> : la première étiquette créée pointe vers l&#8217;arbre initial lors de l&#8217;importation du code source.</p>
</section>
<section class="sect2" title="Références distantes">
<h3 id="_références_distantes">Références distantes</h3>
<p>Le troisième type de références que l&#8217;on étudiera sont les références distantes (<em>remotes</em>).
Si l&#8217;on ajoute une référence distante et que l&#8217;on pousse des objets vers elle, Git stocke la valeur que vous avez poussée en dernier vers cette référence pour chaque branche dans le répertoire <code class="literal">refs/remotes</code>.
Vous pouvez par exemple ajouter une référence distante nommée <code class="literal">origin</code> et y pousser votre branche <code class="literal">master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@github.com:schacon/simplegit-progit.git
<span style="font-weight: bold">$</span> git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</figure>
<p>Ensuite, vous pouvez voir l&#8217;état de la branche <code class="literal">master</code> dans la référence distante <code class="literal">origin</code> la dernière fois que vous avez communiqué avec le serveur en regardant le fichier <code class="literal">refs/remotes/origin/master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</figure>
<p>Les références distantes diffèrent des branches (références <code class="literal">refs/heads</code>) principalement parce qu&#8217;on ne peut y accéder qu&#8217;en lecture seule.
Vous pouvez éxécuter <code class="literal">git checkout</code> sur l&#8217;une d&#8217;entre elles, mais Git ne fera jamais pointer HEAD sur l&#8217;une d&#8217;elles, donc vous ne pourrez jamais en mettre une à jour en utilisant une commande <code class="literal">commit</code>.
Git les gère comme des marque-pages du dernier état connu de vers quoi ces branches pointent sur le serveur.</p>
</section>
</section>
<section class="sect1" title="Fichiers groupés">
<h2 id="_fichiers_groupés">Fichiers groupés</h2>
<p>Revenons à la base de donnée d&#8217;objets de notre dépôt Git de test.
Pour l&#8217;instant, elle contient 11 objets : 4 blobs, 3 arbres, 3 <em>commits</em> et 1 étiquette :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &#39;test content&#39;
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</figure>
<p>Git compresse le contenu de ces fichiers avec zlib et on ne stocke pas grand chose ; au final, tous ces fichiers occupent seulement 925 octets.
Ajoutons de plus gros contenu au dépôt pour montrer une fonctionnalité intéressante de Git.
Pour la démonstration, nous allons ajouter le fichier <code class="literal">repo.rb</code> de la bibliothèque Grit.
Il représente environ 22 ko de code source :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb
<span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git add repo.rb
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;added repo.rb&#39;</span>
[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)</code></pre>
</figure>
<p>Si vous observez l&#8217;arbre qui en résulte, vous verrez l&#8217;empreinte SHA-1 du blob contenant le fichier <code class="literal">repo.rb</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre>
</figure>
<p>Vous pouvez vérifier la taille de l&#8217;objet sur disque à l&#8217;aide de <code class="literal">git cat-file</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044</code></pre>
</figure>
<p>Maintenant, modifiez légèrement le fichier et voyez ce qui arrive :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;# testing&#39;</span> &gt;&gt; repo.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;modified repo.rb a bit&#39;</span>
[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Regardez l&#8217;arbre créé par ce <em>commit</em> et vous verrez quelque chose d&#8217;intéressant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre>
</figure>
<p>Ce blob est un blob différent.
Bien que l&#8217;on ait ajouté une seule ligne à la fin d&#8217;un fichier en faisant 400, Git enregistre ce nouveau contenu dans un objet totalement différent :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054</code></pre>
</figure>
<p>Il y a donc deux objets de 22 ko quasiment identiques sur le disque.
Ne serait-ce pas charmant si Git pouvait n&#8217;enregistrer qu&#8217;un objet en entier, le deuxième n&#8217;étant qu&#8217;un delta (une différence) avec le premier ?</p>
<p>Il se trouve que c&#8217;est possible.
Le format initial dans lequel Git enregistre les objets sur le disque est appelé le format brut (<em>loose object</em>).
De temps en temps, Git compacte plusieurs de ces objets en un seul fichier binaire appelé <em>packfile</em> (fichier groupé), afin d&#8217;économiser de l&#8217;espace et d&#8217;être plus efficace.
Git effectue cette opération quand il y a trop d&#8217;objets au format brut, ou si l&#8217;on exécute manuellement la commande <code class="literal">git gc</code>, ou encore quand on pousse vers un serveur distant.
Pour voir cela en action, vous pouvez demander manuellement à Git de compacter les objets en exécutant la commande <code class="literal">git gc</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)</code></pre>
</figure>
<p>Si l&#8217;on jette un œil dans le répertoire des objets, on constatera que la plupart des objets ne sont plus là et qu&#8217;un couple de fichiers est apparu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</code></pre>
</figure>
<p>Les objets restant sont des blobs qui ne sont pointés par aucun <em>commit</em>.
Dans notre cas, il s&#8217;agit des blobs « what is up, doc? » et « test content » créés plus tôt comme exemple.
Puisqu&#8217;ils n&#8217;ont été ajoutés à aucun <em>commit</em>, ils sont considérés en suspend et ne sont pas compactés dans le nouveau fichier groupé.</p>
<p>Les autres fichiers sont le nouveau fichier groupé et un index.
Le fichier groupé est un fichier unique rassemblant le contenu de tous les objets venant d&#8217;être supprimés du système de fichier.
L&#8217;index est un fichier contenant les emplacements dans le fichier groupé, pour que l&#8217;on puisse accéder rapidement à un objet particulier.
Ce qui est vraiment bien, c&#8217;est que les objets occupaient environ 15 ko d&#8217;espace disque avant <code class="literal">gc</code> et que le nouveau fichier groupé en occupe seulement 7.
On a réduit l&#8217;occupation du disque de ½ en regroupant les objets.</p>
<p>Comment Git réalise-t-il cela ?
Quand Git compacte des objets, il recherche les fichiers qui ont des noms et des tailles similaires, puis enregistre seulement les deltas entre une version du fichier et la suivante.
On peut regarder à l&#8217;intérieur du fichier groupé et voir l&#8217;espace économisé par Git.
La commande de plomberie <code class="literal">git verify-pack</code> vous permet de voir ce qui a été compacté :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</code></pre>
</figure>
<p>Ici, le blob <code class="literal">033b4</code>, qui, si on se souvient bien, était la première version du fichier <code class="literal">repo.rb</code>, référence le blob <code class="literal">b042a</code>, qui est la seconde version du fichier.
La troisième colonne de l&#8217;affichage est la taille de l&#8217;objet dans le fichier compact et on peut voir que <code class="literal">b042a</code> occupe 22 ko dans le fichier, mais que <code class="literal">033b4</code> occupe seulement 9 octets.
Ce qui est aussi intéressant est que la seconde version du fichier est celle qui est enregistrée telle quelle, tandis que la version originale est enregistrée sous forme d&#8217;un delta.
La raison en est que vous aurez sans doute besoin d&#8217;accéder rapidement aux versions les plus récentes du fichier.</p>
<p>Une chose intéressante à propos de ceci est que l&#8217;on peut recompacter à tout moment.
Git recompacte votre base de donnée occasionnellement, en essayant d&#8217;économiser de la place.
Vous pouvez aussi recompacter à la main, en exécutant la commande <code class="literal">git gc</code> vous-même.</p>
</section>
<section class="sect1" title="La refspec">
<h2 id="s_refspec">La <em>refspec</em></h2>
<p>Tout au long de ce livre, nous avons utilisé des associations simples entre les branches distantes et les références locales.
Elles peuvent être plus complexes.
Supposons que vous ajoutiez un dépôt distant comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin https://github.com/schacon/simplegit-progit</code></pre>
</figure>
<p>Cela ajoute une section au fichier <code class="literal">.git/config</code>, contenant le nom du dépôt distant (<code class="literal">origin</code>), l&#8217;URL de ce dépôt et la <em>refspec</em> pour la récupération :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/*:refs/remotes/origin/*</span></code></pre>
</figure>
<p>Le format de la <em>refspec</em> est un <code class="literal">+</code> facultatif, suivi de <code class="literal">&lt;src&gt;:&lt;dst&gt;</code>, où <code class="literal">&lt;src&gt;</code> est le motif des références du côté distant et <code class="literal">&lt;dst&gt;</code> est l&#8217;emplacement local où les références seront enregistrées.
Le <code class="literal">+</code> précise à Git de mettre à jour la référence même si ce n&#8217;est pas une avance rapide.</p>
<p>Dans le cas par défaut, qui est celui d&#8217;un enregistrement automatique par la commande <code class="literal">git remote add</code>, Git récupère toutes les références de <code class="literal">refs/heads/</code> sur le serveur et les enregistre localement dans <code class="literal">refs/remotes/origin/</code>.
Ainsi, s&#8217;il y a une branche <code class="literal">master</code> sur le serveur, vous pouvez accéder localement à l&#8217;historique de cette branche via :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log origin/master
<span style="font-weight: bold">$</span> git log remotes/origin/master
<span style="font-weight: bold">$</span> git log refs/remotes/origin/master</code></pre>
</figure>
<p>Ces syntaxes sont toutes équivalentes, car Git les développe en <code class="literal">refs/remotes/origin/master</code>.</p>
<p>Si vous préférez que Git récupère seulement la branche <code class="literal">master</code> et non chacune des branches du serveur distant, vous pouvez remplacer la ligne fetch par :</p>
<figure class="listing">
<pre class="source language-"><code>fetch = +refs/heads/master:refs/remotes/origin/master</code></pre>
</figure>
<p>C&#8217;est la <em>refspec</em> par défaut de <code class="literal">git fetch</code> pour ce dépôt distant.
Si l&#8217;on veut effectuer une action particulière une seule fois, la <em>refspec</em> peut aussi être précisée en ligne de commande.
Pour tirer la branche <code class="literal">master</code> du dépôt distant vers la branche locale <code class="literal">origin/mymaster</code>, vous pouvez exécuter :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin master:refs/remotes/origin/mymaster</code></pre>
</figure>
<p>Vous pouvez indiquer plusieurs <em>refspecs</em>.
En ligne de commande, vous pouvez tirer plusieurs branches de cette façon :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin master:refs/remotes/origin/mymaster <span style="font-weight: bold; font-style: italic">\</span>
	 topic:refs/remotes/origin/topic
From git@github.com:schacon/simplegit
 ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)
 * [new branch]      topic      -&gt; origin/topic</code></pre>
</figure>
<p>Dans ce cas, la récupération (<em>pull</em>) de la branche <code class="literal">master</code> a été refusée car ce n&#8217;était pas une avance rapide.
On peut surcharger ce comportement en précisant un <code class="literal">+</code> devant la <em>refspec</em>.</p>
<p>On peut aussi indiquer plusieurs <em>refspecs</em> pour la récupération, dans le fichier de configuration.
Si vous voulez toujours récupérer les branches <code class="literal">master</code> et <code class="literal">experiment</code>, ajoutez ces deux lignes :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/master:refs/remotes/origin/master</span>
<span style="font-style: italic">	fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span></code></pre>
</figure>
<p>Vous ne pouvez pas utiliser des jokers partiels, ce qui suit est donc invalide :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>fetch = <span style="font-style: italic">+refs/heads/qa*:refs/remotes/origin/qa*</span></code></pre>
</figure>
<p>On peut toutefois utiliser des espaces de noms (<em>namespaces</em>) ou des répertoires pour accomplir cela.
S&#8217;il existe une équipe qualité (QA) qui publie une série de branches et que l&#8217;on veut la branche <code class="literal">master</code>, les branches de l&#8217;équipe qualité et rien d&#8217;autre, on peut utiliser la configuration suivante :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/master:refs/remotes/origin/master</span>
<span style="font-style: italic">	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span></code></pre>
</figure>
<p>Si vous utilisez des processus complexes impliquant une équipe qualité, des développeurs et des intégrateurs qui publient des branches et qui collaborent sur des branches distantes, vous pouvez facilement utiliser des espaces de noms de cette façon.</p>
<section class="sect2" title="Pousser des refspecs">
<h3 id="s_pushing_refspecs">Pousser des <em>refspecs</em></h3>
<p>Il est pratique de pouvoir récupérer des références issues d&#8217;espace de nom de cette façon, mais comment l&#8217;équipe qualité insère-t-elle ces branches dans l&#8217;espace de nom <code class="literal">qa/</code> en premier lieu ?
On peut accomplir cela en utilisant les spécifications de références pour la publication.</p>
<p>Si l&#8217;équipe qualité veut publier sa branche <code class="literal">master</code> vers <code class="literal">qa/master</code> sur le serveur distant, elle peut exécuter :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master:refs/heads/qa/master</code></pre>
</figure>
<p>Si elle veut que Git le fasse automatiquement à chaque exécution de <code class="literal">git push origin</code>, elle peut ajouter une entrée <code class="literal">push</code> au fichier de configuration :</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/*:refs/remotes/origin/*</span>
<span style="font-style: italic">	push = refs/heads/master:refs/heads/qa/master</span></code></pre>
</figure>
<p>De même, cela fera que, par défaut, <code class="literal">git push origin</code> publiera la branche locale <code class="literal">master</code> sur la branche distante <code class="literal">qa/master</code>.</p>
</section>
<section class="sect2" title="Supprimer des références">
<h3 id="_supprimer_des_références">Supprimer des références</h3>
<p>Vous pouvez aussi utiliser les <em>refspecs</em> pour supprimer des références sur le serveur distant en exécutant une commande comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin :topic</code></pre>
</figure>
<p>La <em>refspec</em> ressemble à <code class="literal">&lt;src&gt;:&lt;dst&gt;</code>, mais en laissant vide la partie <code class="literal">&lt;src&gt;</code>, cela signifie une création de la branche à partir de rien et donc sa suppression.</p>
</section>
</section>
<section class="sect1" title="Les protocoles de transfert">
<h2 id="_les_protocoles_de_transfert">Les protocoles de transfert</h2>
<p>Git peut transférer des données entre deux dépôts de deux façons principales : le protocole « stupide » et le protocole « intelligent ».</p>
<p>Cette section fait un tour d&#8217;horizon du fonctionnement de ces deux protocoles.</p>
<section class="sect2" title="Le protocole stupide">
<h3 id="_le_protocole_stupide">Le protocole stupide</h3>
<p>Si vous mettez en place un dépôt à accéder en lecture seule sur HTTP, c&#8217;est vraisemblablement le protocole stupide qui sera utilisé.</p>
<p>Ce protocole est dit « stupide », car il ne nécessite aucun code spécifique à Git côté serveur durant le transfert ;
le processus de récupération est une série de requêtes GET, où le client devine la structure du dépôt Git présent sur le serveur.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Le protocole stupide est rarement utilisé ces derniers temps.
Il est difficile de le rendre sécurisé ou privé, et donc la plupart des hébergeurs Git (sur le <em>cloud</em> ou sur serveur dédié) refusent de l&#8217;utiliser.
On conseille généralement d&#8217;utiliser le protocole intelligent, qui est décrit plus loin.</p>
</div>
</aside>
<p>Suivons le processus <code class="literal">http-fetch</code> pour la bibliothèque simplegit :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone http://server/simplegit-progit.git</code></pre>
</figure>
<p>La première chose que fait cette commande est de récupérer le fichier <code class="literal">info/refs</code>.
Ce fichier est écrit par la commande <code class="literal">update-server-info</code> et c&#8217;est pour cela qu&#8217;il faut activer le crochet <code class="literal">post-receive</code>, sinon le transfert HTTP ne fonctionnera pas correctement :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre>
</figure>
<p>On possède maintenant une liste des références distantes et empreintes SHA-1.
Ensuite, on regarde vers quoi pointe HEAD, pour savoir sur quelle branche se placer quand on aura fini :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET HEAD
ref: refs/heads/master</code></pre>
</figure>
<p>On aura besoin de se placer sur la branche <code class="literal">master</code>, quand le processus sera terminé.
On est maintenant prêt à démarrer le processus de parcours.
Puisque votre point de départ est l&#8217;objet <em>commit</em> <code class="literal">ca82a6</code> que vous avez vu dans le fichier <code class="literal">info/refs</code>, vous commencez par le récupérer :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>
</figure>
<p>Vous obtenez un objet, cet objet est dans le format brut sur le serveur et vous l&#8217;avez récupéré à travers une requête HTTP GET statique.
Vous pouvez le décompresser avec zlib, ignorer l&#8217;en-tête et regarder le contenu du <em>commit</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>
</figure>
<p>Puis, vous avez deux autres objets supplémentaires à récupérer : <code class="literal">cfda3b</code> qui est l&#8217;arbre du contenu sur lequel pointe le <em>commit</em> que nous venons de récupérer et <code class="literal">085bb3</code> qui est le <em>commit</em> parent :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>
</figure>
<p>Cela vous donne le prochain objet <em>commit</em>.
Récupérez l&#8217;objet arbre :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>
</figure>
<p>Oups, on dirait que l&#8217;objet arbre n&#8217;est pas au format brut sur le serveur, vous obtenez donc une réponse 404.
On peut en déduire certaines raisons : l&#8217;objet peut être dans un dépôt suppléant ou il peut être dans un fichier groupé de ce dépôt.
Git vérifie la liste des dépôts suppléants d&#8217;abord :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/info/http-alternates
(empty file)</code></pre>
</figure>
<p>Si la réponse contenait une liste d&#8217;URL suppléantes, Git aurait cherché les fichiers bruts et les fichiers groupés à ces emplacements, c&#8217;est un mécanisme sympathique pour les projets qui ont dérivé d&#8217;un autre pour partager les objets sur le disque.
Cependant, puisqu&#8217;il n&#8217;y a pas de suppléants listés dans ce cas, votre objet doit se trouver dans un fichier groupé.
Pour voir quels fichiers groupés sont disponibles sur le serveur, vous avez besoin de récupérer le fichier <code class="literal">objects/info/packs</code>, qui en contient la liste (générée également par <code class="literal">update-server-info</code>) :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>
</figure>
<p>Il n&#8217;existe qu&#8217;un seul fichier groupé sur le serveur, votre objet se trouve évidemment dedans, mais vous allez tout de même vérifier l&#8217;index pour être sûr.
C&#8217;est également utile lorsque vous avez plusieurs fichiers groupés sur le serveur, vous pouvez donc voir quel fichier groupé contient l&#8217;objet dont vous avez besoin :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>
</figure>
<p>Maintenant que vous avez l&#8217;index du fichier groupé, vous pouvez vérifier si votre objet est bien dedans car l&#8217;index liste les empreintes SHA-1 des objets contenus dans ce fichier groupé et des emplacements de ces objets.
Votre objet est là, allez donc récupérer le fichier groupé complet :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>
</figure>
<p>Vous avez votre objet arbre, vous continuez donc le chemin des <em>commits</em>.
Ils sont également tous contenus dans votre fichier groupé que vous venez de télécharger, vous n&#8217;avez donc pas d&#8217;autres requêtes à faire au serveur.
Git récupère une copie de travail de votre branche <code class="literal">master</code> qui été référencée par HEAD que vous avez téléchargé au début.</p>
</section>
<section class="sect2" title="Le protocole intelligent">
<h3 id="_le_protocole_intelligent">Le protocole intelligent</h3>
<p>Le protocole stupide est simple mais un peu inefficace, et il ne permet pas l&#8217;écriture de données du client au serveur.
Le protocole intelligent est une méthode plus habituelle pour transférer des données, mais elle nécessite l&#8217;exécution sur le serveur d&#8217;un processus qui connaît Git : il peut lire les données locales et déterminer ce que le client a ou ce dont il a besoin pour générer un fichier groupé personnalisé pour lui.
Il y a deux ensembles d&#8217;exécutables pour transférer les données : une paire pour téléverser des données et une paire pour en télécharger.</p>
<section class="sect3" title="Téléverser des données">
<h4 id="_téléverser_des_données">Téléverser des données</h4>
<p>
Pour téléverser des données vers un exécutable distant, Git utilise les exécutables <code class="literal">send-pack</code> et <code class="literal">receive-pack</code>.
L&#8217;exécutable <code class="literal">send-pack</code> tourne sur le client et se connecte à l&#8217;exécutable <code class="literal">receive-pack</code> du côté serveur.</p>
<section class="sect4" title="SSH">
<h5 id="_ssh">SSH</h5>
<p>Par exemple, disons que vous exécutez <code class="literal">git push origin master</code> dans votre projet et <code class="literal">origin</code> est défini comme une URL qui utilise le protocole SSH.
Git appelle l&#8217;exécutable <code class="literal">send-pack</code>, qui initialise une connexion à travers SSH vers votre serveur.
Il essaye d&#8217;exécuter une commande sur le serveur distant via un appel SSH qui ressemble à :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh -x git@server <span style="font-style: italic">&quot;git-receive-pack &#39;simplegit-progit.git&#39;&quot;</span>
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000</code></pre>
</figure>
<p>La commande <code class="literal">git-receive-pack</code> répond immédiatement avec une ligne pour chaque référence qu&#8217;elle connaît actuellement, dans ce cas, uniquement la branche <code class="literal">master</code> et son empreinte SHA-1.
La première ligne contient également une liste des compétences du serveur (ici : <code class="literal">report-status</code>, <code class="literal">delete-refs</code> et quelques autres, dont l&#8217;identifiant du client).</p>
<p>Chaque ligne commence avec une valeur hexadécimale sur 4 caractères, spécifiant le reste de la longueur de la ligne.
La première ligne, ici, commence avec <code class="literal">00a5</code>, soit 165 en hexadécimal, ce qui signifie qu&#8217;il y a 165 octets restants sur cette ligne.
La ligne d&#8217;après est <code class="literal">0000</code>, signifiant que le serveur a fini de lister ses références.</p>
<p>Maintenant qu&#8217;il connait l&#8217;état du serveur, votre exécutable <code class="literal">send-pack</code> détermine quels <em>commits</em> il a de plus que le serveur.
L&#8217;exécutable <code class="literal">send-pack</code> envoie alors à l&#8217;exécutable <code class="literal">receive-pack</code> les informations concernant chaque référence que cette commande <code class="literal">push</code> va mettre à jour.
Par exemple, si vous mettez à jour la branche <code class="literal">master</code> et ajoutez la branche <code class="literal">experiment</code>, la réponse de <code class="literal">send-pack</code> ressemblera à quelque chose comme :</p>
<figure class="listing">
<pre class="source language-"><code>0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</code></pre>
</figure>
<p>Git envoie une ligne pour chaque référence que l&#8217;on met à jour avec l&#8217;ancien SHA-1, le nouveau SHA-1 et la référence en train d&#8217;être mise à jour.
La première ligne contient également les compétences du client.
La valeur SHA-1 remplie de <em>0</em> signifie qu&#8217;il n&#8217;y avait rien à cet endroit avant, car vous êtes en train d&#8217;ajouter la référence <code class="literal">experiment</code>.
Si vous étiez en train de supprimer une référence, vous verriez l&#8217;opposé : que des <em>0</em> du côté droit.</p>
<p>Puis, le client téléverse un fichier groupé de tous les objets que le serveur n&#8217;a pas encore.</p>
<p>Finalement, le serveur répond avec une indication de succès (ou d&#8217;échec) :</p>
<figure class="listing">
<pre class="source language-"><code>000eunpack ok</code></pre>
</figure>
</section>
<section class="sect4" title="HTTP(S)">
<h5 id="_http_s">HTTP(S)</h5>
<p>Le processus est quasiment le même avec HTTP, à une différence près lors de l&#8217;établissement de la liaison (<em>handshaking</em>).
La connection est amorcée avec cette requête :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master \
	report-status delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</code></pre>
</figure>
<p>Ceci est la fin du premier échange client-serveur.
Le client fait alors une nouvelle requête, qui est cette fois un <code class="literal">POST</code>, avec les données fournies par <code class="literal">git-upload-pack</code>.</p>
<figure class="listing">
<pre class="source language-"><code>&gt; POST http://server/simplegit-progit.git/git-receive/pack</code></pre>
</figure>
<p>La requête <code class="literal">POST</code> contient la sortie de <code class="literal">send-pack</code> et le fichier groupé.
Enfin, le serveur indique le succès ou l&#8217;échec dans sa réponse HTTP.</p>
</section>
</section>
<section class="sect3" title="Téléchargement des données">
<h4 id="_téléchargement_des_données">Téléchargement des données</h4>
<p>
Lorsque vous téléchargez des données, les exécutables <code class="literal">fetch-pack</code> et <code class="literal">upload-pack</code> entrent en jeu.
Le client démarre un processus <code class="literal">fetch-pack</code> qui se connecte à un processus <code class="literal">upload-pack</code> du côté serveur pour négocier les données qui seront téléchargées.</p>
<section class="sect4" title="SSH">
<h5 id="_ssh_2">SSH</h5>
<p>Si vous téléchargez par SSH, <code class="literal">fetch-pack</code> fait quelque chose comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh -x git@server <span style="font-style: italic">&quot;git-upload-pack &#39;simplegit-progit.git&#39;&quot;</span></code></pre>
</figure>
<p>Une fois <code class="literal">fetch-pack</code> connecté, <code class="literal">upload-pack</code> lui répond quelque chose du style :</p>
<figure class="listing">
<pre class="source language-"><code>00dfca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</figure>
<p>Ceci est très proche de la réponse de <code class="literal">receive-pack</code> mais les compétences sont différentes.
En plus, il envoie ce qui est pointé par HEAD (<code class="literal">symref=HEAD:refs/heads/master</code>), afin que le client sache ce qu&#8217;il doit récupérer dans le cas d&#8217;un clone.</p>
<p>À ce moment, <code class="literal">fetch-pack</code> regarde les objets qu&#8217;il a et répond avec la liste des objets dont il a besoin en envoyant « want » (vouloir) suivi du SHA-1 qu&#8217;il veut.
Il envoie tous les objets qu&#8217;il a déjà avec « have » suivi du SHA-1.
À la fin de la liste, il écrit « done » (fait) pour inciter l&#8217;exécutable <code class="literal">upload-pack</code> à commencer à envoyer le fichier groupé des données demandées :</p>
<figure class="listing">
<pre class="source language-"><code>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000</code></pre>
</figure>
</section>
<section class="sect4" title="HTTP(S)">
<h5 id="_http_s_2">HTTP(S)</h5>
<p>L&#8217;établissement de la liaison pour une opération de téléchargement nécessite deux requêtes HTTP.
La première est un <code class="literal">GET</code> vers le même point que dans le protocole stupide :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</figure>
<p>Ceci ressemble beaucoup à un appel à <code class="literal">git-upload-pack</code> par une connection SSH, mais le deuxième échange est fait dans une requête séparée :</p>
<figure class="listing">
<pre class="source language-"><code>&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</code></pre>
</figure>
<p>Une fois de plus, ce format est le même que plus haut.
La réponse à cette requête indique le succès ou l&#8217;échec, et contient le fichier groupé.</p>
</section>
</section>
</section>
<section class="sect2" title="Résumé sur les protocoles">
<h3 id="_résumé_sur_les_protocoles">Résumé sur les protocoles</h3>
<p>Cette section contient un survol basique des protocoles de transfert.
Les protocoles contiennent de nombreuses autres fonctionalités,
comme les compétences <code class="literal">multi_ack</code> ou <code class="literal">side-band</code>,
mais leur étude est hors du sujet de ce livre.
Nous avons essayé de vous donner une idée générale des échanges entre client et serveur.
Si vous souhaitez en connaître davantage, vous devrez probablement jeter un œil sur le code source de Git.</p>
</section>
</section>
<section class="sect1" title="Maintenance et récupération de données">
<h2 id="_maintenance_et_récupération_de_données">Maintenance et récupération de données</h2>
<p>Parfois, vous aurez besoin de faire un peu de ménage : rendre un dépôt plus compact, nettoyer les dépôts importés, ou récupérer du travail perdu.
Cette section couvrira certains de ces scénarios.</p>
<section class="sect2" title="Maintenance">
<h3 id="s_git_gc">Maintenance</h3>
<p>De temps en temps, Git exécute automatiquement une commande appelée « auto gc ».
La plupart du temps, cette commande ne fait rien.
Cependant, s&#8217;il y a trop d&#8217;objets bruts (des objets qui ne sont pas dans des fichiers groupés), ou trop de fichiers groupés, Git lance une commande <code class="literal">git gc</code> à part entière.
« gc » est l&#8217;abréviation de « garbage collect » (ramasse-miettes) et la commande fait plusieurs choses : elle rassemble plusieurs objets bruts et les place dans des fichiers groupés, elle rassemble des fichiers groupés en un gros fichier groupé et elle supprime des objets qui ne sont plus accessibles depuis aucun <em>commit</em> et qui sont vieux de plusieurs mois.</p>
<p>Vous pouvez exécuter <code class="literal">auto gc</code> manuellement :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc --auto</code></pre>
</figure>
<p>Encore une fois, cela ne fait généralement rien.
Vous devez avoir environ 7 000 objets bruts ou plus de 50 fichiers groupés pour que Git appelle une vraie commande <code class="literal">gc</code>.
Vous pouvez modifier ces limites avec les propriétés de configuration <code class="literal">gc.auto</code> et <code class="literal">gc.autoPackLimit</code>, respectivement.</p>
<p><code class="literal">gc</code> regroupera aussi vos références dans un seul fichier.
Supposons que votre dépôt contienne les branches et étiquettes suivantes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1</code></pre>
</figure>
<p>Si vous exécutez <code class="literal">git gc</code>, vous n&#8217;aurez plus ces fichiers dans votre répertoire <code class="literal">refs</code>.
Git les déplacera pour plus d&#8217;efficacité dans un fichier nommé <code class="literal">.git/packed-refs</code> qui ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/packed-refs
<span style="font-weight: bold">#</span> pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</figure>
<p>Si vous mettez à jour une référence, Git ne modifiera pas ce fichier, mais enregistrera plutôt un nouveau fichier dans <code class="literal">refs/heads</code>.
Pour obtenir l&#8217;empreinte SHA-1 appropriée pour une référence donnée, Git cherche d&#8217;abord cette référence dans le répertoire <code class="literal">refs</code>, puis dans le fichier <code class="literal">packed-refs</code> si non trouvée.
Si vous ne pouvez pas trouver une référence dans votre répertoire <code class="literal">refs</code>, elle est probablement dans votre fichier <code class="literal">packed-refs</code>.</p>
<p>Remarquez la dernière ligne du fichier, celle commençant par <code class="literal">^</code>.
Cela signifie que l&#8217;étiquette directement au-dessus est une étiquette annotée et que cette ligne est le <em>commit</em> que l&#8217;étiquette annotée référence.</p>
</section>
<section class="sect2" title="Récupération de données">
<h3 id="s_data_recovery">Récupération de données</h3>
<p>À un moment quelconque de votre vie avec Git, vous pouvez accidentellement perdre un <em>commit</em>.
Généralement, cela arrive parce que vous avez forcé la suppression d&#8217;une branche contenant du travail et il se trouve que vous vouliez cette branche finalement ; ou vous avez réinitialisé une branche avec suppression, en abandonnant des <em>commits</em> dont vous vouliez des informations.
Supposons que cela arrive, comment pouvez-vous récupérer vos <em>commits</em> ?</p>
<p>Voici un exemple qui réinitialise la branche <code class="literal">master</code> avec suppression dans votre dépôt de test vers un ancien <em>commit</em> et qui récupère les <em>commits</em> perdus.
Premièrement, vérifions dans quel état est votre dépôt en ce moment :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Maintenant, déplaçons la branche <code class="literal">master</code> vers le <em>commit</em> du milieu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
<span style="font-weight: bold">$</span> git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Vous avez effectivement perdu les deux <em>commits</em> du haut, vous n&#8217;avez pas de branche depuis laquelle ces <em>commits</em> seraient accessibles.
Vous avez besoin de trouver le SHA du dernier <em>commit</em> et d&#8217;ajouter une branche s&#8217;y référant.
Le problème est de trouver ce SHA, ce n&#8217;est pas comme si vous l&#8217;aviez mémorisé, hein ?</p>
<p>Souvent, la manière la plus rapide est d&#8217;utiliser l&#8217;outil <code class="literal">git reflog</code>.
Pendant que vous travaillez, Git enregistre l&#8217;emplacement de votre HEAD chaque fois que vous le changez.
À chaque <em>commit</em> ou commutation de branche, le journal des références (<em>reflog</em>) est mis à jour.
Le journal des références est aussi mis à jour par la commande <code class="literal">git update-ref</code>, ce qui est une autre raison de l&#8217;utiliser plutôt que de simplement écrire votre valeur SHA dans vos fichiers de références, comme mentionné dans la section <a id="xref-s_git_refs" href="#s_git_refs" class="xref">Références Git</a> plus haut dans ce chapitre.
Vous pouvez voir où vous étiez à n&#8217;importe quel moment en exécutant <code class="literal">git reflog</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb</code></pre>
</figure>
<p>Ici, nous pouvons voir deux <em>commits</em> que nous avons récupérés, cependant, il n&#8217;y a pas plus d&#8217;information ici.
Pour voir, les mêmes informations d&#8217;une manière plus utile, nous pouvons exécuter <code class="literal">git log -g</code>, qui nous donnera une sortie normalisée pour votre journal de références :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit</code></pre>
</figure>
<p>On dirait que le <em>commit</em> du bas est celui que vous avez perdu, vous pouvez donc le récupérer en créant une nouvelle branche sur ce <em>commit</em>.
Par exemple, vous créez une branche nommée <code class="literal">recover-branch</code> sur ce <em>commit</em> (ab1afef):</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch recover-branch ab1afef
<span style="font-weight: bold">$</span> git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Cool. Maintenant vous avez une nouvelle branche appelée <code class="literal">recover-branch</code> à l&#8217;emplacement où votre branche <code class="literal">master</code> se trouvait, rendant les deux premiers <em>commits</em> à nouveau accessibles.
Pour poursuivre, nous supposerons que vos pertes ne sont pas dans le journal des références pour une raison quelconque.
On peut simuler cela en supprimant <code class="literal">recover-branch</code> et le journal des références.
Maintenant, les deux premiers <em>commits</em> ne sont plus accessibles :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -D recover-branch
<span style="font-weight: bold">$</span> rm -Rf .git/logs/</code></pre>
</figure>
<p>Comme les données du journal de référence sont sauvegardées dans le répertoire <code class="literal">.git/logs/</code>, vous n&#8217;avez effectivement plus de journal de références.
Comment pouvez-vous récupérer ces <em>commits</em> maintenant ?
Une manière de faire est d&#8217;utiliser l&#8217;outil <code class="literal">git fsck</code>, qui vérifie l&#8217;intégrité de votre base de données.
Si vous l&#8217;exécutez avec l&#8217;option <code class="literal">--full</code>, il vous montre tous les objets qui ne sont pas référencés par d&#8217;autres objets :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>
</figure>
<p>Dans ce cas, vous pouvez voir votre <em>commit</em> manquant après « dangling commit ».
Vous pouvez le restaurer de la même manière que précédemment, en créant une branche qui référence cette empreinte SHA-1.</p>
</section>
<section class="sect2" title="Suppression d&#8217;objets">
<h3 id="s_removing_objects">Suppression d&#8217;objets</h3>
<p>Il y a beaucoup de choses dans Git qui sont géniales, mais une fonctionnalité qui peut poser problème est le fait que <code class="literal">git clone</code> télécharge l&#8217;historique entier du projet, incluant chaque version de chaque fichier.
C&#8217;est très bien lorsque le tout est du code source, parce que Git est hautement optimisé pour compresser les données efficacement.
Cependant, si quelqu&#8217;un à un moment donné de l&#8217;historique de votre projet a ajouté un énorme fichier, chaque clone sera forcé de télécharger cet énorme fichier, même s&#8217;il a été supprimé du projet dans le <em>commit</em> suivant.
Puisqu&#8217;il est accessible depuis l&#8217;historique, il sera toujours là.</p>
<p>Cela peut être un énorme problème, lorsque vous convertissez un dépôt Subversion ou Perforce en un dépôt Git.
Comme comme vous ne téléchargez pas l&#8217;historique entier dans ces systèmes, ce genre d&#8217;ajout n&#8217;a que peu de conséquences.
Si vous avez importé depuis un autre système ou que votre dépôt est beaucoup plus gros que ce qu&#8217;il devrait être, voici comment vous pouvez trouver et supprimer des gros objets.</p>
<p><strong>Soyez prévenu : cette technique détruit votre historique de <em>commit</em>.</strong>
Elle réécrit chaque objet <em>commit</em> depuis le premier objet arbre que vous modifiez pour supprimer une référence d&#8217;un gros fichier.
Si vous faites cela immédiatement après un import, avant que quiconque n&#8217;ait eu le temps de commencer à travailler sur ce <em>commit</em>, tout va bien.
Sinon, vous devez alerter tous les contributeurs qu&#8217;ils doivent rebaser leur travail sur vos nouveaux <em>commits</em>.</p>
<p>Pour la démonstration, nous allons ajouter un gros fichier dans votre dépôt de test, le supprimer dans le <em>commit</em> suivant, le trouver et le supprimer de manière permanente du dépôt.
Premièrement, ajoutons un gros objet à votre historique :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
<span style="font-weight: bold">$</span> git add git.tgz
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;add git tarball&#39;</span>
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz</code></pre>
</figure>
<p>Oups, vous ne vouliez pas ajouter une énorme archive à votre projet.
Il vaut mieux s&#8217;en débarrasser :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm git.tgz
rm &#39;git.tgz&#39;
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;oops - removed large tarball&#39;</span>
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz</code></pre>
</figure>
<p>Maintenant, faites un <code class="literal">gc</code> sur votre base de données, pour voir combien d&#8217;espace disque vous utilisez :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)</code></pre>
</figure>
<p>Vous pouvez exécuter la commande <code class="literal">count-objects</code> pour voir rapidement combien d&#8217;espace disque vous utilisez :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</figure>
<p>L&#8217;entrée <code class="literal">size-pack</code> est la taille de vos fichiers groupés en kilo-octet, vous utilisez donc presque 5 Mo.
Avant votre dernier <em>commit</em>, vous utilisiez environ 2 ko ; clairement, supprimer le fichier avec le <em>commit</em> précédent ne l&#8217;a pas enlevé de votre historique.
À chaque fois que quelqu&#8217;un clonera votre dépôt, il aura à cloner les 5 Mo pour récupérer votre tout petit projet, parce que vous avez accidentellement rajouté un gros fichier.
Débarrassons-nous en.</p>
<p>Premièrement, vous devez le trouver.
Dans ce cas, vous savez déjà de quel fichier il s&#8217;agit.
Mais supposons que vous ne le sachiez pas, comment identifieriez-vous quel(s) fichier(s) prennent trop de place ?
Si vous exécutez <code class="literal">git gc</code>, tous les objets sont dans des fichiers groupés ; vous pouvez identifier les gros objets en utilisant une autre commande de plomberie appelée <code class="literal">git verify-pack</code> et en triant sur le troisième champ de la sortie qui est la taille des fichiers.
Vous pouvez également le faire suivre à la commande <code class="literal">tail</code> car vous ne vous intéressez qu&#8217;aux fichiers les plus gros :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git verify-pack -v .git/objects/pack/pack-29…69.idx <span style="font-weight: bold; font-style: italic">\</span>
  | sort -k 3 -n <span style="font-weight: bold; font-style: italic">\</span>
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre>
</figure>
<p>Le gros objet est à la fin : 5 Mio.
Pour trouver quel fichier c&#8217;est, vous allez utiliser la commande <code class="literal">rev-list</code>, que vous avez utilisée brièvement dans <a id="xref--ch08-customizing-git--s_enforcing_commit_message_format" href="ch08-customizing-git.xhtml#s_enforcing_commit_message_format" class="xref">Application d&#8217;une politique de format du message de validation</a>.
Si vous mettez l&#8217;option <code class="literal">--objects</code> à <code class="literal">rev-list</code>, elle listera tous les SHA des <em>commits</em> et des blobs avec le chemin du fichier associé.
Vous pouvez utilisez cette commande pour trouver le nom de votre blob :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre>
</figure>
<p>Maintenant, vous voulez supprimer ce fichier de toutes les arborescences passées.
Vous pouvez facilement voir quels <em>commits</em> ont modifié ce fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball</code></pre>
</figure>
<p>Vous devez réécrire tous les <em>commits</em> en descendant depuis <code class="literal">7b30847</code> pour supprimer totalement ce fichier de votre historique Git.
Pour cela, utilisez <code class="literal">filter-branch</code>, que vous avez utilisée dans le chapitre <a id="xref--ch07-git-tools--s_rewriting_history" href="ch07-git-tools.xhtml#s_rewriting_history" class="xref">Réécrire l&#8217;historique</a> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --index-filter <span style="font-weight: bold; font-style: italic">\</span>
  <span style="font-style: italic">&#39;git rm --ignore-unmatch --cached git.tgz&#39;</span> -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm &#39;git.tgz&#39;
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p>L&#8217;option <code class="literal">--index-filter</code> est similaire à l&#8217;option <code class="literal">--tree-filter</code> utilisée dans le chapitre <a href="ch07-git-tools.xhtml#s_rewriting_history" class="xref">Réécrire l&#8217;historique</a>, sauf qu&#8217;au lieu de modifier les fichiers sur le disque, vous modifiez votre index.</p>
<p>Plutôt que de supprimer un fichier spécifique avec une commande comme <code class="literal">rm file</code>, vous devez le supprimer avec <code class="literal">git rm --cached</code> ; vous devez le supprimer de l&#8217;index, pas du disque.
La raison de faire cela de cette manière est la rapidité, car Git n&#8217;ayant pas besoin de récupérer chaque révision sur disque avant votre filtre, la procédure peut être beaucoup, beaucoup plus rapide.
Vous pouvez faire la même chose avec <code class="literal">--tree-filter</code> si vous voulez.
L&#8217;option <code class="literal">--ignore-unmatch</code> de <code class="literal">git rm</code> lui dit que ce n&#8217;est pas une erreur si le motif que vous voulez supprimez n&#8217;existe pas.
Finalement, vous demandez à <code class="literal">filter-branch</code> de réécrire votre historique seulement depuis le parent du <em>commit</em> <code class="literal">7b30847</code>, car vous savez que c&#8217;est de là que le problème a commencé.
Sinon, il aurait démarré du début et serait plus long inutilement.</p>
<p>Votre historique ne contient plus de référence à ce fichier.
Cependant, votre journal de révision et un nouvel ensemble de références que Git a ajouté lors de votre <code class="literal">filter-branch</code> dans <code class="literal">.git/refs/original</code> en contiennent encore, vous devez donc les supprimer puis regrouper votre base de données.
Vous devez vous débarrasser de tout ce qui fait référence à ces vieux <em>commits</em> avant de regrouper :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm -Rf .git/refs/original
<span style="font-weight: bold">$</span> rm -Rf .git/logs/
<span style="font-weight: bold">$</span> git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)</code></pre>
</figure>
<p>Voyons combien d&#8217;espace vous avez récupéré :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</figure>
<p>La taille du dépôt regroupé est retombée à 8 ko, ce qui est beaucoup mieux que 5 Mo.
Vous pouvez voir dans la valeur « size » que votre gros objet est toujours dans vos objets bruts, il n&#8217;est donc pas parti ; mais il ne sera plus transféré lors d&#8217;une poussée vers un serveur ou un clone, ce qui est l&#8217;important dans l&#8217;histoire.
Si vous le voulez réellement, vous pouvez supprimer complètement l&#8217;objet en exécutant <code class="literal">git prune</code> avec l&#8217;option <code class="literal">--expire</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git prune --expire now
<span style="font-weight: bold">$</span> git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="Les variables d&#8217;environnement">
<h2 id="_les_variables_d_environnement">Les variables d&#8217;environnement</h2>
<p>Git s&#8217;exécute toujours dans un shell <code class="literal">bash</code>, et utilise un certain nombre de variables d&#8217;environnement pour savoir comment se comporter.
Il est parfois pratique de savoir lesquelles, et la façon de les utiliser pour que Git se comporte comme vous le souhaitez.
Ceci n&#8217;est pas une liste exhaustive de toutes les variables d&#8217;environnement que Git utilise, mais nous allons voir les plus utiles.</p>
<section class="sect2" title="Comportement général">
<h3 id="_comportement_général">Comportement général</h3>
<p>Certains aspects du comportement général de Git en tant que programme dépend de variables d&#8217;environnement.</p>
<p><strong><code class="literal">GIT_EXEC_PATH</code></strong> détermine l&#8217;endroit où Git va chercher ses sous-programmes (comme <code class="literal">git-commit</code>, <code class="literal">git-diff</code>, et d&#8217;autres).
  Vous pouvez vérifier le réglage actuel en lançant <code class="literal">git --exec-path</code>.</p>
<p><strong><code class="literal">HOME</code></strong> n&#8217;est pas en général considérée comme modifiable (trop d&#8217;autres choses en dépendent), mais c&#8217;est l&#8217;endroit où Git va chercher le fichier de configuration général (<em>global</em>).
  Si vous voulez une installation de Git vraiment portable, complète du point de vue de la configuration générale, vous pouvez surcharger <code class="literal">HOME</code> dans le profil (<em>profile</em>).</p>
<p><strong><code class="literal">PREFIX</code></strong> est l&#8217;équivalent pour la configuration au niveau du système.
  Git va chercher le fichier <code class="literal">$PREFIX/etc/gitconfig</code>.</p>
<p><strong><code class="literal">GIT_CONFIG_NOSYSTEM</code></strong>, si elle est définie, invalide l&#8217;utilisation du fichier de configuration au niveau du système.
  Cette variable est utile si la configuration système interfère avec vos commandes et que vous n&#8217;avez pas les privilèges pour la changer ou la supprimer.</p>
<p><strong><code class="literal">GIT_PAGER</code></strong> contrôle le programme que vous utilisez pour afficher les résultats sur plusieurs pages à la ligne de commande.
Si elle n&#8217;est pas définie, Git utilisera <code class="literal">PAGER</code> à la place.</p>
<p><strong><code class="literal">GIT_EDITOR</code></strong> est l&#8217;éditeur lancé par Git quand l&#8217;utilisateur doit taper du texte (un message de <em>commit</em> par exemple).
Si elle n&#8217;est pas définie, Git utilisera <code class="literal">EDITOR</code>.</p>
</section>
<section class="sect2" title="Les emplacements du dépôt">
<h3 id="_les_emplacements_du_dépôt">Les emplacements du dépôt</h3>
<p>Git utilise plusieurs variables d&#8217;environnement pour déterminer comment interagir avec le dépôt courant.</p>
<p><strong><code class="literal">GIT_DIR</code></strong> est l&#8217;emplacement du répertoire <code class="literal">.git</code>.
S&#8217;il n&#8217;est pas spécifié, Git remonte l&#8217;arbre des répertoires jusqu&#8217;à ce qu&#8217;il arrive à <code class="literal">~</code> ou bien <code class="literal">/</code>, en cherchant un répertoire <code class="literal">.git</code> à chaque étape.</p>
<p><strong><code class="literal">GIT_CEILING_DIRECTORIES</code></strong> contrôle le comportement de Git pendant la recherche d&#8217;un répertoire <code class="literal">.git</code>.
Si vous êtes sur des répertoires qui se chargent lentement (par exemple sur une bande magnétique ou à travers une connexion réseau lente), vous pouvez souhaiter que Git s&#8217;arrête plus tôt qu&#8217;il ne le ferait habituellemnt, surtout si Git est appelé à la construction de votre appel shell (<em>prompt</em>).</p>
<p><strong><code class="literal">GIT_WORK_TREE</code></strong> est l&#8217;emplacement de la racine du répertoire de travail pour un dépôt non nu.
Si cette variable n&#8217;est pas spécifiée, c&#8217;est le répertoire parent de <code class="literal">$GIT_DIR</code> qui est utilisé.</p>
<p><strong><code class="literal">GIT_INDEX_FILE</code></strong> est le chemin du fichier d&#8217;index (uniquement pour les dépôts non nus).</p>
<p><strong><code class="literal">GIT_OBJECT_DIRECTORY</code></strong> peut être utilisé pour spécifier l&#8217;emplacement du répertoire qui se trouve habituellement à <code class="literal">.git/objects</code>.</p>
<p><strong><code class="literal">GIT_ALTERNATE_OBJECT_DIRECTORIES</code></strong> est une liste séparée par des « : » (formattée comme ceci : <code class="literal">/rep/un:/rep/deux:…</code>) qui dit à Git où trouver les objets s&#8217;ils ne sont pas dans <code class="literal">GIT_OBJECT_DIRECTORY</code>.
S&#8217;il vous arrive d&#8217;avoir beaucoup de projets avec des gros fichiers ayant exactement le même contenu, cette variable peut vous éviter d&#8217;en garder trop de copies.</p>
</section>
<section class="sect2" title="Pathspecs">
<h3 id="_em_pathspecs_em"><em>Pathspecs</em></h3>
<p>Une "<em>pathspec</em>" fait référence à la façon dont on spécifie les chemins dans Git, y compris l&#8217;utilisation des jokers.
Ils sont utilisés dans le fichier <code class="literal">.gitignore</code>, mais également à la ligne de commande (<code class="literal">git add *.c</code>).</p>
<p><strong><code class="literal">GIT_GLOB_PATHSPECS</code> et <code class="literal">GIT_NOGLOB_PATHSPECS</code></strong> contrôlent le comportement par défaut des jokers dans les <em>pathspecs</em>.
Si <code class="literal">GIT_GLOB_PATHSPECS</code> vaut 1, les caractères jokers agissent comme des jokers (ce qui est le comportement par défaut) ; si <code class="literal">GIT_NOGLOB_PATHSPECS</code> vaut 1, les caractères jokers ne correspondent qu&#8217;à eux-même, ce qui veut dire que quelque chose comme <code class="literal">*.c</code> ne correspondrait qu&#8217;à un fichier  <em>nommé</em> « *.c », et non pas tout fichier dont le nom se termine par <code class="literal">.c</code>.
Vous pouvez surcharger ce comportement pour certains cas en faisant commencer la <em>pathspec</em> par <code class="literal">:(glob)</code> pour utiliser le joker, ou bien <code class="literal">:(literal)</code> pour une correspondance stricte, comme dans <code class="literal">:(glob)*.c</code>.</p>
<p><strong><code class="literal">GIT_LITERAL_PATHSPECS</code></strong> empêche ces deux comportements ; aucun joker ne fonctionnera, et les préfixes de surcharge seront également inopérants.</p>
<p><strong><code class="literal">GIT_ICASE_PATHSPECS</code></strong> rend toutes les <em>pathspecs</em> insensibles à la casse.</p>
</section>
<section class="sect2" title="Création de commits">
<h3 id="_création_de_em_commits_em">Création de <em>commits</em></h3>
<p>La création finale d&#8217;un objet Git <em>commit</em> est habituellement faite par <code class="literal">git-commit-tree</code>, qui utilise les variables d&#8217;environnement suivantes comme première source d&#8217;information, se repliant sur les valeurs de configuration seulement si celles-ci ne sont pas présentes :</p>
<p><strong><code class="literal">GIT_AUTHOR_NAME</code></strong> est le nom lisible par un humain dans le champ « Auteur » (<em>author</em>).</p>
<p><strong><code class="literal">GIT_AUTHOR_EMAIL</code></strong> est l&#8217;adresse de courriel pour le champ « Auteur ».</p>
<p><strong><code class="literal">GIT_AUTHOR_DATE</code></strong> est l&#8217;horodatage utilisé pourle champ « Auteur ».</p>
<p><strong><code class="literal">GIT_COMMITTER_NAME</code></strong> définit le nom humain pour le champ « Validateur » (<em>commiter</em>).</p>
<p><strong><code class="literal">GIT_COMMITTER_EMAIL</code></strong> est l&#8217;adresse de courriel pour le champ « Validateur ».</p>
<p><strong><code class="literal">GIT_COMMITTER_DATE</code></strong> est utilisé pour l&#8217;horodatage dans le champ « Validateur ».</p>
<p><strong><code class="literal">EMAIL</code></strong> est l&#8217;adresse de courriel de repli pour le cas où la valeur de configuration <code class="literal">user.email</code> n&#8217;est pas définie.
Si <em>celle-ci</em> n&#8217;est pas définie, Git se replie sur les noms d&#8217;utilisateur système et d&#8217;hôte.</p>
</section>
<section class="sect2" title="Travail sur le réseau">
<h3 id="_travail_sur_le_réseau">Travail sur le réseau</h3>
<p>Git utilise la bibliothèque <code class="literal">curl</code> pour effectuer des opérations sur HTTP, ainsi <strong><code class="literal">GIT_CURL_VERBOSE</code></strong> demande à Git d&#8217;émettre tous les messages générés par cette bibliothèque.
C&#8217;est similaire à <code class="literal">curl -v</code> en ligne de commande.</p>
<p><strong><code class="literal">GIT_SSL_NO_VERIFY</code></strong> demande à Git de ne pas vérifier les certificats SSL.
Cela peut être parfois nécessaire si vous utilisez des certificats auto-signés pour servir des dépôts Git sur HTTPS, ou si vous êtes au milieu de l&#8217;installation d&#8217;un serveur Git mais n&#8217;avez pas encore installé un certificat complet.</p>
<p>Si le taux de données d&#8217;une opération HTTP est plus basse que <strong><code class="literal">GIT_HTTP_LOW_SPEED_LIMIT</code></strong> octets par seconde pendant plus longtemps que <strong><code class="literal">GIT_HTTP_LOW_SPEED_TIME</code></strong> secondes, Git annulera cette opération.
Ces valeurs surchargent les valeurs de configuration <code class="literal">http.lowSpeedLimit</code> et <code class="literal">http.lowSpeedTime</code>.</p>
<p><strong><code class="literal">GIT_HTTP_USER_AGENT</code></strong> définit la chaîne d&#8217;agent utilisateur utilisée par Git quand il communique sur HTTP.
La valeur par défaut est quelque chose comme <code class="literal">git/2.0.0</code>.</p>
</section>
<section class="sect2" title="Visualisation des différences et Fusion">
<h3 id="_visualisation_des_différences_et_fusion">Visualisation des différences et Fusion</h3>
<p><strong><code class="literal">GIT_DIFF_OPTS</code></strong> est un terme un peu inapproprié.
Les seules valeurs valides sont <code class="literal">-u&lt;n&gt;</code> ou <code class="literal">--unified=&lt;n&gt;</code>, qui contrôlent le nombre de lignes de contexte affichées dans une commande <code class="literal">git diff</code>.</p>
<p><strong><code class="literal">GIT_EXTERNAL_DIFF</code></strong> est utilisée comme une surcharge de la valeur de configuration <code class="literal">diff.external</code>.
Si elle est définie, Git invoquera ce programme quand <code class="literal">git diff</code> sera invoquée.</p>
<p><strong><code class="literal">GIT_DIFF_PATH_COUNTER</code></strong> et <strong><code class="literal">GIT_DIFF_PATH_TOTAL</code></strong> sont utiles à l&#8217;intérieur du programme spécifié par <code class="literal">GIT_EXTERNAL_DIFF</code> ou <code class="literal">diff.external</code>.
Le premier represente le fichier de la série dont on est en train de visualiser les différences (en commençant par 1), et le dernier est le nombre total de fichiers dans le lot.</p>
<p><strong><code class="literal">GIT_MERGE_VERBOSITY</code></strong> contrôle la sortie pour la stratégie de fusion récursive.
Les valeurs admises sont les suivantes :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">0 ne sort rien, sauf éventuellement un seul message d&#8217;erreur.</span>
</li>
<li>
<span class="principal">1 ne montre que les conflits.</span>
</li>
<li>
<span class="principal">2 montre aussi les modifications de fichier.</span>
</li>
<li>
<span class="principal">3 montre quand les fichiers sont sautés parce qu&#8217;ils n&#8217;ont pas changé.</span>
</li>
<li>
<span class="principal">4 montre tous les chemins qui sont en train d&#8217;être traités.</span>
</li>
<li>
<span class="principal">5 et au-delà montrent des informations détaillées de débogage.</span>
</li>
</ul>
</div>
<p>La valeur par défaut est 2.</p>
</section>
<section class="sect2" title="Débogage">
<h3 id="_débogage">Débogage</h3>
<p>Vous voulez <em>vraiment</em> savoir de quoi Git est capable ?
Git comprend un ensemble de traces assez complet, et tout ce que vous avez à faire est de les activer.
Les valeurs possibles de ces variables sont les suivantes :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">« true », « 1 » ou « 2 » – la catégorie de trace est écrite sur la sortie d&#8217;erreur standard (stderr).</span>
</li>
<li>
<span class="principal">Un chemin absolu commençant par <code class="literal">/</code> – la sortie de trace sera écrite dans ce fichier.</span>
</li>
</ul>
</div>
<p><strong><code class="literal">GIT_TRACE</code></strong> contrôle les traces générales, qui ne rentrent dans aucune catégorie spécifique.
Cela inclut le développement des alias et la délégation aux autres sous-programmes.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE=true git lga
20:12:49.877982 git.c:554               trace: exec: &#39;git-lga&#39;
20:12:49.878369 run-command.c:341       trace: run_command: &#39;git-lga&#39;
20:12:49.879529 git.c:282               trace: alias expansion: lga =&gt; &#39;log&#39; &#39;--graph&#39; &#39;--pretty=oneline&#39; &#39;--abbrev-commit&#39; &#39;--decorate&#39; &#39;--all&#39;
20:12:49.879885 git.c:349               trace: built-in: git &#39;log&#39; &#39;--graph&#39; &#39;--pretty=oneline&#39; &#39;--abbrev-commit&#39; &#39;--decorate&#39; &#39;--all&#39;
20:12:49.899217 run-command.c:341       trace: run_command: &#39;less&#39;
20:12:49.899675 run-command.c:192       trace: exec: &#39;less&#39;</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_PACK_ACCESS</code></strong> contrôle le traçage d&#8217;accès aux fichiers groupés.
Le premier champ est le fichier groupé auquel on est en train d&#8217;accéder, le second est le décalage dans ce fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_PACK_ACCESS=true git status
20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 12
20:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 34662
20:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175
<span style="font-weight: bold">#</span> […]
20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 56914983
20:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_PACKET</code></strong> permet le traçage au niveau paquet pour les opérations sur le réseau.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_PACKET=true git ls-remote origin
20:15:14.867043 pkt-line.c:46           packet:          git&lt; # service=git-upload-pack
20:15:14.867071 pkt-line.c:46           packet:          git&lt; 0000
20:15:14.867079 pkt-line.c:46           packet:          git&lt; 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.4
20:15:14.867088 pkt-line.c:46           packet:          git&lt; 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name
20:15:14.867094 pkt-line.c:46           packet:          git&lt; 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config
<span style="font-weight: bold">#</span> […]</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_PERFORMANCE</code></strong> contrôle la journalisation d&#8217;information de performance.
La sortie montre combien de temps prend chaque invocation particulère de Git.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_PERFORMANCE=true git gc
20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: &#39;git&#39; &#39;pack-refs&#39; &#39;--all&#39; &#39;--prune&#39;
20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: &#39;git&#39; &#39;reflog&#39; &#39;expire&#39; &#39;--all&#39;
Counting objects: 170994, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (43413/43413), done.
Writing objects: 100% (170994/170994), done.
Total 170994 (delta 126176), reused 170524 (delta 125706)
20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: &#39;git&#39; &#39;pack-objects&#39; &#39;--keep-true-parents&#39; &#39;--honor-pack-keep&#39; &#39;--non-empty&#39; &#39;--all&#39; &#39;--reflog&#39; &#39;--unpack-unreachable=2.weeks.ago&#39; &#39;--local&#39; &#39;--delta-base-offset&#39; &#39;.git/objects/pack/.tmp-49190-pack&#39;
20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: &#39;git&#39; &#39;prune-packed&#39;
20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: &#39;git&#39; &#39;update-server-info&#39;
20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: &#39;git&#39; &#39;repack&#39; &#39;-d&#39; &#39;-l&#39; &#39;-A&#39; &#39;--unpack-unreachable=2.weeks.ago&#39;
Checking connectivity: 170994, done.
20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: &#39;git&#39; &#39;prune&#39; &#39;--expire&#39; &#39;2.weeks.ago&#39;
20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: &#39;git&#39; &#39;rerere&#39; &#39;gc&#39;
20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: &#39;git&#39; &#39;gc&#39;</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_SETUP</code></strong> montre des informations sur ce que Git découvre sur le dépôt et l&#8217;environnement avec lequel il interagit.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_SETUP=true git status
20:19:47.086765 trace.c:315             setup: git_dir: .git
20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git
20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git
20:19:47.087194 trace.c:318             setup: prefix: (null)
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean</code></pre>
</figure>
</section>
<section class="sect2" title="Divers">
<h3 id="_divers">Divers</h3>
<p><strong><code class="literal">GIT_SSH</code></strong>, si spécifié, est un programme qui est invoqué à la place de <code class="literal">ssh</code> quand Git essaie de se connecter à un hôte SSH.
Il est invoqué comme <code class="literal">$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code>.
Notez que ce n&#8217;est pas le moyen le plus facile de personnaliser la façon dont ssh est invoqué ; il ne prendra pas en compte des paramètres supplémentaires en ligne de commande, donc vous devriez écrire un script l&#8217;enveloppant et faire pointer <code class="literal">GIT_SSH</code> dessus.
Il est sans doute plus facile d&#8217;utiliser le fichier <code class="literal">~/.ssh/config</code> pour cela.</p>
<p><strong><code class="literal">GIT_ASKPASS</code></strong> est une surcharge pour la valeur de configuration <code class="literal">core.askpass</code>.
C&#8217;est le programme invoqué lorsque Git à besoin de demander ses identifiants à l&#8217;utilisateur, qui peut s&#8217;attendre à un texte comme argument en ligne de commande, et qui devrait retourner la réponse sur la sortie standard (<code class="literal">stdout</code>).
(Consultez <a id="xref--ch07-git-tools--s_credential_caching" href="ch07-git-tools.xhtml#s_credential_caching" class="xref">Stockage des identifiants</a> pour plus d&#8217;information sur ce sous-système.)</p>
<p><strong><code class="literal">GIT_NAMESPACE</code></strong> contrôle l&#8217;accès des références cloisonnées dans des espaces de nom, et est équivalent à l&#8217;option <code class="literal">--namespace</code>.
C&#8217;est surtout utile côté serveur, où vous pourriez vouloir stocker plusieurs bifurcations (<em>forks</em>) d&#8217;un seul dépôt dans un seul dépôt, en gardant seulement les références séparées.</p>
<p><strong><code class="literal">GIT_FLUSH</code></strong> peut être utilisée pour forcer Git à utiliser des entrées/sorties non mises en mémoire tampon (<em>buffer</em>) quand il écrit progressivement dans la sortie standard.
Une valeur de 1 fait que Git évacue (<em>flush</em>) plus souvent, une valeur de 0 fait que la sortie est mise en mémoire tampon.
La valeur par défaut (si la variable n&#8217;est pas définie) est à choisir selon un plan approprié de mise en mémoire tampon en fonction de l&#8217;activité et du mode de sortie.</p>
<p><strong><code class="literal">GIT_REFLOG_ACTION</code></strong> vous permet de spécifier le texte descriptif écrit dans le <code class="literal">reflog</code>.
Voici un exemple :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_REFLOG_ACTION=<span style="font-style: italic">&quot;my action&quot;</span> git commit --allow-empty -m <span style="font-style: italic">&#39;my message&#39;</span>
[master 9e3d55a] my message
<span style="font-weight: bold">$</span> git reflog -1
9e3d55a HEAD@{0}: my action: my message</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="Résumé">
<h2 id="_résumé">Résumé</h2>
<p>Vous devriez avoir une assez bonne compréhension de ce que Git fait en arrière-plan et, jusqu&#8217;à un certain niveau, comment il est implémenté.
Ce chapitre a parcouru plusieurs commandes de plomberie, qui sont à un niveau plus bas et plus simple que les commandes de porcelaine que vous avez vues dans le reste du livre.
Comprendre comment Git travaille à bas niveau devrait vous aider à comprendre pourquoi il fait ce qu&#8217;il fait et à créer vos propres outils et scripts pour vous permettre de travailler comme vous l&#8217;entendez.</p>
<p>Git, en tant que système de fichiers adressable par contenu, est un outil puissant que vous pouvez utiliser pour des fonctionnalités au-delà d&#8217;un système de contrôle de version.
Nous espérons que vous pourrez utiliser votre connaissance nouvellement acquise des tripes de Git pour implémenter votre propre super application avec cette technologie et que vous vous sentirez plus à l&#8217;aise pour utiliser Git de manière plus poussée.</p>
</section>
</section>
</body>
</html>