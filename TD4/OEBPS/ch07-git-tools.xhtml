<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
<meta charset="UTF-8"/>
<title>Utilitaires Git</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Utilitaires Git" epub:type="chapter" id="ch07-git-tools">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Utilitaires</b> <b>Git</b></small></h1>
</div>
</header>
<p>À présent, vous avez appris les commandes et modes de fonctionnement usuels requis pour gérer et maintenir un dépôt Git pour la gestion de votre code source.
Vous avez déroulé les routines de suivi et de validation de fichiers, vous avez exploité la puissance de l&#8217;index, de la création et de la fusion de branches locales de travail.</p>
<p>Maintenant, vous allez explorer un certain nombre de fonctionnalités particulièrement efficaces, fonctionnalités que vous utiliserez moins souvent mais dont vous pourriez avoir l&#8217;usage à un moment ou à un autre.</p>
<section class="sect1" title="Sélection des versions">
<h2 id="s_revision_selection">Sélection des versions</h2>
<p>Git vous permet de faire référence à certains <em>commits</em> ou un ensemble de <em>commits</em> de différentes façons.
Si elles ne sont pas toutes évidentes, il est bon de les connaître.</p>
<section class="sect2" title="Révisions ponctuelles">
<h3 id="_révisions_ponctuelles">Révisions ponctuelles</h3>
<p>Naturellement, vous pouvez référencer un <em>commit</em> par sa signature SHA-1, mais il existe des méthodes plus confortables pour les humains.
Cette section présente les méthodes pour référencer un <em>commit</em> simple.</p>
</section>
<section class="sect2" title="Empreinte SHA courte">
<h3 id="_empreinte_sha_courte">Empreinte SHA courte</h3>
<p>Git est capable de deviner de quel <em>commit</em> vous parlez si vous ne fournissez que quelques caractères du début de la signature, tant que votre SHA-1 partiel comporte au moins 4 caractères et ne correspond pas à plusieurs <em>commits</em>.
Dans ces conditions, un seul objet correspondra à ce SHA-1 partiel.</p>
<p>Par exemple, pour afficher un <em>commit</em> précis, supposons que vous exécutiez <code class="literal">git log</code> et que vous identifiiez le <em>commit</em> où vous avez introduit une fonctionnalité précise.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &#39;phedders/rdocs&#39;

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff</code></pre>
</figure>
<p>Pour cet exemple, choisissons <code class="literal">1c002dd...</code>.
Si vous affichez le contenu de ce <em>commit</em> via <code class="literal">git show</code>, les commandes suivantes sont équivalentes (en partant du principe que les SHA-1 courts ne sont pas ambigus).</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
<span style="font-weight: bold">$</span> git show 1c002dd4b536e7479f
<span style="font-weight: bold">$</span> git show 1c002d</code></pre>
</figure>
<p>Git peut déterminer une référence SHA-1 tout à la fois la plus courte possible et non ambigüe.
Ajoutez l&#8217;option <code class="literal">--abbrev-commit</code> à la commande <code class="literal">git log</code> et le résultat affiché utilisera des valeurs plus courtes mais uniques ; par défaut Git retiendra 7 caractères et augmentera au besoin :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit</code></pre>
</figure>
<p>En règle générale, entre 8 et 10 caractères sont largement suffisant pour assurer l&#8217;unicité dans un projet.</p>
<p>Un des plus gros projets utilisant Git, le noyau Linux, est un projet plutôt important de plus de 450k <em>commits</em> et 3,6 millions d&#8217;objets dont les empreintes SHA sont uniques à partir des 11 premiers caractères.</p>
<aside class="admonition note" title="Note: Quelques mots sur SHA-1" epub:type="note">
<h2>Quelques mots sur SHA-1</h2>
<div class="content">
<p>Beaucoup de gens s&#8217;inquiètent qu&#8217;à un moment donné ils auront, par des circonstances hasardeuses, deux objets dans leur référentiel de hachage de même empreinte SHA-1.
Qu&#8217;en est-il réellement ?</p>
<p>S&#8217;il vous arrivait de valider un objet qui se hache à la même empreinte SHA-1 qu&#8217;un objet existant dans votre référentiel, Git verrait l&#8217;objet existant déjà dans votre base de données et présumerait qu&#8217;il était déjà enregistré.
Si vous essayez de récupérer l&#8217;objet de nouveau à un moment donné, vous auriez toujours les données du premier objet.</p>
<p>Quoi qu&#8217;il en soit, vous devriez être conscient à quel point ce scénario est ridiculement improbable.
Une empreinte SHA-1 porte sur 20 octets soit 160 bits.
Le nombre d&#8217;objets aléatoires à hacher requis pour assurer une probabilité de collision de 50 % vaut environ 2<sup>80</sup> (la formule pour calculer la probabilité de collision est <code class="literal">p = (n(n-1)/2) * (1/2^160)</code>).
2<sup>80</sup> vaut 1,2 × 10<sup>24</sup> soit 1 million de milliards de milliards.
Cela représente 1200 fois le nombre de grains de sable sur Terre.</p>
<p>Voici un exemple pour vous donner une idée de ce qui pourrait provoquer une collision du SHA-1.
Si tous les 6,5 milliards d&#8217;humains sur Terre programmaient et que chaque seconde, chacun produisait du code équivalent à l&#8217;historique entier du noyau Linux (3,6 million d&#8217;objets Git) et le poussait sur un énorme dépôt Git, cela prendrait 2 ans pour que ce dépôt contienne assez d&#8217;objets pour avoir une probabilité de 50 % qu&#8217;une seule collision SHA-1 existe.
Il y a une probabilité plus grande que tous les membres de votre équipe de programmation soient attaqués et tués par des loups dans des incidents sans relation la même nuit.</p>
</div>
</aside>
</section>
<section class="sect2" title="Références de branches">
<h3 id="s_branch_references">Références de branches</h3>
<p>La méthode la plus commune pour désigner un <em>commit</em> est une branche y pointant.
Dès lors, vous pouvez utiliser le nom de la branche dans toute commande utilisant un objet de type <em>commit</em> ou un SHA-1.
Par exemple, si vous souhaitez afficher le dernier <em>commit</em> d&#8217;une branche, les commandes suivantes sont équivalentes, en supposant que la branche <code class="literal">sujet1</code> pointe sur <code class="literal">ca82a6d</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show ca82a6dff817ec66f44342007202690a93763949
<span style="font-weight: bold">$</span> git show sujet1</code></pre>
</figure>
<p>Pour connaître l&#8217;empreinte SHA sur laquelle pointe une branche ou pour savoir parmi tous les exemples précédents ce que cela donne en terme de SHA, vous pouvez utiliser la commande de plomberie nommée <code class="literal">rev-parse</code>.
Référez-vous à <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Les tripes de Git</a> pour plus d&#8217;informations sur les commandes de plomberie ; <code class="literal">rev-parse</code> sert aux opérations de bas niveau et n&#8217;est pas conçue pour être utilisée quotidiennement.
Quoi qu&#8217;il en soit, elle se révèle utile pour comprendre ce qui se passe.
Je vous invite à tester <code class="literal">rev-parse</code> sur votre propre branche.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</figure>
</section>
<section class="sect2" title="Raccourcis RefLog">
<h3 id="s_git_reflog">Raccourcis RefLog</h3>
<p>Git maintient en arrière-plan un historique des références où sont passés HEAD et vos branches sur les derniers mois — ceci s&#8217;appelle le <em>reflog</em>.</p>
<p>Vous pouvez le consulter avec la commande <code class="literal">git reflog</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reflog
734713b... HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970... HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd... HEAD@{2}: commit: added some blame and merge stuff
1c36188... HEAD@{3}: rebase -i (squash): updating HEAD
95df984... HEAD@{4}: commit: # This is a combination of two commits.
1c36188... HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5... HEAD@{6}: rebase -i (pick): updating HEAD</code></pre>
</figure>
<p>À chaque fois que l&#8217;extrémité de votre branche est modifiée, Git enregistre cette information pour vous dans son historique temporaire.
Vous pouvez référencer d&#8217;anciens <em>commits</em> avec cette donnée.
Si vous souhaitez consulter le n-ième antécédent de votre HEAD, vous pouvez utiliser la référence <code class="literal">@{n}</code> du reflog, 5 dans cet exemple :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD@{5}</code></pre>
</figure>
<p>Vous pouvez également remonter le temps et savoir où en était une branche à une date donnée.
Par exemple, pour savoir où en était la branche <code class="literal">master</code> hier (<em>yesterday</em> en anglais), tapez :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show master@{yesterday}</code></pre>
</figure>
<p>Cette technique fonctionne uniquement si l&#8217;information est encore présente dans le reflog et vous ne pourrez donc pas le consulter sur des <em>commits</em> plus vieux que quelques mois.</p>
<p>Pour consulter le reflog au format <code class="literal">git log</code>, exécutez: <code class="literal">git log -g</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &#39;phedders/rdocs&#39;</code></pre>
</figure>
<p>Veuillez noter que le reflog ne stocke que des informations locales, c&#8217;est un historique de ce que vous avez fait dans votre dépôt.
Les références sont différentes pour un autre dépôt et juste après le clone d&#8217;un dépôt, votre reflog sera vide puisque qu&#8217;aucune activité n&#8217;aura été produite.
Exécuter <code class="literal">git show HEAD@{2.months.ago}</code> ne fonctionnera que si vous avez dupliqué ce projet depuis au moins 2 mois — si vous l&#8217;avez dupliqué il y a 5 minutes, vous n&#8217;obtiendrez aucun résultat.</p>
</section>
<section class="sect2" title="Références ancêtres">
<h3 id="_références_ancêtres">Références ancêtres</h3>
<p>Une solution fréquente pour référencer un <em>commit</em> est d&#8217;utiliser son ascendance.
Si vous suffixez une référence par <code class="literal">^</code>, Git la résoudra comme étant le parent de cette référence.
Supposons que vous consultiez votre historique :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&#39;%h %s&#39;</span> --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit &#39;phedders/rdocs&#39;
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list</code></pre>
</figure>
<p>Alors, vous pouvez consulter le <em>commit</em> précédent en spécifiant <code class="literal">HEAD^</code>, ce qui signifie « le parent de HEAD » :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &#39;phedders/rdocs&#39;</code></pre>
</figure>
<p>Vous pouvez également spécifier un nombre après <code class="literal">^</code> — par exemple, <code class="literal">d921970^2</code> signifie « le second parent de d921970 ».
Cette syntaxe ne sert que pour les <em>commits</em> de fusion, qui ont plus d&#8217;un parent.
Le premier parent est la branche depuis laquelle vous avez fusionné, et le second est le <em>commit</em> de la branche que vous avez fusionnée :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

<span style="font-weight: bold">$</span> git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes</code></pre>
</figure>
<p>Une autre solution courante pour spécifier une référence ancêtre est le <code class="literal">~</code>.
Il fait également référence au premier parent, donc <code class="literal">HEAD~</code> et <code class="literal">HEAD^</code> sont équivalents.
La différence apparaît si vous spécifiez un nombre.
<code class="literal">HEAD~2</code> signifie « le premier parent du premier parent », ou bien « le grand-parent » ; on remonte les premiers parents autant de fois que demandé.
Par exemple, dans l&#8217;historique précédemment présenté, <code class="literal">HEAD~3</code> serait :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</figure>
<p>Cela peut aussi s&#8217;écrire <code class="literal">HEAD^^^</code>, qui là encore est le premier parent du premier parent du premier parent :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</figure>
<p>Vous pouvez également combiner ces syntaxes — vous pouvez obtenir le second parent de la référence précédente (en supposant que c&#8217;était un <em>commit</em> de fusion) en utilisant <code class="literal">HEAD~3^2</code>, et ainsi de suite.</p>
</section>
<section class="sect2" title="Plages de commits">
<h3 id="s_commit_ranges">Plages de <em>commits</em></h3>
<p>À présent que vous pouvez spécifier des <em>commits</em> individuels, voyons comment spécifier des plages de <em>commits</em>.
Ceci est particulièrement pratique pour la gestion des branches — si vous avez beaucoup de branches, vous pouvez utiliser les plages pour répondre à des questions telles que « Quel travail sur cette branche n&#8217;ai-je pas encore fusionné sur ma branche principale ? ».</p>
<section class="sect3" title="Double point">
<h4 id="_double_point">Double point</h4>
<p>La spécification de plage de <em>commits</em> la plus fréquente est la syntaxe double-point.
En gros, cela demande à Git de résoudre la plage des <em>commits</em> qui sont accessibles depuis un <em>commit</em> mais ne le sont pas depuis un autre.
Par exemple, disons que votre historique ressemble à <a id="xref-double_dot" href="#double_dot" class="xref">Exemple d&#8217;historique pour la sélection de plage.</a>.</p>
<figure id="double_dot" class="image">
<div class="content">
<img src="images/double-dot.png" alt="Exemple d'historique pour la sélection de plage."/>
</div>
<figcaption>Figure 1. Exemple d&#8217;historique pour la sélection de plage.</figcaption>
</figure>
<p>Si vous voulez savoir ce qui n&#8217;a pas encore été fusionné sur votre branche <code class="literal">master</code> depuis votre branche <code class="literal">experiment</code>, vous pouvez demander à Git de vous montrer un journal des <em>commits</em> avec <code class="literal">master..experiment</code> — ce qui signifie « tous les <em>commits</em> accessibles par <code class="literal">experiment</code> qui ne le sont pas par <code class="literal">master</code> ».
Dans un souci de brièveté et de clarté de ces exemples, je vais utiliser les lettres des <em>commits</em> issus du diagramme à la place de la vraie liste dans l&#8217;ordre où ils auraient dû être affichés :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log master..experiment
D
C</code></pre>
</figure>
<p>Si, par contre, vous souhaitez voir l&#8217;opposé — tous les <em>commits</em> dans <code class="literal">master</code> mais pas encore dans <code class="literal">experiment</code> — vous pouvez inverser les noms de branches, <code class="literal">experiment..master</code> vous montre tout ce que <code class="literal">master</code> accède mais qu'<code class="literal">experiment</code> ne voit pas :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log experiment..master
F
E</code></pre>
</figure>
<p>C&#8217;est pratique si vous souhaitez maintenir <code class="literal">experiment</code> à jour et anticiper les fusions.
Un autre cas d&#8217;utilisation fréquent consiste à voir ce que vous vous apprêtez à pousser sur une branche distante :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log origin/master..HEAD</code></pre>
</figure>
<p>Cette commande vous affiche tous les <em>commits</em> de votre branche courante qui ne sont pas sur la branche <code class="literal">master</code> du dépôt distant <code class="literal">origin</code>.
Si vous exécutez <code class="literal">git push</code> et que votre branche courante suit <code class="literal">origin/master</code>, les <em>commits</em> listés par <code class="literal">git log origin/master..HEAD</code> sont les <em>commits</em> qui seront transférés sur le serveur.
Vous pouvez également laisser tomber une borne de la syntaxe pour faire comprendre à Git que vous parlez de HEAD.
Par exemple, vous pouvez obtenir les mêmes résultats que précédemment en tapant <code class="literal">git log origin/master..</code> — Git utilise HEAD si une des bornes est manquante.</p>
</section>
<section class="sect3" title="Emplacements multiples">
<h4 id="_emplacements_multiples">Emplacements multiples</h4>
<p>La syntaxe double-point est pratique comme raccourci ; mais peut-être souhaitez-vous utiliser plus d&#8217;une branche pour spécifier une révision, comme pour voir quels <em>commits</em> sont dans plusieurs branches mais sont absents de la branche courante.
Git vous permet cela avec <code class="literal">^</code> ou <code class="literal">--not</code> en préfixe de toute référence de laquelle vous ne souhaitez pas voir les <em>commits</em>.
Les 3 commandes ci-après sont équivalentes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log refA..refB
<span style="font-weight: bold">$</span> git log ^refA refB
<span style="font-weight: bold">$</span> git log refB --not refA</code></pre>
</figure>
<p>C&#8217;est utile car cela vous permet de spécifier plus de 2 références dans votre requête, ce que vous ne pouvez accomplir avec la syntaxe double-point.
Par exemple, si vous souhaitez voir les <em>commits</em> qui sont accessibles depuis <code class="literal">refA</code> et <code class="literal">refB</code> mais pas depuis <code class="literal">refC</code>, vous pouvez taper ces 2 commandes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log refA refB ^refC
<span style="font-weight: bold">$</span> git log refA refB --not refC</code></pre>
</figure>
<p>Ceci vous fournit un système de requêtage des révisions très puissant, pour vous aider à saisir ce qui se trouve sur vos branches.</p>
</section>
<section class="sect3" title="Triple point">
<h4 id="s_triple_dot">Triple point</h4>
<p>La dernière syntaxe majeure de sélection de plage de <em>commits</em> est la syntaxe triple-point qui spécifie tous les <em>commits</em> accessibles par l&#8217;une des deux références, exclusivement.
Toujours avec l&#8217;exemple d&#8217;historique de <a href="#double_dot" class="xref">Exemple d&#8217;historique pour la sélection de plage.</a>, si vous voulez voir ce qui se trouve sur <code class="literal">master</code> ou <code class="literal">experiment</code> mais pas sur les deux, exécutez :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log master...experiment
F
E
D
C</code></pre>
</figure>
<p>Encore une fois, cela vous donne un <code class="literal">log</code> normal mais ne vous montre les informations que pour ces quatre <em>commits</em>, dans l&#8217;ordre naturel des dates de validation.</p>
<p>Une option courante à utiliser avec la commande <code class="literal">log</code> dans ce cas est <code class="literal">--left-right</code> qui vous montre la borne de la plage à laquelle ce <em>commit</em> appartient.
Cela rend les données plus utiles :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --left-right master...experiment
&lt; F
&lt; E
<span style="font-weight: bold">&gt;</span> D
<span style="font-weight: bold">&gt;</span> C</code></pre>
</figure>
<p>Avec ces outils, vous pourrez spécifier à Git les <em>commits</em> que vous souhaitez inspecter.</p>
</section>
</section>
</section>
<section class="sect1" title="Indexation interactive">
<h2 id="s_interactive_staging">Indexation interactive</h2>
<p>Git propose quelques scripts qui rendent les opérations en ligne de commande plus simples.
Nous allons à présent découvrir des commandes interactives vous permettant de choisir les fichiers ou les parties d&#8217;un fichier à incorporer à un <em>commit</em>.
Ces outils sont particulièrement pratiques si vous modifiez un grand nombre de fichiers et que vous souhaitez valider ces changements en modifications plus atomiques plutôt que d&#8217;un tenant.
De la sorte, vous vous assurez que vos <em>commits</em> sont des ensembles cohérents de modifications et qu&#8217;ils peuvent être facilement revus par vos collaborateurs.
Si vous exécutez <code class="literal">git add</code> avec l&#8217;option <code class="literal">-i</code> ou <code class="literal">--interactive</code>, Git entre en mode interactif et affiche quelque chose comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt;</code></pre>
</figure>
<p>Vous vous apercevrez que cette commande propose une vue bien différente de votre index ; en gros, c&#8217;est la même information que vous auriez obtenue avec <code class="literal">git status</code> mais en plus succinct et plus instructif.
Cela liste les modifications que vous avez indexées à gauche et celles hors index à droite.</p>
<p>En dessous vient la section des commandes (<strong>Commands</strong>).
Vous aurez accès à un certain nombre d&#8217;actions, notamment indexer des fichiers, les enlever de l&#8217;index, indexer des parties de fichiers, ajouter des fichiers non indexés, et vérifier les différences de ce que vous avez indexé.</p>
<section class="sect2" title="Indexation et désindexation des fichiers">
<h3 id="_indexation_et_désindexation_des_fichiers">Indexation et désindexation des fichiers</h3>
<p>Si vous tapez <code class="literal">2</code> ou <code class="literal">u</code> au prompt <code class="literal">What now&gt;</code>, le script vous demande quels fichiers vous voulez indexer :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>What now&gt; 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;</code></pre>
</figure>
<p>Pour indexer les fichiers TODO et index.html, vous pouvez taper ces nombres :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Update&gt;&gt; 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;</code></pre>
</figure>
<p>Le caractère <code class="literal">*</code> au début de la ligne de chaque fichier indique que celui-ci est sélectionné.
Si vous tapez Entrée sur l&#8217;invite <code class="literal">Update&gt;&gt;</code>, Git prend tout ce qui est sélectionné et l&#8217;indexe pour vous :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Update&gt;&gt;
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb</code></pre>
</figure>
<p>À présent, vous pouvez voir que les fichiers TODO et index.html sont indexés (<em>staged</em> en anglais) et que <code class="literal">simplegit.rb</code> ne l&#8217;est toujours pas.
Si vous souhaitez enlever de l&#8217;index le fichier TODO, utilisez <code class="literal">3</code> (ou <code class="literal">r</code> pour revert en anglais) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; [enter]
reverted one path</code></pre>
</figure>
<p>Un aperçu rapide à votre statut Git et vous pouvez voir que vous avez enlevé le fichier TODO de l&#8217;index :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb</code></pre>
</figure>
<p>Pour voir la modification que vous avez indexée, utilisez <code class="literal">6</code> ou <code class="literal">d</code> (pour différence).
Cela vous affiche la liste des fichiers indexés et vous pouvez choisir ceux pour lesquels vous voulez consulter la différence.
C&#8217;est équivalent à <code class="literal">git diff --cached</code> en ligne de commande :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff&gt;&gt; 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;

-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;
+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;

 &lt;script type=&quot;text/javascript&quot;&gt;</code></pre>
</figure>
<p>Avec ces commandes élémentaires, vous pouvez utiliser l&#8217;ajout interactif pour manipuler votre index un peu plus facilement.</p>
</section>
<section class="sect2" title="Indexations partielles">
<h3 id="_indexations_partielles">Indexations partielles</h3>
<p>Git est également capable d&#8217;indexer certaines parties d&#8217;un fichier.
Par exemple, si vous modifiez en deux endroits votre fichier <code class="literal">simplegit.rb</code> et que vous souhaitez indexer une modification seulement, cela peut se faire très aisément avec Git.
En mode interactif, tapez <code class="literal">5</code> ou <code class="literal">p</code> (pour <em>patch</em> en anglais).
Git vous demandera quels fichiers vous voulez indexer partiellement, puis, pour chacun des fichiers sélectionnés, il affichera les parties du fichier où il y a des différences et vous demandera si vous souhaitez les indexer, une par une :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log -n 25 #{treeish}&quot;)
+    command(&quot;git log -n 30 #{treeish}&quot;)
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</code></pre>
</figure>
<p>À cette étape, vous disposez de bon nombre d&#8217;options.
<code class="literal">?</code> vous liste les actions possibles dont voici une traduction :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Indexer cette partie [y,n,a,d,/,j,J,g,e,?]? ?
y - indexer cette partie
n - ne pas indexer cette partie
a - indexer cette partie et toutes celles restantes dans ce fichier
d - ne pas indexer cette partie ni aucune de celles restantes dans ce fichier
g - sélectionner une partie à voir
/ - chercher une partie correspondant à la regexp donnée
j - laisser cette partie non décidée, voir la prochaine partie non encore décidée
J - laisser cette partie non décidée, voir la prochaine partie
k - laisser cette partie non décidée, voir la partie non encore décidée précédente
K - laisser cette partie non décidée, voir la partie précédente
s - couper la partie courante en parties plus petites
e - modifier manuellement la partie courante
? - afficher l&#39;aide</code></pre>
</figure>
<p>En règle générale, vous choisirez <code class="literal">y</code> ou <code class="literal">n</code> pour indexer ou non chacun des blocs, mais tout indexer pour certains fichiers ou remettre à plus tard le choix pour un bloc peut également être utile.
Si vous indexez une partie d&#8217;un fichier et une autre non, votre statut ressemblera à peu près à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb</code></pre>
</figure>
<p>Le statut pour le fichier <code class="literal">simplegit.rb</code> est intéressant.
Il vous montre que quelques lignes sont indexées et d&#8217;autres non.
Vous avez partiellement indexé ce fichier.
Dès lors, vous pouvez quitter l&#8217;ajout interactif et exécuter <code class="literal">git commit</code> pour valider les fichiers partiellement indexés.</p>
<p>Enfin, vous pouvez vous passer du mode interactif pour indexer partiellement un fichier ; vous pouvez faire de même avec <code class="literal">git add -p</code> ou <code class="literal">git add --patch</code> en ligne de commande.</p>
<p>De plus, vous pouvez utiliser le mode patch pour réinitialiser partiellement des fichiers avec la commande <code class="literal">reset --patch</code>, pour extraire des parties de fichiers avec <code class="literal">checkout --patch</code> et pour remiser des parties de fichiers avec <code class="literal">stash save --patch</code>.
Nous explorerons plus en détail chacune des ces commandes quand nous aborderons les usages avancés de ces commandes.</p>
</section>
</section>
<section class="sect1" title="Remisage et nettoyage">
<h2 id="s_git_stashing">Remisage et nettoyage</h2>
<p>Souvent, lorsque vous avez travaillé sur une partie de votre projet, les choses sont dans un état instable mais vous voulez changer de branche pour travailler momentanément sur autre chose.
Le problème est que vous ne voulez pas valider un travail à moitié fait seulement pour pouvoir y revenir plus tard.
La réponse à cette problématique est la commande <code class="literal">git stash</code>.</p>
<p>Remiser prend l&#8217;état en cours de votre répertoire de travail, c&#8217;est-à-dire les fichiers modifiés et l&#8217;index, et l&#8217;enregistre dans la pile des modifications non finies que vous pouvez ré-appliquer à n&#8217;importe quel moment.</p>
<section class="sect2" title="Remiser votre travail">
<h3 id="_remiser_votre_travail">Remiser votre travail</h3>
<p>Pour démontrer cette possibilité, allez dans votre projet et commencez à travailler sur quelques fichiers et indexez l&#8217;un de ces changements.
Si vous exécutez <code class="literal">git status</code>, vous pouvez voir votre état modifié :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
Modifications qui seront validées :
  (utilisez &quot;git reset HEAD &lt;fichier&gt;...&quot; pour désindexer)

	modifié :   index.html

Modifications qui ne seront pas validées :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
  (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)

	modifié :   lib/simplegit.rb</code></pre>
</figure>
<p>À ce moment-là, vous voulez changer de branche, mais vous ne voulez pas encore valider ce travail ; vous allez donc remiser vos modifications.
Pour créer une nouvelle remise sur votre pile, exécutez <code class="literal">git stash</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash
Saved working directory and index state \
  &quot;WIP on master: 049d078 added the index file&quot;
HEAD is now at 049d078 added the index file
(To restore them type &quot;git stash apply&quot;)</code></pre>
</figure>
<p>Votre répertoire de travail est propre :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
Sur la branche master
rien à valider, la copie de travail est propre</code></pre>
</figure>
<p>À ce moment, vous pouvez facilement changer de branche et travailler autre part ; vos modifications sont conservées dans votre pile.
Pour voir quelles remises vous avez sauvegardées, vous pouvez utiliser la commande <code class="literal">git stash list</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert &quot;added file_size&quot;
stash@{2}: WIP on master: 21d80a5... added number to log</code></pre>
</figure>
<p>Dans ce cas, deux remises ont été créées précédemment, vous avez donc accès à trois travaux remisés différents.
Vous pouvez ré-appliquer celui que vous venez juste de remiser en utilisant la commande affichée dans la sortie d&#8217;aide de la première commande de remise : <code class="literal">git stash apply</code>.
Si vous voulez appliquer une remise plus ancienne, vous pouvez la spécifier en la nommant, comme ceci : <code class="literal">git stash apply stash@{2}</code>.
Si vous ne spécifiez pas une remise, Git présume que vous voulez la remise la plus récente et essaye de l&#8217;appliquer.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash apply
Sur la branche master
Modifications qui ne seront pas validées :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
  (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)

     modified:   index.html
     modified:   lib/simplegit.rb</code></pre>
</figure>
<p>Vous pouvez observer que Git remodifie les fichiers non validés lorsque vous avez créé la remise.
Dans ce cas, vous aviez un répertoire de travail propre lorsque vous avez essayé d&#8217;appliquer la remise et vous l&#8217;avez fait sur la même branche que celle où vous l&#8217;aviez créée ; mais avoir un répertoire de travail propre et l&#8217;appliquer sur la même branche n&#8217;est pas nécessaire pour réussir à appliquer une remise.
Vous pouvez très bien créer une remise sur une branche, changer de branche et essayer d&#8217;appliquer ces modifications.
Vous pouvez même avoir des fichiers modifiés et non validés dans votre répertoire de travail quand vous appliquez une remise, Git vous indique les conflits de fusions si quoi que ce soit ne s&#8217;applique pas proprement.</p>
<p>Par défaut, les modifications de vos fichiers sont ré-appliquées, mais pas les indexations.
Pour cela, vous devez exécuter la commande <code class="literal">git stash apply</code> avec l&#8217;option <code class="literal">--index</code> pour demander à Git d&#8217;essayer de ré-appliquer les modifications de votre index.
Si vous exécutez cela à la place de la commande précédente, vous vous retrouvez dans la position d&#8217;origine précédent la remise :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash apply --index
Sur la branche master
Modifications qui seront validées :
  (utilisez &quot;git reset HEAD &lt;fichier&gt;...&quot; pour désindexer)

     modifié :   index.html

Modifications qui ne seront pas validées :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
  (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)

     modified:   lib/simplegit.rb</code></pre>
</figure>
<p>L&#8217;option <code class="literal">apply</code> essaye seulement d&#8217;appliquer le travail remisé, vous aurez toujours la remise dans votre pile.
Pour la supprimer, vous pouvez exécuter <code class="literal">git stash drop</code> avec le nom de la remise à supprimer :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert &quot;added file_size&quot;
stash@{2}: WIP on master: 21d80a5... added number to log
<span style="font-weight: bold">$</span> git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</code></pre>
</figure>
<p>Vous pouvez également exécuter <code class="literal">git stash pop</code> pour appliquer et supprimer immédiatement la remise de votre pile.</p>
</section>
<section class="sect2" title="Remisage créatif">
<h3 id="_remisage_créatif">Remisage créatif</h3>
<p>Il existe des variantes de remisages qui peuvent s&#8217;avérer utiles.
La première option assez populaire est l&#8217;option <code class="literal">--keep-index</code> de la commande <code class="literal">stash save</code>.
Elle indique à Git de ne pas remiser ce qui aurait été déjà indexé au moyen de la commande <code class="literal">git add</code>.</p>
<p>C&#8217;est particulièrement utile si vous avez réalisé des modifications mais souhaitez ne valider que certaines d&#8217;entre elles et gérer le reste plus tard.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
M  index.html
 M lib/simplegit.rb

<span style="font-weight: bold">$</span> git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

<span style="font-weight: bold">$</span> git status -s
M  index.html</code></pre>
</figure>
<p>Une autre option utile de <code class="literal">stash</code> est la possibilité de remiser les fichiers non suivis aussi bien que les fichiers suivis.
Par défaut, <code class="literal">git stash</code> ne sauve que les fichiers qui sont déjà suivis ou indexés.
Si vous spécifiez l&#8217;option <code class="literal">--include-untracked</code> ou <code class="literal">-u</code>, Git remisera aussi les fichiers non-suivis du répertoire de travail.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

<span style="font-weight: bold">$</span> git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

<span style="font-weight: bold">$</span> git status -s
<span style="font-weight: bold">$</span></code></pre>
</figure>
<p>Enfin, si vous ajoutez l&#8217;option <code class="literal">--patch</code>, Git ne remisera pas tout le contenu modifié, mais vous invitera à sélectionner interactivement les modifications que vous souhaitez remiser et celles que vous souhaiter conserver dans la copie de travail.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2&gt;&amp;1`.chomp
       end
     end
+
+    def show(treeish = &#39;master&#39;)
+      command(&quot;git show #{treeish}&quot;)
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file</code></pre>
</figure>
</section>
<section class="sect2" title="Défaire l&#8217;effet d&#8217;une remise">
<h3 id="_défaire_l_effet_d_une_remise">Défaire l&#8217;effet d&#8217;une remise</h3>
<p>Dans certains cas, il est souhaitable de pouvoir appliquer une modification remisée, réaliser d&#8217;autres modifications, puis défaire les modifications de la remise.
Git ne fournit pas de commande <code class="literal">stash unapply</code> mais il est possible d&#8217;obtenir le même effet en extrayant les modifications qui constituent la remise et en appliquant leur inverse :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash show -p stash@{0} | git apply -R</code></pre>
</figure>
<p>Ici aussi, si la remise n&#8217;est pas indiquée, Git utilise la plus récente.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash show -p | git apply -R</code></pre>
</figure>
<p>La création d&#8217;un alias permettra d&#8217;ajouter effectivement la commande <code class="literal">stash-unapply</code> à votre Git.
Par exemple :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.stash-unapply <span style="font-style: italic">&#39;!git stash show -p | git apply -R&#39;</span>
<span style="font-weight: bold">$</span> git stash
<span style="font-weight: bold">$</span> <span style="font-style: italic">#... travail, travail, travail</span>
<span style="font-weight: bold">$</span> git stash-unapply</code></pre>
</figure>
</section>
<section class="sect2" title="Créer une branche depuis une remise">
<h3 id="_créer_une_branche_depuis_une_remise">Créer une branche depuis une remise</h3>
<p>Si vous remisez votre travail, et l&#8217;oubliez pendant un temps en continuant sur la branche où vous avez créé la remise, vous pouvez avoir un problème en ré-appliquant le travail.
Si l&#8217;application de la remise essaye de modifier un fichier que vous avez modifié depuis, vous allez obtenir des conflits de fusion et vous devrez essayer de les résoudre.
Si vous voulez un moyen plus facile de tester une nouvelle fois les modifications remisées, vous pouvez exécuter <code class="literal">git stash branch</code> qui créera une nouvelle branche à votre place, récupérant le <em>commit</em> où vous étiez lorsque vous avez créé la remise, ré-appliquera votre travail dedans, et supprimera finalement votre remise si cela a réussi :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash branch testchanges
Basculement sur la nouvelle branche &#39;testchanges&#39;
Sur la branche testchanges
Modifications qui seront validées :
  (utilisez &quot;git reset HEAD &lt;fichier&gt;...&quot; pour désindexer)

     modifié :   index.html

Modifications qui ne seront pas validées :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
  (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)

     modified:   lib/simplegit.rb

refs/stash@{0} supprimé (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</code></pre>
</figure>
<p>C&#8217;est un bon raccourci pour récupérer facilement du travail remisé et pouvoir travailler dessus dans une nouvelle branche.</p>
</section>
<section class="sect2" title="Nettoyer son répertoire de travail">
<h3 id="s_git_clean">Nettoyer son répertoire de travail</h3>
<p>Enfin, vous pouvez ne pas souhaiter remiser certain fichiers de votre répertoire de travail, mais simplement vous en débarrasser.
La commande <code class="literal">git clean</code> s&#8217;en chargera pour vous.</p>
<p>Le besoin le plus commun pourra être d&#8217;éliminer les scories générées par les fusions ou les outils externes ou d&#8217;éliminer les artefacts de compilation pour pouvoir relancer une compilation propre.</p>
<p>Faites néanmoins très attention avec cette commande car elle supprime des fichiers non-suivis de votre répertoire de travail.
Si vous changez d&#8217;avis, il est souvent impossible de récupérer après coup le contenu de ces fichiers.
Une option plus sécurisée consiste à lancer <code class="literal">git stash --all</code> pour tout sauvegarder dans une remise.</p>
<p>En supposant que vous souhaitez réellement éliminer les scories et nettoyer votre répertoire de travail, vous pouvez lancer <code class="literal">git clean</code>.
Pour supprimer tous les fichiers non-suivis, vous pouvez lancer <code class="literal">git clean -f -d</code>, qui effacera aussi tout sous-répertoire vide.
L&#8217;option <code class="literal">-f</code> signifie « force », soit « fais-le réellement ».</p>
<p>Si vous souhaitez visualiser ce qui serait fait, vous pouvez lancer la commande avec l&#8217;option <code class="literal">-n</code> qui signifie « fais-le à blanc et montre-moi ce qui <em>serait</em> supprimé ».</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -d -n
Supprimerait test.o
Supprimerait tmp/</code></pre>
</figure>
<p>Par défaut, la commande <code class="literal">git clean</code> ne va supprimer que les fichiers non-suivis qui ne sont pas ignorés.
Tout fichier qui correspond à un motif de votre fichier <code class="literal">.gitignore</code> ou tout autre fichier similaire ne sera pas supprimé.
Si vous souhaitez supprimer aussi ces fichiers, comme par exemple les fichiers <code class="literal">.o</code> généré par un compilateur pour faire une compilation totale, vous pouvez ajouter l&#8217;option <code class="literal">-x</code> à la commande de nettoyage.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

<span style="font-weight: bold">$</span> git clean -n -d
Supprimerait build.TMP
Supprimerait tmp/

<span style="font-weight: bold">$</span> git clean -n -d -x
Supprimerait build.TMP
Supprimerait test.o
Supprimerait tmp/</code></pre>
</figure>
<p>Si vous ne savez pas ce que la commande <code class="literal">git clean</code> va effectivement supprimer, lancez-la une première fois avec <code class="literal">-n</code> par sécurité avant de transformer le <code class="literal">-n</code> en <code class="literal">-f</code> et nettoyer définitivement.
Un autre choix pour s&#8217;assurer de ce qui va être effacé consiste à lancer la commande avec l&#8217;option <code class="literal">-i</code> ou <code class="literal">--interactive</code>.</p>
<p>La commande sera lancée en mode interactif.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -x -i
Supprimerait les éléments suivants :
  build.TMP  test.o
*** Commandes ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
Et maintenant ?&gt;</code></pre>
</figure>
<p>De cette manière, vous pouvez détailler chaque fichier individuellement ou spécifier un motif pour la suppression interactive.</p>
</section>
</section>
<section class="sect1" title="Signer votre travail">
<h2 id="s_signing">Signer votre travail</h2>
<p>Git est cryptographiquement sûr, mais il n&#8217;est pas infaillible.
Si vous récupérez le travail d&#8217;autres personnes sur Internet et souhaitez vérifier que les <em>commits</em> ont effectivement une source de confiance, Git propose quelques méthodes pour signer et vérifier ceci au moyen de GPG.</p>
<section class="sect2" title="Introduction à GPG">
<h3 id="_introduction_à_gpg">Introduction à GPG</h3>
<p>Avant tout, si vous voulez pouvoir signer quoique ce soit, vous devez avoir un GPG configuré et une clé personnelle.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   2048R/0A46826A 2014-06-04
uid                  Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;
sub   2048R/874529A9 2014-06-04</code></pre>
</figure>
<p>Si vous n&#8217;avez pas de clé, vous pouvez en générer une avec la commande <code class="literal">gpg --gen-key</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>gpg --gen-key</code></pre>
</figure>
<p>A présent que vous avez une clé privée permettant de signer, vous pouvez configurer Git pour l&#8217;utiliser pour signer diverses choses en renseignant le paramètre de configuration <code class="literal">user.signingkey</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>git config --global user.signingkey 0A46826A</code></pre>
</figure>
<p>A partir de maintenant, Git utilisera par défaut votre clé pour signer les étiquettes et les <em>commits</em> que vous souhaitez.</p>
</section>
<section class="sect2" title="Signer des étiquettes">
<h3 id="_signer_des_étiquettes">Signer des étiquettes</h3>
<p>Avec votre clé privée GPG renseignée, vous pouvez signer des étiquettes.
Tout ce que vous avez à faire, c&#8217;est remplacer <code class="literal">-a</code> par <code class="literal">-s</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -s v1.5 -m <span style="font-style: italic">&#39;mon étiquette signée 1.5&#39;</span>

You need a passphrase to unlock the secret key for
user: &quot;Ben Straub &lt;ben@straub.cc&gt;&quot;
2048-bit RSA key, ID 800430EB, created 2014-05-04</code></pre>
</figure>
<p>Si vous lancez <code class="literal">git show</code> sur cette étiquette, vous pouvez voir votre signature GPG attachée :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.5
tag v1.5
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:29:41 2014 -0700

mon étiquette signée 1.5
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut
LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b
hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm
ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp
8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi
RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=
EFTF
-----END PGP SIGNATURE-----

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
</section>
<section class="sect2" title="Verifier des étiquettes">
<h3 id="_verifier_des_étiquettes">Verifier des étiquettes</h3>
<p>Pour vérifier une étiquette signée, vous utilisez <code class="literal">git tag -v [nom-de-l-etiquette]</code>.
Cette commande utilise GPG pour vérifier la signature.
Vous devez posséder la clé publique du signataire dans votre trousseau pour que cela fonctionne.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;
gpg:                 aka &quot;[jpeg image of size 1513]&quot;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</code></pre>
</figure>
<p>Si vous ne possédez pas la clé publique du signataire, vous obtiendrez plutôt quelque chose comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can&#39;t check signature: public key not found
error: could not verify the tag &#39;v1.4.2.1&#39;</code></pre>
</figure>
</section>
<section class="sect2" title="Signer des commits">
<h3 id="s_signing_commits">Signer des <em>commits</em></h3>
<p>Dans les versions les plus récentes de Git (à partir de v1.7.9), vous pouvez maintenant signer aussi les <em>commits</em> individuels.
Si signer directement des <em>commits</em> au lieu d&#8217;étiquettes vous intéresse, tout ce que vous avez à faire est d&#8217;ajouter l&#8217;option <code class="literal">-S</code> à votre commande <code class="literal">git commit</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -a -S -m <span style="font-style: italic">&#39;commit signé&#39;</span>

You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;
2048-bit RSA key, ID 0A46826A, created 2014-06-04

[master 5c3386c] commit signé
 4 files changed, 4 insertions(+), 24 deletions(-)
 rewrite Rakefile (100%)
 create mode 100644 lib/git.rb</code></pre>
</figure>
<p>Pour visualiser et vérifier ces signatures, il y a l&#8217;option <code class="literal">--show-signature</code> pour <code class="literal">git log</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --show-signature -1
commit 5c3386cf54bba0a33a32da706aa52bc0155503c2
gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A
gpg: Good signature from &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Jun 4 19:49:17 2014 -0700

    commit signé</code></pre>
</figure>
<p>En complément, vous pouvez configurer <code class="literal">git log</code> pour vérifier toutes les signatures qu&#8217;il trouvera et les montrer grâce au formatage <code class="literal">%G?</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=<span style="font-style: italic">&quot;format:%h %G? %aN  %s&quot;</span>

5c3386c G Scott Chacon  commit signé
ca82a6d N Scott Chacon  changed the verison number
085bb3b N Scott Chacon  removed unnecessary test code
a11bef0 N Scott Chacon  first commit</code></pre>
</figure>
<p>Ici nous pouvons voir que seul le dernier <em>commit</em> est signé et valide tandis que les précédents ne le sont pas.</p>
<p>Depuis Git 1.8.3, <code class="literal">git merge</code> et <code class="literal">git pull</code> peuvent vérifier et annuler une fusion d&#8217;un <em>commit</em> qui ne porte pas de signature GPG de confiance, avec la commande <code class="literal">--verify-signatures</code>.</p>
<p>Si vous utilisez cette option lors de la fusion d&#8217;une branche et qu&#8217;elle contient des <em>commits</em> qui ne sont pas signés et valides, la fusion échouera.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge --verify-signatures non-verify
fatal: La validation ab06180 n&#39;a pas de signature GPG.</code></pre>
</figure>
<p>Si la fusion ne contient que des <em>commits</em> signés valides, la commande de fusion vous montrera toutes les signatures vérifiées et démarrera la fusion proprement dite.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge --verify-signatures signed-branch
La validation 13ad65e a une signature GPG correcte par Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;
Mise à jour 5c3386c..13ad65e
Avance rapide
 README | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</figure>
<p>Vous pouvez aussi utiliser l&#8217;option <code class="literal">-S</code> avec la commande <code class="literal">git merge</code> elle-même pour signer le <em>commit</em> de fusion.
L&#8217;exemple suivant vérifie que tous les <em>commits</em> dans la branche à fusionner sont signés et de plus signe le <em>commit</em> de fusion résultant.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge --verify-signatures -S  signed-branch
Commit 13ad65e a une signature GPG correcte par Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;

You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;
2048-bit RSA key, ID 0A46826A, created 2014-06-04

Merge made by the &#39;recursive&#39; strategy.
 README | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</figure>
</section>
<section class="sect2" title="Tout le monde doit signer">
<h3 id="_tout_le_monde_doit_signer">Tout le monde doit signer</h3>
<p>Signer les étiquettes et les <em>commits</em>, c&#8217;est bien mais si vous décidez d&#8217;utiliser cette fonction dans votre méthode de travail, il faudra s&#8217;assurer que tous les membres de votre équipe comprennent comment s&#8217;y prendre.
Sinon, vous allez devoir passer du temps à aider les personnes à réécrire leurs <em>commits</em> en version signée.
Assurez-vous de bien comprendre GPG et les bénéfices de la signature avant d&#8217;adopter cette pratique dans vos méthodes de travail.</p>
</section>
</section>
<section class="sect1" title="Recherche">
<h2 id="s_searching">Recherche</h2>
<p>Quelle que soit la taille de votre code, vous avez souvent besoin de chercher où une fonction est appelée ou définie, ou de retrouver l&#8217;historique d&#8217;une méthode.
Git fournit quelques outils permettant rapidement de rechercher dans le code et les <em>commits</em> stockés dans votre base de données.
Nous allons en détailler quelques uns.</p>
<section class="sect2" title="Git grep">
<h3 id="s_git_grep">Git grep</h3>
<p>Git est livré avec une commande appelée <code class="literal">grep</code> qui permet de rechercher facilement une chaîne de caractères ou une expression régulière dans une arborescence validée ou dans le répertoire de travail.
Pour tous les exemples qui suivent, nous allons utiliser le dépôt de Git lui-même.</p>
<p>Par défaut, <code class="literal">git grep</code> recherche dans le répertoire de travail.
Vous pouvez passer l&#8217;option <code class="literal">-n</code> pour afficher les numéros des lignes des correspondances.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep -n gmtime_r
<span style="font-weight: bold">compat/gmtime.c:3:#</span>undef gmtime_r
compat/gmtime.c:8:      return git_gmtime_r(timep, &amp;result);
compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)
compat/gmtime.c:16:     ret = gmtime_r(timep, result);
compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm *result)
compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm *result);
date.c:429:             if (gmtime_r(&amp;now, &amp;now_tm))
date.c:492:             if (gmtime_r(&amp;time, tm)) {
git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm *);
<span style="font-weight: bold">git-compat-util.h:723:#</span>define gmtime_r git_gmtime_r</code></pre>
</figure>
<p>La commande <code class="literal">grep</code> peut être enrichie grâce à un certain nombre d&#8217;options intéressantes.</p>
<p>Par exemple, pour l&#8217;appel précédent, vous pouvez indiquer à Git de résumer le résultat en ne montrant que les fichiers et le nombre de correspondances au moyen de l&#8217;option <code class="literal">--count</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep --count gmtime_r
compat/gmtime.c:4
compat/mingw.c:1
compat/mingw.h:1
date.c:2
git-compat-util.h:2</code></pre>
</figure>
<p>Si vous souhaitez voir dans quelle méthode ou fonction la correspondance a été trouvée, vous pouvez passer l&#8217;option <code class="literal">-p</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep -p gmtime_r *.c
date.c=static int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)
date.c:         if (gmtime_r(&amp;now, &amp;now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)
date.c:         if (gmtime_r(&amp;time, tm)) {</code></pre>
</figure>
<p>Ici, on peut voir que <code class="literal">gmtime_r</code> est appelée dans les fonctions <code class="literal">match_multi_number</code> et <code class="literal">match_digit</code> du fichier <code class="literal">date.c</code>.</p>
<p>Vous pouvez aussi rechercher des combinaisons plus complexes de chaînes de caractères avec l&#8217;option <code class="literal">--and</code> qui force plusieurs correspondances sur la même ligne.
Par exemple, recherchons toutes les lignes qui définissent une constante qui contient au choix « LINK » ou « BUF_MAX » dans la base de code de Git avant la version 1.8.0.</p>
<p>Ici, nous allons utiliser les options <code class="literal">--break</code> et <code class="literal">--heading</code> qui aident à découper le résultat dans un format plus digeste.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep --break --heading <span style="font-weight: bold; font-style: italic">\</span>
    -n -e <span style="font-style: italic">&#39;#define&#39;</span> --and <span style="font-weight: bold; font-style: italic">\(</span> -e LINK -e BUF_MAX <span style="font-weight: bold; font-style: italic">\)</span> v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u&lt;&lt;20)

v1.8.0:cache.h
73:#define S_IFGITLINK  0160000
74:#define S_ISGITLINK(m)       (((m) &amp; S_IFMT) == S_IFGITLINK)

v1.8.0:environment.c
54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS

v1.8.0:strbuf.c
326:#define STRBUF_MAXLINK (2*PATH_MAX)

v1.8.0:symlinks.c
53:#define FL_SYMLINK  (1 &lt;&lt; 2)

v1.8.0:zlib.c
<span style="font-weight: bold">30:/* #</span>define ZLIB_BUF_MAX ((uInt)-1) */
31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</code></pre>
</figure>
<p>La commande <code class="literal">git grep</code> a quelques avantages sur les commandes de recherche normales telles que <code class="literal">grep</code> et <code class="literal">ack</code>.
Le premier est qu&#8217;elle est vraiment rapide, le second est qu&#8217;elle vous permet de rechercher dans n&#8217;importe quelle arborescence Git, pas seulement la copie de travail.
Comme nous l&#8217;avons vu dans l&#8217;exemple ci-dessus, nous avons cherché des termes dans une version ancienne du code source de Git, pas dans la dernière version extraite.</p>
</section>
<section class="sect2" title="Recherche dans le journal Git">
<h3 id="_recherche_dans_le_journal_git">Recherche dans le journal Git</h3>
<p>Peut-être ne cherchez-vous pas <strong>où</strong> un terme apparaît, mais plutôt <strong>quand</strong> il existait ou fut introduit.
La commande <code class="literal">git log</code> comprend un certain nombre d&#8217;outils puissants pour trouver des <em>commits</em> spécifiques par le contenu de leurs messages ou le contenu des diffs qu&#8217;ils introduisent.</p>
<p>Si vous voulez trouver par exemple quand la constante <code class="literal">ZLIB_BUF_MAX</code> a été initialement introduite, nous pouvons indiquez à Git de ne montrer que les <em>commits</em> qui soit ajoutent soit retirent la chaîne avec l&#8217;option <code class="literal">-S</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -SZLIB_BUF_MAX --oneline
e01503b zlib: allow feeding more than 4GB in one go
ef49a7a zlib: zlib can only process 4GB at a time</code></pre>
</figure>
<p>Si nous regardons la diff de ces <em>commits</em>, nous pouvons voir que dans <code class="literal">ef49a7a</code>, la constante a été introduite et qu&#8217;elle a été modifiée dans <code class="literal">e01503b</code>.</p>
<p>Si vous devez être plus spécifique, vous pouvez fournir une expression régulière à rechercher avec l&#8217;option  <code class="literal">-G</code>.</p>
<section class="sect3" title="Recherche des évolutions d&#8217;une ligne">
<h4 id="_recherche_des_évolutions_d_une_ligne">Recherche des évolutions d&#8217;une ligne</h4>
<p>Un autre outil avancé de recherche dans l&#8217;historique qui peut s&#8217;avérer très utile est la recherche de l&#8217;historique d&#8217;une ligne.
C&#8217;est une addition assez récente et peu connue, mais elle peut être très efficace.
On l&#8217;active avec l&#8217;option <code class="literal">-L</code> de <code class="literal">git log</code> et elle vous montre l&#8217;historique d&#8217;une fonction ou d&#8217;une ligne dans votre base de code.</p>
<p>Par exemple, si nous souhaitions voir toutes les modifications réalisées sur la fonction <code class="literal">git_deflate_bound</code> dans le fichier <code class="literal">zlib.c</code>, nous pourrions lancer <code class="literal">git log -L :git_deflate_bound:zlib.c</code>.
Cette commande va essayer de déterminer les limites de cette fonction et de rechercher dans l&#8217;historique chaque modification réalisée sur la fonction comme une série de patchs jusqu&#8217;au moment de sa création.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -L :git_deflate_bound:zlib.c
commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Fri Jun 10 11:52:15 2011 -0700

    zlib: zlib can only process 4GB at a time

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -85,5 +130,5 @@
-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)
 {
-       return deflateBound(strm, size);
+       return deflateBound(&amp;strm-&gt;z, size);
 }


commit 225a6f1068f71723a910e8565db4e252b3ca21fa
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Fri Jun 10 11:18:17 2011 -0700

    zlib: wrap deflateBound() too

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -81,0 +85,5 @@
+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+{
+       return deflateBound(strm, size);
+}
+</code></pre>
</figure>
<p>Si Git ne peut pas déterminer comment trouver la fonction ou la méthode dans votre langage de programmation, vous pouvez aussi fournir une regex.
Par exemple, cela aurait donné le même résultat avec <code class="literal">git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c</code>.
Vous auriez pu aussi spécifier un intervalle de lignes ou un numéro de ligne et vous auriez obtenu le même type de résultat.</p>
</section>
</section>
</section>
<section class="sect1" title="Réécrire l&#8217;historique">
<h2 id="s_rewriting_history">Réécrire l&#8217;historique</h2>
<p>Bien souvent, lorsque vous travaillez avec Git, vous souhaitez modifier votre historique de validation pour une raison quelconque.
Une des choses merveilleuses de Git est qu&#8217;il vous permet de prendre des décisions le plus tard possible.
Vous pouvez décider quels fichiers vont dans quel <em>commit</em> avant que vous ne validiez l&#8217;index, vous pouvez décider que vous ne voulez pas encore montrer que vous travaillez sur quelque chose avec les remises, et vous pouvez réécrire les <em>commits</em> déjà sauvegardés pour qu&#8217;ils ressemblent à quelque chose d&#8217;autre.
Cela peut signifier changer l&#8217;ordre des <em>commits</em>, modifier les messages ou modifier les fichiers appartenant au <em>commit</em>, rassembler ou scinder des <em>commits</em>, ou supprimer complètement des <em>commits</em> ; tout ceci avant de les partager avec les autres.</p>
<p>Dans cette section, nous expliquerons comment accomplir ces tâches très utiles pour que vous puissiez remodeler votre historique de validation comme vous le souhaitez avant de le partager avec autrui.</p>
<section class="sect2" title="Modifier la dernière validation">
<h3 id="s_git_amend">Modifier la dernière validation</h3>
<p>Modifier votre dernière validation est probablement la réécriture de l&#8217;historique que vous allez utiliser le plus souvent.
Vous voudrez souvent faire deux choses basiques à votre dernier <em>commit</em> : modifier le message de validation ou changer le contenu que vous avez enregistré en ajoutant, modifiant ou supprimant des fichiers.</p>
<p>Si vous voulez seulement modifier votre dernier message de validation, c&#8217;est vraiment simple :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>Cela ouvre votre éditeur de texte contenant votre dernier message, prêt à être modifié.
Lorsque vous sauvegardez et fermez l&#8217;éditeur, Git enregistre la nouvelle validation contenant le message et en fait votre dernier <em>commit</em>.</p>
<p>Si vous voulez modifier le contenu de votre validation en ajoutant ou modifiant des fichiers, sûrement parce que vous avez oublié d&#8217;ajouter les fichiers nouvellement créés quand vous avez validé la première fois, la procédure fonctionne grosso-modo de la même manière.
Vous indexez les modifications que vous voulez en exécutant <code class="literal">git add</code> ou <code class="literal">git rm</code>, et le prochain <code class="literal">git commit --amend</code> prendra votre index courant et en fera le contenu de votre nouvelle validation.</p>
<p>Vous devez être prudent avec cette technique car votre modification modifie également le SHA-1 du <em>commit</em>.
Cela ressemble à un tout petit <code class="literal">rebase</code>.
Ne modifiez pas votre dernière validation si vous l&#8217;avez déjà publiée !</p>
</section>
<section class="sect2" title="Modifier plusieurs messages de validation">
<h3 id="s_changing_multiple">Modifier plusieurs messages de validation</h3>
<p>Pour modifier une validation qui est plus loin dans votre historique, vous devez utiliser des outils plus complexes.
Git ne contient pas d&#8217;outil de modification d&#8217;historique, mais vous pouvez utiliser l&#8217;outil <code class="literal">rebase</code> pour rebaser une suite de <em>commits</em> depuis la branche HEAD plutôt que de les déplacer vers une autre branche.
Avec l&#8217;outil <code class="literal">rebase</code> interactif, vous pouvez vous arrêter après chaque <em>commit</em> que vous voulez modifier et changer le message, ajouter des fichiers ou quoi que ce soit que vous voulez.
Vous pouvez exécuter <code class="literal">rebase</code> interactivement en ajoutant l&#8217;option <code class="literal">-i</code> à <code class="literal">git rebase</code>.
Vous devez indiquer jusqu&#8217;à quand remonter dans votre historique en donnant à la commande le <em>commit</em> sur lequel vous voulez vous rebaser.</p>
<p>Par exemple, si vous voulez modifier les 3 derniers messages de validation ou n&#8217;importe lequel des messages dans ce groupe, vous fournissez à <code class="literal">git rebase -i</code> le parent du dernier <em>commit</em> que vous voulez éditer, qui est <code class="literal">HEAD~2^</code> or <code class="literal">HEAD~3</code>.
Il peut être plus facile de se souvenir de <code class="literal">~3</code>, car vous essayez de modifier les 3 derniers <em>commits</em>, mais gardez à l&#8217;esprit que vous désignez le 4e, le parent du dernier <em>commit</em> que vous voulez modifier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase -i HEAD~3</code></pre>
</figure>
<p>Souvenez-vous également que ceci est une commande de rebasage, chaque <em>commit</em> inclus dans l&#8217;intervalle <code class="literal">HEAD~3..HEAD</code> sera réécrit, que vous changiez le message ou non.
N&#8217;incluez pas, dans cette commande, de <em>commit</em> que vous avez déjà poussé sur un serveur central.
Le faire entraînera la confusion chez les autres développeurs en leur fournissant une version altérée des mêmes modifications.</p>
<p>Exécuter cette commande vous donne la liste des validations dans votre éditeur de texte, ce qui ressemble à :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

<span style="font-weight: bold">#</span> Rebase 710f0f8..a5f4a0d onto 710f0f8
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Commands:
<span style="font-weight: bold">#</span>  p, pick = use commit
<span style="font-weight: bold">#</span>  r, reword = use commit, but edit the commit message
<span style="font-weight: bold">#</span>  e, edit = use commit, but stop <span style="font-weight: bold">for</span> amending
<span style="font-weight: bold">#</span>  s, squash = use commit, but meld into previous commit
<span style="font-weight: bold">#</span>  f, fixup = like <span style="font-style: italic">&quot;squash&quot;</span>, but discard this commit<span style="border: 1px solid #FF0000">&#39;</span>s log message
<span style="font-weight: bold">#</span>  x, exec = run command (the rest of the line) using shell
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> These lines can be re-ordered; they are executed from top to bottom.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> If you remove a line here THAT COMMIT WILL BE LOST.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> However, <span style="font-weight: bold">if</span> you remove everything, the rebase will be aborted.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Note that empty commits are commented out</code></pre>
</figure>
<p>Il est important de signaler que les <em>commits</em> sont listés dans l&#8217;ordre inverse de celui que vous voyez normalement en utilisant la commande <code class="literal">log</code>.
Si vous exécutez la commande <code class="literal">log</code>, vous verrez quelque chose de ce genre :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span> HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit</code></pre>
</figure>
<p>Remarquez l&#8217;ordre inverse.
Le rebasage interactif va créer un script à exécuter.
Il commencera au <em>commit</em> que vous spécifiez sur la ligne de commande (<code class="literal">HEAD~3</code>) et refera les modifications introduites dans chacun des <em>commits</em> du début à la fin.
Il ordonne donc le plus vieux au début, plutôt que le plus récent, car c&#8217;est celui qu&#8217;il refera en premier.</p>
<p>Vous devez éditer le script afin qu&#8217;il s&#8217;arrête au <em>commit</em> que vous voulez modifier.
Pour cela, remplacer le mot « pick » par le mot « edit » pour chaque <em>commit</em> après lequel vous voulez que le script s&#8217;arrête.
Par exemple, pour modifier uniquement le message du troisième <em>commit</em>, vous modifiez le fichier pour ressembler à :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</figure>
<p>Au moment où vous sauvegardez et quittez l&#8217;éditeur, Git revient au dernier <em>commit</em> de cette liste et vous laisse sur une ligne de commande avec le message suivant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase -i HEAD~3
Stopped at 7482e0d... updated the gemspec to hopefully work better
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue</code></pre>
</figure>
<p>Ces instructions vous disent exactement quoi faire.
Entrez :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>Modifiez le message de <em>commit</em> et quittez l&#8217;éditeur.
Puis exécutez :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase --continue</code></pre>
</figure>
<p>Cette commande appliquera les deux autres <em>commits</em> automatiquement.
Si vous remplacez « pick » en « edit » sur plusieurs lignes, vous pouvez répéter ces étapes pour chaque <em>commit</em> que vous avez marqué pour modification.
Chaque fois, Git s&#8217;arrêtera, vous laissant modifier le <em>commit</em> et continuera lorsque vous aurez fini.</p>
</section>
<section class="sect2" title="Réordonner les commits">
<h3 id="_réordonner_les_em_commits_em">Réordonner les <em>commits</em></h3>
<p>Vous pouvez également utiliser les rebasages interactifs afin de réordonner ou supprimer entièrement des <em>commits</em>.
Si vous voulez supprimer le <em>commit</em> « added cat-file » et modifier l&#8217;ordre dans lequel les deux autres <em>commits</em> se trouvent dans l&#8217;historique, vous pouvez modifier le script de rebasage :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</figure>
<p>afin qu&#8217;il ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit</code></pre>
</figure>
<p>Lorsque vous sauvegardez et quittez l&#8217;éditeur, Git remet votre branche au niveau du parent de ces <em>commits</em>, applique <code class="literal">310154e</code> puis <code class="literal">f7f3f6d</code> et s&#8217;arrête.
Vous venez de modifier l&#8217;ordre de ces <em>commits</em> et de supprimer entièrement le <em>commit</em> « added cat-file ».</p>
</section>
<section class="sect2" title="Écraser un commit">
<h3 id="s_squashing">Écraser un <em>commit</em></h3>
<p>Il est également possible de prendre une série de <em>commits</em> et de les rassembler en un seul avec l&#8217;outil de rebasage interactif.
Le script affiche des instructions utiles dans le message de rebasage :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Commands:
<span style="font-weight: bold">#</span>  p, pick = use commit
<span style="font-weight: bold">#</span>  r, reword = use commit, but edit the commit message
<span style="font-weight: bold">#</span>  e, edit = use commit, but stop <span style="font-weight: bold">for</span> amending
<span style="font-weight: bold">#</span>  s, squash = use commit, but meld into previous commit
<span style="font-weight: bold">#</span>  f, fixup = like <span style="font-style: italic">&quot;squash&quot;</span>, but discard this commit<span style="border: 1px solid #FF0000">&#39;</span>s log message
<span style="font-weight: bold">#</span>  x, exec = run command (the rest of the line) using shell
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> These lines can be re-ordered; they are executed from top to bottom.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> If you remove a line here THAT COMMIT WILL BE LOST.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> However, <span style="font-weight: bold">if</span> you remove everything, the rebase will be aborted.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Note that empty commits are commented out</code></pre>
</figure>
<p>Si, à la place de « <em>pick</em> » ou « <em>edit</em> », vous spécifiez « <em>squash</em> », Git applique cette modification et la modification juste précédente et fusionne les messages de validation.
Donc, si vous voulez faire un seul <em>commit</em> de ces trois validations, vous faites en sorte que le script ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file</code></pre>
</figure>
<p>Lorsque vous sauvegardez et quittez l&#8217;éditeur, Git applique ces trois modifications et vous remontre l&#8217;éditeur contenant maintenant la fusion des 3 messages de validation :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> This is a combination of 3 commits.
<span style="font-weight: bold">#</span> The first commit<span style="border: 1px solid #FF0000">&#39;</span>s message is:
changed my name a bit

<span style="font-weight: bold">#</span> This is the 2nd commit message:

updated README formatting and added blame

<span style="font-weight: bold">#</span> This is the 3rd commit message:

added cat-file</code></pre>
</figure>
<p>Lorsque vous sauvegardez cela, vous obtenez un seul <em>commit</em> amenant les modifications des trois <em>commits</em> précédents.</p>
</section>
<section class="sect2" title="Diviser un commit">
<h3 id="_diviser_un_em_commit_em">Diviser un <em>commit</em></h3>
<p>Pour diviser un <em>commit</em>, il doit être défait, puis partiellement indexé et validé autant de fois que vous voulez pour en finir avec lui.
Par exemple, supposons que vous voulez diviser le <em>commit</em> du milieu dans l&#8217;exemple des trois <em>commits</em> précédents.
Plutôt que « <em>updated README formatting and added blame</em> », vous voulez le diviser en deux <em>commits</em> : « <em>updated README formatting</em> » pour le premier, et « <em>added blame</em> » pour le deuxième.
Vous pouvez le faire avec le script <code class="literal">rebase -i</code> en remplaçant l&#8217;instruction sur le <em>commit</em> que vous voulez diviser en « <em>edit</em> » :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</figure>
<p>Puis, lorsque le script vous laisse accès à la ligne de commande, vous pouvez annuler (<strong>reset</strong>) ce <em>commit</em> et revalider les modifications que vous voulez pour créer plusieurs <em>commits</em>.
En reprenant l&#8217;exemple, lorsque vous sauvegardez et quittez l&#8217;éditeur, Git revient au parent de votre premier <em>commit</em> de votre liste, applique le premier <em>commit</em> (<code class="literal">f7f3f6d</code>), applique le deuxième (<code class="literal">310154e</code>), et vous laisse accès à la console.
Là, vous pouvez faire une réinitialisation mélangée (<strong>mixed reset</strong>) de ce <em>commit</em> avec <code class="literal">git reset HEAD^</code>, qui défait ce <em>commit</em> et laisse les fichiers modifiés non indexés.
Maintenant, vous pouvez indexer et valider les fichiers sur plusieurs validations, et exécuter <code class="literal">git rebase --continue</code> quand vous avez fini :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset HEAD^
<span style="font-weight: bold">$</span> git add README
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;updated README formatting&#39;</span>
<span style="font-weight: bold">$</span> git add lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;added blame&#39;</span>
<span style="font-weight: bold">$</span> git rebase --continue</code></pre>
</figure>
<p>Git applique le dernier <em>commit</em> (<code class="literal">a5f4a0d</code>) de votre script, et votre historique ressemblera alors à :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -4 --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span>
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit</code></pre>
</figure>
<p>Une fois encore, ceci modifie les empreintes SHA-1 de tous les <em>commits</em> dans votre liste, soyez donc sûr qu&#8217;aucun <em>commit</em> de cette liste n&#8217;ait été poussé dans un dépôt partagé.</p>
</section>
<section class="sect2" title="L&#8217;option nucléaire : filter-branch">
<h3 id="_l_option_nucléaire_code_class_literal_filter_branch_code">L&#8217;option nucléaire : <code class="literal">filter-branch</code></h3>
<p>Il existe une autre option de la réécriture d&#8217;historique que vous pouvez utiliser si vous avez besoin de réécrire un grand nombre de <em>commits</em> d&#8217;une manière scriptable ; par exemple, modifier globalement votre adresse mail ou supprimer un fichier de tous les <em>commits</em>.
La commande est <code class="literal">filter-branch</code>, et elle peut réécrire des pans entiers de votre historique, vous ne devriez donc pas l&#8217;utiliser à moins que votre projet ne soit pas encore public ou que personne n&#8217;ait encore travaillé sur les <em>commits</em> que vous allez réécrire.
Cependant, cela peut être très utile.
Vous allez maintenant apprendre quelques usages communs pour vous donner une idée de ses capacités.</p>
<section class="sect3" title="Supprimer un fichier de chaque commit">
<h4 id="s_removing_file_every_commit">Supprimer un fichier de chaque <em>commit</em></h4>
<p>Cela arrive assez fréquemment.
Quelqu&#8217;un a accidentellement validé un énorme fichier binaire avec une commande <code class="literal">git add .</code> irréfléchie, et vous voulez le supprimer partout.
Vous avez peut-être validé un fichier contenant un mot de passe et vous voulez rendre votre projet open source.
<code class="literal">filter-branch</code> est l&#8217;outil que vous voulez probablement utiliser pour nettoyer votre historique entier.
Pour supprimer un fichier nommé « passwords.txt » de tout votre historique, vous pouvez utiliser l&#8217;option <code class="literal">--tree-filter</code> de <code class="literal">filter-branch</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --tree-filter <span style="font-style: italic">&#39;rm -f passwords.txt&#39;</span> HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p>L&#8217;option <code class="literal">--tree-filter</code> exécute la commande spécifiée pour chaque <em>commit</em> et le revalide ensuite.
Dans le cas présent, vous supprimez le fichier nommé « passwords.txt » de chaque contenu, qu&#8217;il existait ou non.
Si vous voulez supprimer tous les fichiers temporaires des éditeurs validés accidentellement, vous pouvez exécuter une commande telle que <code class="literal">git filter-branch --tree-filter "find * -type f -name '*~' -delete" HEAD</code>.</p>
<p>Vous pourrez alors regarder Git réécrire l&#8217;arbre des <em>commits</em> et revalider à chaque fois, pour finir en modifiant la référence de la branche.
C&#8217;est généralement une bonne idée de le faire dans un branche de test puis de faire une réinitialisation forte (<strong>hard-reset</strong>) de votre branche <code class="literal">master</code> si le résultat vous convient.
Pour exécuter <code class="literal">filter-branch</code> sur toutes vos branches, vous pouvez ajouter <code class="literal">--all</code> à la commande.</p>
</section>
<section class="sect3" title="Faire d&#8217;un sous-répertoire la nouvelle racine">
<h4 id="_faire_d_un_sous_répertoire_la_nouvelle_racine">Faire d&#8217;un sous-répertoire la nouvelle racine</h4>
<p>Supposons que vous avez importé votre projet depuis un autre système de gestion de configuration et que vous avez des sous-répertoires qui n&#8217;ont aucun sens (trunk, tags, etc.).
Si vous voulez faire en sorte que le sous-répertoire <code class="literal">trunk</code> soit la nouvelle racine de votre projet pour tous les <em>commits</em>, <code class="literal">filter-branch</code> peut aussi vous aider à le faire :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p>Maintenant votre nouvelle racine est remplacée par le contenu du répertoire <code class="literal">trunk</code>.
De plus, Git supprimera automatiquement les <em>commits</em> qui n&#8217;affectent pas ce sous-répertoire.</p>
</section>
<section class="sect3" title="Modifier globalement l&#8217;adresse mail">
<h4 id="_modifier_globalement_l_adresse_mail">Modifier globalement l&#8217;adresse mail</h4>
<p>Un autre cas habituel est que vous oubliez d&#8217;exécuter <code class="literal">git config</code> pour configurer votre nom et votre adresse mail avant de commencer à travailler, ou vous voulez peut-être rendre un projet du boulot open source et donc changer votre adresse professionnelle pour celle personnelle.
Dans tous les cas, vous pouvez modifier l&#8217;adresse mail dans plusieurs <em>commits</em> avec un script <code class="literal">filter-branch</code>.
Vous devez faire attention de ne changer que votre adresse mail, utilisez donc <code class="literal">--commit-filter</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --commit-filter <span style="border: 1px solid #FF0000">&#39;</span>
        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];
        then
                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;
                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;
                git commit-tree &quot;$@&quot;;
        else
                git commit-tree &quot;$@&quot;;
        fi&#39; HEAD</code></pre>
</figure>
<p>Cela passe sur chaque <em>commit</em> et le réécrit pour avoir votre nouvelle adresse.
Mais puisque les <em>commits</em> contiennent l&#8217;empreinte SHA-1 de leur parent, cette commande modifie tous les <em>commits</em> dans votre historique, pas seulement ceux correspondant à votre adresse mail.</p>
</section>
</section>
</section>
<section class="sect1" title="Reset démystifié">
<h2 id="s_git_reset">Reset démystifié</h2>
<p>Avant d&#8217;aborder des outils plus spécialisés, parlons un instant de <code class="literal">reset</code> et <code class="literal">checkout</code>.
Ces commandes sont deux des plus grandes sources de confusion à leur premier contact.
Elles permettent de faire tant de choses et il semble impossible de les comprendre et les employer correctement.
Pour ceci, nous vous recommandons une simple métaphore.</p>
<section class="sect2" title="Les trois arbres">
<h3 id="_les_trois_arbres">Les trois arbres</h3>
<p>Le moyen le plus simple de penser à <code class="literal">reset</code> et <code class="literal">checkout</code> consiste à représenter Git comme un gestionnaire de contenu de trois arborescences différentes.
Par « arborescence », il faut comprendre « collection de fichiers », pas spécifiquement structure de données.
Il existe quelques cas pour lesquels l&#8217;index ne se comporte pas exactement comme une arborescence, mais pour ce qui nous concerne, c&#8217;est plus simple de l&#8217;imaginer de cette manière pour le moment.</p>
<p>Git, comme système, gère et manipule trois arbres au cours de son opération normale :</p>
<div class="table">
<div class="content">
<table class="table table-framed-topbot table-grid-rows" style="width: 100%">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Arbre</th>
<th>Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>HEAD</p></td>
<td><p>instantané de la dernière validation, prochain parent</p></td>
</tr>
<tr>
<td><p>Index</p></td>
<td><p>instantané proposé de la prochaine validation</p></td>
</tr>
<tr>
<td><p>Répertoire de travail</p></td>
<td><p>bac à sable</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<section class="sect3" title="HEAD">
<h4 id="_head">HEAD</h4>
<p>HEAD est un pointeur sur la référence de la branche actuelle, qui est à son tour un pointeur sur le dernier <em>commit</em> réalisé sur cette branche.
Ceci signifie que HEAD sera le parent du prochain <em>commit</em> à créer.
C&#8217;est généralement plus simple de penser HEAD comme l&#8217;instantané de <strong>votre dernière validation</strong>.</p>
<p>En fait, c&#8217;est assez simple de visualiser ce à quoi cet instantané ressemble.
Voici un exemple de liste du répertoire et des sommes de contrôle SHA-1 pour chaque fichier de l&#8217;instantané HEAD :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

<span style="font-weight: bold">$</span> git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib</code></pre>
</figure>
<p>Les commandes <code class="literal">cat-file</code> et <code class="literal">ls-tree</code> sont des commandes de « plomberie » qui sont utilisées pour des activités de base niveau et ne sont pas réellement utilisées pour le travail quotidien, mais elles nous permettent de voir ce qui se passe ici.</p>
</section>
<section class="sect3" title="L&#8217;index">
<h4 id="s_the_index">L&#8217;index</h4>
<p>L&#8217;index est votre <strong>prochain commit proposé</strong>.
Nous avons aussi fait référence à ce concept comme la « zone de préparation » de Git du fait que c&#8217;est ce que Git examine lorsque vous lancez <code class="literal">git commit</code>.</p>
<p>Git remplit cet index avec une liste de tous les contenus des fichiers qui ont été extraits dans votre copie de travail et ce qu&#8217;ils contenaient quand ils ont été originellement extraits.
Vous pouvez alors remplacer certains de ces fichiers par de nouvelles versions de ces mêmes fichiers, puis <code class="literal">git commit</code> convertit cela en arborescence du nouveau <em>commit</em>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb</code></pre>
</figure>
<p>Encore une fois, nous utilisons ici <code class="literal">ls-files</code> qui est plus une commande de coulisses qui vous montre l&#8217;état actuel de votre index.</p>
<p>L&#8217;index n&#8217;est pas techniquement parlant une structure arborescente ‑ c&#8217;est en fait un manifeste aplati ‑ mais pour nos besoins, c&#8217;est suffisamment proche.</p>
</section>
<section class="sect3" title="Le répertoire de travail">
<h4 id="_le_répertoire_de_travail">Le répertoire de travail</h4>
<p>Finalement, vous avez votre répertoire de travail.
Les deux autres arbres stockent leur contenu de manière efficace mais peu pratique dans le répertoire <code class="literal">.git</code>.
Le répertoire de travail les dépaquette comme fichiers réels, ce qui rend tout de même plus facile leur modification.
Il faut penser à la copie de travail comme un <strong>bac à sable</strong> où vous pouvez essayer vos modifications avant de les transférer dans votre index puis le valider dans votre historique.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files</code></pre>
</figure>
</section>
</section>
<section class="sect2" title="Le flux de travail">
<h3 id="_le_flux_de_travail">Le flux de travail</h3>
<p>L&#8217;objet principal de Git est d&#8217;enregistrer des instantanés de votre projet comme des états successifs évolutifs en manipulant ces trois arbres.</p>
<figure class="image">
<div class="content">
<img src="images/reset-workflow.png" alt="reset workflow"/>
</div>
</figure>
<p>Visualisons ce processus : supposons que vous allez dans un nouveau répertoire contenant un fichier unique.
Nous appellerons ceci <strong>v1</strong> du fichier et nous le marquerons en bleu.
Maintenant, nous allons lancer <code class="literal">git init</code>, ce qui va créer le dépôt Git avec une référence HEAD qui pointe sur une branche à naître (<code class="literal">master</code> n&#8217;existe pas encore).</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex1.png" alt="reset ex1"/>
</div>
</figure>
<p>À ce point, seul le répertoire de travail contient quelque chose.</p>
<p>Maintenant, nous souhaitons valider ce fichier, donc nous utilisons <code class="literal">git add</code> qui prend le contenu du répertoire de travail et le copie dans l&#8217;index.</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex2.png" alt="reset ex2"/>
</div>
</figure>
<p>Ensuite, nous lançons <code class="literal">git commit</code>, ce qui prend le contenu de l&#8217;index et le sauve comme un instantané permanent, crée un objet commit qui pointe sur cet instantané et met à jour <code class="literal">master</code> pour pointer sur ce <em>commit</em>.</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex3.png" alt="reset ex3"/>
</div>
</figure>
<p>Si nous lançons <code class="literal">git status</code>, nous ne verrons aucune modification parce que les trois arborescences sont identiques.</p>
<p>Maintenant, nous voulons faire des modifications sur ce fichier et le valider.
Nous suivons le même processus ; en premier nous changeons le fichier dans notre copie de travail.
Appelons cette version du fichier <strong>v2</strong> et marquons-le en rouge.</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex4.png" alt="reset ex4"/>
</div>
</figure>
<p>Si nous lançons <code class="literal">git status</code> maintenant, nous verrons le fichier en rouge comme « Modifications qui ne seront pas validées » car cette entrée est différente entre l&#8217;index et le répertoire de travail.
Ensuite, nous lançons <code class="literal">git add</code> dessus pour le monter dans notre index.</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex5.png" alt="reset ex5"/>
</div>
</figure>
<p>À ce point, si nous lançons <code class="literal">git status</code>, nous verrons le fichier en vert sous « Modifications qui seront validées » parce que l&#8217;index et HEAD diffèrent, c&#8217;est-à-dire que notre prochain <em>commit</em> proposé est différent de notre dernier <em>commit</em>.
Finalement, nous lançons <code class="literal">git commit</code> pour finaliser la validation.</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex6.png" alt="reset ex6"/>
</div>
</figure>
<p>Maintenant, <code class="literal">git status</code> n&#8217;indique plus rien, car les trois arborescences sont à nouveau identiques.</p>
<p>Les basculements de branches ou les clonages déroulent le même processus.
Quand vous extrayez une branche, cela change <strong>HEAD</strong> pour pointer sur la nouvelle référence de branche, popule votre <strong>index</strong> avec l&#8217;instantané de ce <em>commit</em>, puis copie le contenu de l&#8217;index dans votre <strong>répertoire de travail</strong>.</p>
</section>
<section class="sect2" title="Le rôle de reset">
<h3 id="_le_rôle_de_reset">Le rôle de reset</h3>
<p>La commande <code class="literal">reset</code> est plus compréhensible dans ce contexte.</p>
<p>Pour l&#8217;objectif des exemples à suivre, supposons que nous avons modifié <code class="literal">file.txt</code> à nouveau et validé une troisième fois.
Donc maintenant, notre historique ressemble à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/reset-start.png" alt="reset start"/>
</div>
</figure>
<p>Détaillons maintenant ce que <code class="literal">reset</code> fait lorsque vous l&#8217;appelez.
Il manipule directement les trois arborescences d&#8217;une manière simple et prédictible.
Il réalise jusqu&#8217;à trois opérations basiques.</p>
<section class="sect3" title="Étape 1: déplacer HEAD">
<h4 id="_étape_1_déplacer_head">Étape 1: déplacer HEAD</h4>
<p>La première chose que <code class="literal">reset</code> va faire consiste à déplacer ce qui est pointé par HEAD.
Ce n&#8217;est pas la même chose que changer HEAD lui-même (ce que fait <code class="literal">checkout</code>).
<code class="literal">reset</code> déplace la branche que HEAD pointe.
Ceci signifie que si HEAD est pointé sur la branche <code class="literal">master</code> (par exemple, si vous êtes sur la branche <code class="literal">master</code>), lancer <code class="literal">git reset 9e5e6a4</code> va commencer par faire pointer <code class="literal">master</code> sur <code class="literal">9e5e6a4</code>.</p>
<figure class="image">
<div class="content">
<img src="images/reset-soft.png" alt="reset soft"/>
</div>
</figure>
<p>Quelle que soit la forme du <code class="literal">reset</code> que vous invoquez pour un <em>commit</em>, ce sera toujours la première chose qu&#8217;il tentera de faire.
Avec <code class="literal">reset --soft</code>, il n&#8217;ira pas plus loin.</p>
<p>Maintenant, arrêtez-vous une seconde et regardez le diagramme ci-dessus pour comprendre ce qu&#8217;il s&#8217;est passé : en essence, il a défait ce que la dernière commande <code class="literal">git commit</code> a créé.
Quand vous lancez <code class="literal">git commit</code>, Git crée un nouvel objet <em>commit</em> et déplace la branche pointée par HEAD dessus.
Quand vous faites un <code class="literal">reset</code> sur <code class="literal">HEAD~</code> (le parent de <code class="literal">HEAD</code>), vous replacez la branche où elle était, sans changer ni l&#8217;index ni la copie de travail.
Vous pourriez maintenant mettre à jour l&#8217;index et relancer <code class="literal">git commit</code> pour accomplir ce que <code class="literal">git commit --amend</code> aurait fait (voir <a id="xref-s_git_amend" href="#s_git_amend" class="xref">Modifier la dernière validation</a>).</p>
</section>
<section class="sect3" title="Étape 2 : Mise à jour de l&#8217;index (--mixed)">
<h4 id="_étape_2_mise_à_jour_de_l_index_mixed">Étape 2 : Mise à jour de l&#8217;index (--mixed)</h4>
<p>Notez que si vous lancez <code class="literal">git status</code> maintenant, vous verrez en vert la différence entre l&#8217;index et le nouveau HEAD.</p>
<p>La chose suivante que <code class="literal">reset</code> réalise est de mettre à jour l&#8217;index avec le contenu de l&#8217;instantané pointé par HEAD.</p>
<figure class="image">
<div class="content">
<img src="images/reset-mixed.png" alt="reset mixed"/>
</div>
</figure>
<p>Si vous spécifiez l&#8217;option <code class="literal">--mixed</code>, <code class="literal">reset</code> s&#8217;arrêtera à cette étape.
C&#8217;est aussi le comportement par défaut, donc si vous ne spécifiez aucune option (juste <code class="literal">git reset HEAD~</code> dans notre cas), c&#8217;est ici que la commande s&#8217;arrêtera.</p>
<p>Maintenant arrêtez-vous encore une seconde et regardez le diagramme ci-dessus pour comprendre ce qui s&#8217;est passé : il a toujours défait la dernière validation, mais il a aussi tout <em>désindéxé</em>.
Vous êtes revenu à l&#8217;état précédant vos commandes <code class="literal">git add</code> et <code class="literal">git commit</code>.</p>
</section>
<section class="sect3" title="Étape 3: Mise à jour de la copie de travail (--hard)">
<h4 id="_étape_3_mise_à_jour_de_la_copie_de_travail_hard">Étape 3: Mise à jour de la copie de travail (--hard)</h4>
<p>La troisième chose que <code class="literal">reset</code> va faire est de faire correspondre la copie de travail avec l&#8217;index.
Si vous utilisez l&#8217;option <code class="literal">--hard</code>, il continuera avec cette étape.</p>
<figure class="image">
<div class="content">
<img src="images/reset-hard.png" alt="reset hard"/>
</div>
</figure>
<p>Donc réfléchissons à ce qui vient d&#8217;arriver.
Vous avez défait la dernière validation, les commandes <code class="literal">git add</code> et <code class="literal">git commit</code> <strong>ainsi que</strong> tout le travail que vous avez réalisé dans le répertoire de travail.</p>
<p>Il est important de noter que cette option (<code class="literal">--hard</code>) est le seul moyen de rendre la commande <code class="literal">reset</code> dangereuse et est un des très rares cas où Git va réellement détruire de la donnée.
Toute autre invocation de <code class="literal">reset</code> peut être défaite, mais l&#8217;option <code class="literal">--hard</code> ne le permet pas, car elle force l&#8217;écrasement des fichiers dans le répertoire de travail.
Dans ce cas particulier, nous avons toujours la version <strong>v3</strong> du fichier dans un <em>commit</em> dans notre base de donnée Git, et nous pourrions la récupérer en parcourant notre <code class="literal">reflog</code>, mais si nous ne l&#8217;avions pas validé, Git aurait tout de même écrasé les fichiers et rien n&#8217;aurait pu être récupéré.</p>
</section>
<section class="sect3" title="Récapitulatif">
<h4 id="_récapitulatif">Récapitulatif</h4>
<p>La commande <code class="literal">reset</code> remplace ces trois arbres dans un ordre spécifique, s&#8217;arrêtant lorsque vous lui indiquez :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Déplace la branche pointée par HEAD <em>(s&#8217;arrête ici si <code class="literal">--soft</code>)</em></span>
</li>
<li>
<span class="principal">Fait ressembler l&#8217;index à HEAD <em>(s&#8217;arrête ici à moins que <code class="literal">--hard</code>)</em></span>
</li>
<li>
<span class="principal">Fait ressembler le répertoire de travail à l&#8217;index.</span>
</li>
</ol>
</div>
</section>
</section>
<section class="sect2" title="Reset avec un chemin">
<h3 id="_reset_avec_un_chemin">Reset avec un chemin</h3>
<p>Tout cela couvre le comportement de <code class="literal">reset</code> dans sa forme de base, mais vous pouvez aussi lui fournir un chemin sur lequel agir.
Si vous spécifiez un chemin, <code class="literal">reset</code> sautera la première étape et limitera la suite de ses actions à un fichier spécifique ou à un ensemble de fichiers.
Cela fait sens ; en fait, HEAD n&#8217;est rien de plus qu&#8217;un pointeur et vous ne pouvez pas pointer sur une partie d&#8217;un <em>commit</em> et une partie d&#8217;un autre.
Mais l&#8217;index et le répertoire de travail <em>peuvent</em> être partiellement mis à jour, donc <code class="literal">reset</code> continue avec les étapes 2 et 3.</p>
<p>Donc, supposons que vous lancez <code class="literal">git reset file.txt</code>.
Cette forme (puisque vous n&#8217;avez pas spécifié un SHA-1 de commit ni de branche, et que vous n&#8217;avez pas non plus spécifié <code class="literal">--soft</code> ou <code class="literal">--hard</code>) est un raccourcis pour <code class="literal">git reset --mixed HEAD file.txt</code>, qui va :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">déplacer la branche pointée par HEAD <em>(sauté)</em></span>
</li>
<li>
<span class="principal">faire ressembler l&#8217;index à HEAD <em>(s&#8217;arrête ici)</em></span>
</li>
</ol>
</div>
<p>Donc, en substance, il ne fait que copier <code class="literal">file.txt</code> de HEAD vers index.</p>
<figure class="image">
<div class="content">
<img src="images/reset-path1.png" alt="reset path1"/>
</div>
</figure>
<p>Ceci a l&#8217;effet pratique de <em>désindexer</em> le fichier.
Si on regarde cette commande dans le diagramme et qu&#8217;on pense à ce que <code class="literal">git add</code> fait, ce sont des opposés exacts.</p>
<figure class="image">
<div class="content">
<img src="images/reset-path2.png" alt="reset path2"/>
</div>
</figure>
<p>C&#8217;est pourquoi le résultat de la commande <code class="literal">git status</code> suggère que vous lanciez cette commande pour désindexer le fichier (voir <a id="xref--ch02-git-basics--s_unstaging" href="ch02-git-basics.xhtml#s_unstaging" class="xref">Désindexer un fichier déjà indexé</a> pour plus de détail).</p>
<p>Nous pourrions tout aussi bien ne pas laisser Git considérer que nous voulions dire « tirer les données depuis HEAD » en spécifiant un <em>commit</em> spécifique d&#8217;où tirer ce fichier.
Nous lancerions juste quelque chose comme <code class="literal">git reset eb43bf file.txt</code>.</p>
<figure class="image">
<div class="content">
<img src="images/reset-path3.png" alt="reset path3"/>
</div>
</figure>
<p>Ceci fait effectivement la même chose que si nous remettions le contenu du fichier à la <strong>v1</strong> dans le répertoire de travail, lancions <code class="literal">git add</code> dessus, puis le ramenions à nouveau à la <strong>v3</strong> (sans forcément passer par toutes ces étapes).
Si nous lançons <code class="literal">git commit</code> maintenant, il enregistrera la modification qui remet le fichier à la version <strong>v1</strong>, même si nous ne l&#8217;avons jamais eu à nouveau dans notre répertoire de travail.</p>
<p>Il est intéressant de noter que comme <code class="literal">git add</code>, la commande <code class="literal">reset</code> accepte une option <code class="literal">--patch</code> pour désindexer le contenu section par section.
Vous pouvez donc sélectivement désindexer ou ramener du contenu.</p>
</section>
<section class="sect2" title="Écraser les commits">
<h3 id="_écraser_les_em_commits_em">Écraser les <em>commits</em></h3>
<p>Voyons comment faire quelque chose d&#8217;intéressant avec ce tout nouveau pouvoir - écrasons des <em>commits</em>.</p>
<p>Supposons que vous avez une série de <em>commits</em> contenant des messages tels que « oups », « en chantier » ou « ajout d&#8217;un fichier manquant ».
Vous pouvez utiliser <code class="literal">reset</code> pour les écraser tous rapidement et facilement en une seule validation qui vous donne l&#8217;air vraiment intelligent (<a id="xref-s_squashing" href="#s_squashing" class="xref">Écraser un <em>commit</em></a> explique un autre moyen de faire pareil, mais dans cet exemple, c&#8217;est plus simple de faire un <code class="literal">reset</code>).</p>
<p>Disons que vous avez un projet où le premier <em>commit</em> contient un fichier, le second <em>commit</em> a ajouté un nouveau fichier et a modifié le premier, et le troisième a remodifié le premier fichier.
Le second <em>commit</em> était encore en chantier et vous souhaitez le faire disparaître.</p>
<figure class="image">
<div class="content">
<img src="images/reset-squash-r1.png" alt="reset squash r1"/>
</div>
</figure>
<p>Vous pouvez lancer <code class="literal">git reset --soft HEAD~2</code> pour ramener la branche de HEAD sur l&#8217;ancien <em>commit</em> (le premier <em>commit</em> que vous souhaitez garder) :</p>
<figure class="image">
<div class="content">
<img src="images/reset-squash-r2.png" alt="reset squash r2"/>
</div>
</figure>
<p>Ensuite, relancez simplement <code class="literal">git commit</code> :</p>
<figure class="image">
<div class="content">
<img src="images/reset-squash-r3.png" alt="reset squash r3"/>
</div>
</figure>
<p>Maintenant vous pouvez voir que votre historique accessible, l&#8217;historique que vous pousseriez, ressemble à présent à un premier <em>commit</em> avec le fichier <code class="literal">file-a.txt</code> v1, puis un second qui modifie à la fois <code class="literal">file-a.txt</code> à la version 3 et ajoute <code class="literal">file-b.txt</code>.
Le <em>commit</em> avec la version v2 du fichier ne fait plus partie de l&#8217;historique.</p>
</section>
<section class="sect2" title="Et checkout">
<h3 id="_et_checkout">Et checkout</h3>
<p>Finalement, vous pourriez vous demander quelle différence il y a entre <code class="literal">checkout</code> et <code class="literal">reset</code>.
Comme <code class="literal">reset</code>, <code class="literal">checkout</code> manipule les trois arborescences et se comporte généralement différemment selon que vous indiquez un chemin vers un fichier ou non.</p>
<section class="sect3" title="Sans chemin">
<h4 id="_sans_chemin">Sans chemin</h4>
<p>Lancer <code class="literal">git checkout [branche]</code> est assez similaire à lancer <code class="literal">git reset --hard [branche]</code> en ce qu&#8217;il met à jour les trois arborescences pour qu&#8217;elles ressemblent à <code class="literal">[branche]</code>, mais avec deux différences majeures.</p>
<p>Premièrement, à la différence de <code class="literal">reset --hard</code>, <code class="literal">checkout</code> préserve le répertoire de travail ; il s&#8217;assure de ne pas casser des fichiers qui ont changé.
En fait, il est même un peu plus intelligent que ça – il essaie de faire une fusion simple dans le répertoire de travail, de façon que tous les fichiers <strong>non modifiés</strong> soient mis à jour.
<code class="literal">reset --hard</code>, par contre, va simplement tout remplacer unilatéralement sans rien vérifier.</p>
<p>La seconde différence majeure concerne sa manière de mettre à jour HEAD.
Là où <code class="literal">reset</code> va déplacer la branche pointée par HEAD, <code class="literal">checkout</code> va déplacer HEAD lui-même pour qu&#8217;il pointe sur une autre branche.</p>
<p>Par exemple, supposons que nous avons des branches <code class="literal">master</code> et <code class="literal">develop</code> qui pointent sur des <em>commits</em> différents et que nous sommes actuellement sur <code class="literal">develop</code> (donc HEAD pointe dessus).
Si nous lançons <code class="literal">git reset master</code>, <code class="literal">develop</code> lui-même pointera sur le même <em>commit</em> que <code class="literal">master</code>.
Si nous lançons plutôt <code class="literal">git checkout master</code>, <code class="literal">develop</code> ne va pas bouger, seul HEAD va changer.
HEAD pointera alors sur <code class="literal">master</code>.</p>
<p>Donc, dans les deux cas, nous déplaçons HEAD pour pointer sur le commit A, mais la manière diffère beaucoup.
<code class="literal">reset</code> va déplacer la branche pointée par HEAD, alors que <code class="literal">checkout</code> va déplacer HEAD lui-même.</p>
<figure class="image">
<div class="content">
<img src="images/reset-checkout.png" alt="reset checkout"/>
</div>
</figure>
</section>
<section class="sect3" title="Avec des chemins">
<h4 id="_avec_des_chemins">Avec des chemins</h4>
<p>L&#8217;autre façon de lancer <code class="literal">checkout</code> est avec un chemin de fichier, ce qui, comme <code class="literal">reset</code>, ne déplace pas HEAD.
Cela correspond juste à <code class="literal">git reset [branche] fichier</code> car cela met à jour l&#8217;index avec ce fichier à ce <em>commit</em>, mais en remplaçant le fichier dans le répertoire de travail.
Ce serait exactement comme <code class="literal">git reset --hard [branche] fichier</code> (si <code class="literal">reset</code> le permettait) – cela ne préserve pas le répertoire de travail et ne déplace pas non plus HEAD.</p>
<p>De même que <code class="literal">git reset</code> et <code class="literal">git add</code>, <code class="literal">checkout</code> accepte une option <code class="literal">--patch</code> permettant de réinitialiser sélectivement le contenu d&#8217;un fichier section par section.</p>
</section>
</section>
<section class="sect2" title="Résumé">
<h3 id="_résumé">Résumé</h3>
<p>J&#8217;espère qu&#8217;à présent vous comprenez mieux et vous sentez plus à l&#8217;aise avec la commande <code class="literal">reset</code>, même si vous pouvez vous sentir encore un peu confus sur ce qui la différencie exactement de <code class="literal">checkout</code> et avoir du mal à vous souvenir de toutes les règles de ses différentes invocations.</p>
<p>Voici un aide-mémoire sur ce que chaque commande affecte dans chaque arborescence.
La colonne « HEAD » contient « RÉF » si cette commande déplace la référence (branche) pointée par HEAD, et « HEAD » si elle déplace HEAD lui-même.
Faites particulièrement attention à la colonne « préserve RT ? » (préserve le répertoire de travail) – si elle indique <strong>NON</strong>, réfléchissez à deux fois avant de lancer la commande.</p>
<div class="table">
<div class="content">
<table class="table table-framed-topbot table-grid-rows" style="width: 100%">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th></th>
<th>HEAD</th>
<th>Index</th>
<th>Rép. Travail</th>
<th>préserve RT ?</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><strong>Niveau commit</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><p><code class="literal">reset --soft [commit]</code></p></td>
<td><p>RÉF</p></td>
<td><p>NON</p></td>
<td><p>NON</p></td>
<td><p>OUI</p></td>
</tr>
<tr>
<td><p><code class="literal">reset [commit]</code></p></td>
<td><p>RÉF</p></td>
<td><p>OUI</p></td>
<td><p>NON</p></td>
<td><p>OUI</p></td>
</tr>
<tr>
<td><p><code class="literal">reset --hard [commit]</code></p></td>
<td><p>RÉF</p></td>
<td><p>OUI</p></td>
<td><p>OUI</p></td>
<td><p><strong>NON</strong></p></td>
</tr>
<tr>
<td><p><code class="literal">checkout [commit]</code></p></td>
<td><p>HEAD</p></td>
<td><p>OUI</p></td>
<td><p>OUI</p></td>
<td><p>OUI</p></td>
</tr>
<tr>
<td><p><strong>Niveau Fichier</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><p><code class="literal">reset (commit) [fichier]</code></p></td>
<td><p>NON</p></td>
<td><p>OUI</p></td>
<td><p>NON</p></td>
<td><p>OUI</p></td>
</tr>
<tr>
<td><p><code class="literal">checkout (commit) [fichier]</code></p></td>
<td><p>NON</p></td>
<td><p>OUI</p></td>
<td><p>OUI</p></td>
<td><p><strong>NON</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</section>
<section class="sect1" title="Fusion avancée">
<h2 id="s_advanced_merging">Fusion avancée</h2>
<p>La fusion avec Git est généralement plutôt facile.
Puisque Git rend facile la fusion d&#8217;une autre branche plusieurs fois, cela signifie que vous pouvez avoir une branche à très longue durée de vie que vous pouvez mettre à jour au fil de l&#8217;eau, en résolvant souvent les petits conflits plutôt que d&#8217;être surpris par un énorme conflit à la fin de la série.</p>
<p>Cependant, il arrive quelques fois des conflits compliqués.
À la différence d&#8217;autres systèmes de contrôle de version, Git n&#8217;essaie pas d&#8217;être plus intelligent que de mesure pour la résolution des conflits.
La philosophie de Git, c&#8217;est d&#8217;être malin pour déterminer lorsque la fusion est sans ambiguïté mais s&#8217;il y a un conflit, il n&#8217;essaie pas d&#8217;être malin pour le résoudre automatiquement.
De ce fait, si vous attendez trop longtemps pour fusionner deux branches qui divergent rapidement, vous rencontrerez des problèmes.</p>
<p>Dans cette section, nous allons détailler ce que certains de ces problèmes peuvent être et quels outils Git vous offre pour vous aider à gérer ces situations délicates.
Nous traiterons aussi quelques types de fusions différents, non-standard, ainsi que la manière de mémoriser les résolutions que vous avez déjà réalisées.</p>
<section class="sect2" title="Conflits de fusion">
<h3 id="_conflits_de_fusion">Conflits de fusion</h3>
<p>Bien que nous avons couvert les bases de la résolution de conflits dans <a id="xref--ch03-git-branching--s_basic_merge_conflicts" href="ch03-git-branching.xhtml#s_basic_merge_conflicts" class="xref">Conflits de fusions (<em>Merge conflicts</em>)</a>, pour des conflits plus complexes, Git fournit quelques outils pour vous aider à vous y retrouver et à mieux gérer les conflits.</p>
<p>Premièrement, si c&#8217;est seulement possible, essayer de démarrer d&#8217;un répertoire de travail propre avant de commencer une fusion qui pourrait engendrer des conflits.
Si vous avez un travail en cours, validez-le dans une branche temporaire ou remisez-le.
Cela vous permettra de défaire <strong>tout</strong> ce que vous pourrez essayer.
Si vous avez des modifications non sauvegardées dans votre répertoire de travail quand vous essayez une fusion, certaines des astuces qui vont suivre risque de vous faire perdre ce travail.</p>
<p>Parcourons ensemble un exemple très simple.
Nous avons un fichier Ruby super simple qui affiche « hello world ».</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
  puts <span style="font-style: italic">&#39;hello world&#39;</span>
<span style="font-weight: bold">end</span>

hello()</code></pre>
</figure>
<p>Dans notre dépôt, nous créons une nouvelle branche appelée <code class="literal">whitespace</code> et nous entamons la transformation de toutes les fins de ligne Unix en fin de lignes DOS, ce qui revient à modifier chaque ligne, mais juste avec des caractères invisibles.
Ensuite, nous changeons la ligne « hello world » en « hello mundo ».</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b whitespace
Basculement sur la nouvelle branche &#39;whitespace&#39;

<span style="font-weight: bold">$</span> unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;converted hello.rb to DOS&#39;</span>
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

<span style="font-weight: bold">$</span> vim hello.rb
<span style="font-weight: bold">$</span> git diff -w
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

 def hello
-  puts &#39;hello world&#39;
+  puts &#39;hello mundo&#39;^M
 end

 hello()

<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;hello mundo change&#39;</span>
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</figure>
<p>À présent, nous rebasculons sur <code class="literal">master</code> et nous ajoutons une documentation de la fonction.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
Basculement sur la branche &#39;master&#39;

<span style="font-weight: bold">$</span> vim hello.rb
<span style="font-weight: bold">$</span> git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts &#39;hello world&#39;
 end

<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;document the function&#39;</span>
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Et maintenant, nous essayons de fusionner notre branche <code class="literal">whitespace</code> et nous allons générer des conflits dûs aux modifications de fins de ligne.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge whitespace
Fusion automatique de hello.rb
CONFLIT (contenu) : Conflit de fusion dans hello.rb
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<section class="sect3" title="Abandonner une fusion">
<h4 id="s_abort_merge">Abandonner une fusion</h4>
<p>Nous avons ici plusieurs options.
Une première consiste à sortir de cette situation.
Vous ne vous attendiez peut-être pas à rencontrer un conflit et vous ne souhaitez pas encore le gérer, alors vous pouvez simplement faire marche arrière avec <code class="literal">git merge --abort</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -sb
<span style="font-weight: bold">#</span><span style="font-style: italic"># master</span>
UU hello.rb

<span style="font-weight: bold">$</span> git merge --abort

<span style="font-weight: bold">$</span> git status -sb
<span style="font-weight: bold">#</span><span style="font-style: italic"># master</span></code></pre>
</figure>
<p>L&#8217;option <code class="literal">git merge --abort</code> essaie de vous ramener à l&#8217;état précédent la fusion.
Les seuls cas dans lesquels il n&#8217;y parvient pas parfaitement seraient ceux pour lesquels vous aviez déjà auparavant des modifications non validées ou non remisées dans votre répertoire de travail au moment de la fusion.
Sinon, tout devrait se passer sans problème.</p>
<p>Si, pour une raison quelconque, vous vous trouvez dans une situation horrible et que vous souhaitez repartir à zéro, vous pouvez aussi lancer <code class="literal">git reset --hard HEAD</code> ou sur toute autre référence où vous souhaitez revenir.
Souvenez-vous tout de même que cela va balayer toutes les modifications de votre répertoire de travail, donc assurez-vous de n&#8217;avoir aucune modification de valeur avant.</p>
</section>
<section class="sect3" title="Ignorer les caractères invisibles">
<h4 id="_ignorer_les_caractères_invisibles">Ignorer les caractères invisibles</h4>
<p>Dans ce cas spécifique, les conflits sont dûs à des espaces blancs.
Nous le savons parce que le cas est simple, mais cela reste assez facile à déterminer dans les cas réels en regardant les conflits parce que chaque ligne est supprimée à une ligne puis réintroduite à la suivante.
Par défaut, Git voit toutes ces lignes comme modifiées et il ne peut pas fusionner les fichiers.</p>
<p>La stratégie de fusion par défaut accepte quand même des arguments, et certains d&#8217;entre eux traitent le cas des modifications impliquant les caractères blancs.
Si vous vous rendez compte que vous avez de nombreux conflits de caractères blancs lors d&#8217;une fusion, vous pouvez simplement abandonner la fusion et en relancer une en utilisant les options <code class="literal">-Xignore-all-space</code> ou <code class="literal">-Xignore-space-change</code>.
La première option ignore <strong>complètement</strong> tous les espaces tandis que la seconde traite les séquences d&#8217;un ou plusieurs espaces comme équivalentes.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge -Xignore-all-space whitespace
Fusion automatique de hello.rb
Merge made by the &#39;recursive&#39; strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</figure>
<p>Puisque dans ce cas, les modifications réelles n&#8217;entraient pas en conflit, une fois les modifications d&#8217;espaces ignorées, tout fusionne parfaitement bien.</p>
<p>Ça sauve la vie si vous avez dans votre équipe une personne qui reformate tout d&#8217;espaces en tabulations ou vice-versa.</p>
</section>
<section class="sect3" title="Re-fusion manuelle d&#8217;un fichier">
<h4 id="s_manual_remerge">Re-fusion manuelle d&#8217;un fichier</h4>
<p>Bien que Git gère le pré-traitement d&#8217;espaces plutôt bien, il existe d&#8217;autres types de modifications que Git ne peut pas gérer automatiquement, mais dont la fusion peut être scriptable.
Par exemple, supposons que Git n&#8217;ait pas pu gérer les espaces et que nous ayons dû résoudre le problème à la main.</p>
<p>Ce que nous devons réellement faire est de passer le fichier que nous cherchons à fusionner à travers <code class="literal">dos2unix</code> avant d&#8217;essayer de le fusionner réellement.
Comment pourrions-nous nous y prendre ?</p>
<p>Premièrement, nous entrons dans l&#8217;état de conflit de fusion.
Puis, nous voulons obtenir des copies de la version locale (<strong>ours</strong>), de la version distante (<strong>theirs</strong>, celle qui vient de la branche à fusionner) et de la version commune (l&#8217;ancêtre commun depuis lequel les branches sont parties).
Ensuite, nous voulons corriger au choix la version locale ou la distante et réessayer de fusionner juste ce fichier.</p>
<p>Obtenir les trois versions des fichiers est en fait assez facile.
Git stocke toutes ces versions dans l&#8217;index sous formes d&#8217;étapes (<strong>stages</strong>), auxquelles chacune y a un nombre associé.
Stage 1 est l&#8217;ancêtre commun, stage 2 est notre version, stage 3 est la version de <code class="literal">MERGE_HEAD</code>, la version qu&#8217;on cherche à fusionner (<strong>theirs</strong>).</p>
<p>Vous pouvez extraire une copie de chacune de ces versions du fichier en conflit avec la commande <code class="literal">git show</code> et une syntaxe spéciale.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show :1:hello.rb &gt; hello.common.rb
<span style="font-weight: bold">$</span> git show :2:hello.rb &gt; hello.ours.rb
<span style="font-weight: bold">$</span> git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</figure>
<p>Si vous voulez rentrer un peu plus dans le dur, vous pouvez aussi utiliser la commande de plomberie <code class="literal">ls-files -u</code> pour récupérer les SHA-1 des blobs Git de chacun de ces fichiers.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</figure>
<p>La syntaxe <code class="literal">:1:hello.rb</code> est juste un raccourcis pour la recherche du SHA-1 de ce blob.</p>
<p>À présent que nous avons le contenu des trois étapes dans notre répertoire de travail, nous pouvons réparer manuellement la copie distante pour résoudre le problème d&#8217;espaces et re-fusionner le fichier avec la commande méconnue <code class="literal">git merge-file</code> dont c&#8217;est l&#8217;exacte fonction.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

<span style="font-weight: bold">$</span> git merge-file -p <span style="font-weight: bold; font-style: italic">\</span>
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

<span style="font-weight: bold">$</span> git diff -w
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts &#39;hello world&#39;
+   puts &#39;hello mundo&#39;
  end

  hello()</code></pre>
</figure>
<p>À ce moment, nous avons un fichier joliment fusionné.
En fait, cela fonctionne même mieux que l&#8217;option <code class="literal">ignore-all-space</code> parce que le problème d&#8217;espace est corrigé avant la fusion plutôt que simplement ignoré.
Dans la fusion <code class="literal">ignore-all-space</code>, nous avons en fait obtenu quelques lignes contenant des fins de lignes DOS, ce qui a mélangé les styles.</p>
<p>Si vous voulez vous faire une idée avant de finaliser la validation sur ce qui a réellement changé entre un côté et l&#8217;autre, vous pouvez demander à <code class="literal">git diff</code> de comparer le contenu de votre répertoire de travail que vous êtes sur le point de valider comme résultat de la fusion avec n&#8217;importe quelle étape.
Détaillons chaque comparaison.</p>
<p>Pour comparer votre résultat avec ce que vous aviez dans votre branche avant la fusion, en d&#8217;autres termes, ce que la fusion a introduit, vous pouvez lancer <code class="literal">git diff --ours</code></p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

<span style="font-weight: bold"> #</span> prints out a greeting
 def hello
-  puts &#39;hello world&#39;
+  puts &#39;hello mundo&#39;
 end

 hello()</code></pre>
</figure>
<p>Donc nous voyons ici que ce qui est arrivé à notre branche, ce que nous introduisons réellement dans ce fichier avec cette fusion, n&#8217;est qu&#8217;une ligne modifiée.</p>
<p>Si nous voulons voir le résultat de la fusion modifiée depuis la version distante, nous pouvons lancer <code class="literal">git diff --theirs</code>.
Dans cet exemple et le suivant, nous devons utiliser <code class="literal">-w</code> pour éliminer les espaces parce que nous le comparons à ce qui est dans Git et non pas notre version nettoyée <code class="literal">hello.theirs.rb</code> du fichier.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --theirs -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts &#39;hello mundo&#39;
 end</code></pre>
</figure>
<p>Enfin, nous pouvons voir comment le fichier a été modifié dans les deux branches avec <code class="literal">git diff --base</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --base -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts &#39;hello world&#39;
+  puts &#39;hello mundo&#39;
 end

 hello()</code></pre>
</figure>
<p>À ce point, nous pouvons utiliser la commande <code class="literal">git clean</code> pour éliminer les fichiers supplémentaires maintenant inutiles que nous avons créés pour notre fusion manuelle.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -f
Suppression de hello.common.rb
Suppression de hello.ours.rb
Suppression de hello.theirs.rb</code></pre>
</figure>
</section>
<section class="sect3" title="Examiner les conflits">
<h4 id="s_checking_out_conflicts">Examiner les conflits</h4>
<p>Peut-être ne sommes-nous pas heureux de la résolution actuelle, ou bien l&#8217;édition à la main d&#8217;un côté ou des deux ne fonctionne pas correctement et nécessite plus de contexte.</p>
<p>Modifions un peu l&#8217;exemple.
Pour cet exemple, nous avons deux branches à longue durée de vie qui comprennent quelques <em>commits</em> mais créent des conflits de contenu légitimes à la fusion.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</figure>
<p>Nous avons maintenant trois <em>commits</em> uniques qui n&#8217;existent que sur la branche <code class="literal">master</code> et trois autres sur la branche <code class="literal">mundo</code>.
Si nous essayons de fusionner la branche <code class="literal">mundo</code>, nous obtenons un conflit.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge mundo
Fusion automatique de hello.rb
CONFLIT (contenu): Conflit de fusion dans hello.rb
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<p>Nous souhaitons voir ce qui constitue le conflit de fusion.
Si nous ouvrons le fichier, nous verrons quelque chose comme :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts <span style="font-style: italic">&#39;hola world&#39;</span>
======
  puts <span style="font-style: italic">&#39;hello mundo&#39;</span>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
<span style="font-weight: bold">end</span>

hello()</code></pre>
</figure>
<p>Les deux côtés de la fusion on ajouté du contenu au fichier, mais certains <em>commits</em> ont modifié le fichier au même endroit, ce qui a causé le conflit.</p>
<p>Explorons quelques outils que vous avez à disposition pour déterminer comment ce conflit est apparu.
Peut-être le moyen de résoudre n&#8217;est-il pas évident.
Il nécessite plus de contexte.</p>
<p>Un outil utile est <code class="literal">git checkout</code> avec l&#8217;option <code class="literal">--conflict</code>.
Il va re-extraire le fichier et remplacer les marqueurs de conflit.
Cela peut être utile si vous souhaitez éliminer les marqueurs et essayer de résoudre le conflit à nouveau.</p>
<p>Vous pouvez passer en paramètre à <code class="literal">--conflict</code>, soit <code class="literal">diff3</code> soit <code class="literal">merge</code> (le paramètre par défaut).
Si vous lui passez <code class="literal">diff3</code>, Git utilisera une version différente des marqueurs de conflit, vous fournissant non seulement les versions locales (<em>ours</em>) et distantes (<em>theirs</em>), mais aussi la version « base » intégrée pour vous fournir plus de contexte.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout --conflict=diff3 hello.rb</code></pre>
</figure>
<p>Une fois que nous l&#8217;avons lancé, le fichier ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts <span style="font-style: italic">&#39;hola world&#39;</span>
||||||| base
  puts <span style="font-style: italic">&#39;hello world&#39;</span>
======
  puts <span style="font-style: italic">&#39;hello mundo&#39;</span>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
<span style="font-weight: bold">end</span>

hello()</code></pre>
</figure>
<p>Si vous appréciez ce format, vous pouvez le régler comme défaut pour les futur conflits de fusion en renseignant le paramètre <code class="literal">merge.conflictstyle</code> avec <code class="literal">diff3</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global merge.conflictstyle diff3</code></pre>
</figure>
<p>La commande <code class="literal">git checkout</code> peut aussi accepter les options <code class="literal">--ours</code> et <code class="literal">--theirs</code>, qui peuvent servir de moyen rapide de choisir unilatéralement une version ou une autre sans fusion.</p>
<p>Cela peut être particulièrement utile pour les conflits de fichiers binaires où vous ne pouvez que choisir un des côté, ou des conflits où vous souhaitez fusionner certains fichiers depuis d&#8217;autres branches - vous pouvez fusionner, puis extraire certains fichiers depuis un côté ou un autre avant de valider le résultat.</p>
</section>
<section class="sect3" title="Journal de fusion">
<h4 id="s_merge_log">Journal de fusion</h4>
<p>Un autre outil utile pour la résolution de conflits de fusion est <code class="literal">git log</code>.
Cela peut vous aider à obtenir du contexte ce qui a contribué aux conflits.
Parcourir un petit morceau de l&#8217;historique pour se rappeler pourquoi deux lignes de développement ont touché au même endroit dans le code peut s&#8217;avérer quelque fois très utile.</p>
<p>Pour obtenir une liste complète de tous les <em>commits</em> uniques qui ont été introduits dans chaque branche impliquée dans la fusion, nous pouvons utiliser la syntaxe « triple point » que nous avons apprise dans <a id="xref-s_triple_dot" href="#s_triple_dot" class="xref">Triple point</a>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
<span style="font-weight: bold">&gt;</span> e3eb223 add more tests
<span style="font-weight: bold">&gt;</span> 7cff591 add testing script
<span style="font-weight: bold">&gt;</span> c3ffff1 changed text to hello mundo</code></pre>
</figure>
<p>Voilà une belle liste des six <em>commits</em> impliqués, ainsi que chaque ligne de développement sur laquelle chaque <em>commit</em> se trouvait.</p>
<p>Néanmoins, nous pouvons simplifier encore plus ceci pour fournir beaucoup plus de contexte.
Si nous ajoutons l&#8217;option <code class="literal">--merge</code> à <code class="literal">git log</code>, il n&#8217;affichera que les <em>commits</em> de part et d&#8217;autre de la fusion qui modifient un fichier présentant un conflit.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
<span style="font-weight: bold">&gt;</span> c3ffff1 changed text to hello mundo</code></pre>
</figure>
<p>Si nous lançons cela avec l&#8217;option <code class="literal">-p</code> à la place, vous obtenez les diffs limités au fichier qui s&#8217;est retrouvé en conflit.
Cela peut s&#8217;avérer <strong>vraiment</strong> utile pour vous donner le contexte nécessaire à la compréhension de la raison d&#8217;un conflit et à sa résolution intelligente.</p>
</section>
<section class="sect3" title="Format de diff combiné">
<h4 id="_format_de_diff_combiné">Format de diff combiné</h4>
<p>Puisque Git indexe tous les résultats de fusion couronnés de succès, quand vous lancez <code class="literal">git diff</code> dans un état de conflit de fusion, vous n&#8217;obtenez que ce qui toujours en conflit à ce moment.
Il peut s&#8217;avérer utile de voir ce qui reste à résoudre.</p>
<p>Quand vous lancez <code class="literal">git diff</code> directement après le conflit de fusion, il vous donne de l&#8217;information dans un format de diff plutôt spécial.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts &#39;hola world&#39;
++=======
+   puts &#39;hello mundo&#39;
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</figure>
<p>Ce format s&#8217;appelle « diff combiné » (<em>combined diff</em>) et vous fournit deux colonnes d&#8217;information sur chaque ligne.
La première colonne indique que la ligne est différente (ajoutée ou supprimée) entre la branche « <em>ours</em> » et le fichier dans le répertoire de travail.
La seconde colonne fait de même pour la branche « <em>theirs</em> » et la copie du répertoire de travail.</p>
<p>Donc dans cet exemple, vous pouvez voir que les lignes <code class="literal">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> et <code class="literal">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> sont dans la copie de travail mais n&#8217;étaient dans aucun des deux côtés de la fusion.
C&#8217;est logique parce que l&#8217;outil de fusion les a collés ici pour donner du contexte, mais nous devrons les retirer.</p>
<p>Si nous résolvons le conflit et relançons <code class="literal">git diff</code>, nous verrons la même chose, mais ce sera un peu plus utile.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim hello.rb
<span style="font-weight: bold">$</span> git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
-   puts &#39;hola world&#39;
 -  puts &#39;hello mundo&#39;
++  puts &#39;hola mundo&#39;
  end

  hello()</code></pre>
</figure>
<p>Ceci nous montre que « hola world » était présent de notre côté mais pas dans la copie de travail, que « hello mundo » était présent de l&#8217;autre côté mais pas non plus dans la copie de travail et que finalement, « hola mundo » n&#8217;était dans aucun des deux côtés, mais se trouve dans la copie de travail.
C&#8217;est particulièrement utile lors d&#8217;une revue avant de valider la résolution.</p>
<p>Vous pouvez aussi l&#8217;obtenir depuis <code class="literal">git log</code> pour toute fusion pour visualiser comment quelque chose a été résolu après coup.
Git affichera ce format si vous lancez <code class="literal">git show</code> sur un <em>commit</em> de fusion, ou si vous ajoutez une option <code class="literal">--cc</code> à <code class="literal">git log -p</code> (qui par défaut ne montre que les patchs des <em>commits</em> qui ne sont pas des fusions).</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch &#39;mundo&#39;

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
-   puts &#39;hola world&#39;
 -  puts &#39;hello mundo&#39;
++  puts &#39;hola mundo&#39;
  end

  hello()</code></pre>
</figure>
</section>
</section>
<section class="sect2" title="Défaire des fusions">
<h3 id="s_undoing_merges">Défaire des fusions</h3>
<p>Comme vous savez créer des <em>commits</em> de fusion à présent, vous allez certainement en faire par erreur.
Un des grands avantages de l&#8217;utilisation de Git est qu&#8217;il n&#8217;est pas interdit de faire des erreurs, parce qu&#8217;il reste toujours possible (et très souvent facile) de les corriger.</p>
<p>Les <em>commits</em> de fusion ne font pas exception.
Supposons que vous avez commencé à travailler sur une branche thématique, que vous l&#8217;avez accidentellement fusionnée dans <code class="literal">master</code> et qu&#8217;en conséquence votre historique ressemble à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-start.png" alt="_Commit_ de fusion accidentel."/>
</div>
<figcaption>Figure 2. <em>Commit</em> de fusion accidentel</figcaption>
</figure>
<p>Il existe deux façons d&#8217;aborder ce problème, en fonction du résultat que vous souhaitez obtenir.</p>
<section class="sect3" title="Correction des références">
<h4 id="_correction_des_références">Correction des références</h4>
<p>Si le <em>commit</em> de fusion non désiré n&#8217;existe que dans votre dépôt local, la solution la plus simple et la meilleure consiste à déplacer les branches pour qu&#8217;elles pointent où on le souhaite.
La plupart du temps, en faisant suivre le <code class="literal">git merge</code> malencontreux par un <code class="literal">git reset --hard HEAD~</code>, on remet les pointeurs de branche dans l&#8217;état suivant :</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-reset.png" alt="Historique après `git reset --hard HEAD~`."/>
</div>
<figcaption>Figure 3. Historique après <code class="literal">git reset --hard HEAD~</code></figcaption>
</figure>
<p>Nous avons détaillé <code class="literal">reset</code> dans <a id="xref-s_git_reset" href="#s_git_reset" class="xref">Reset démystifié</a> et il ne devrait pas être très difficile de comprendre ce résultat.
Voici néanmoins un petit rappel : <code class="literal">reset --hard</code> réalise généralement trois étapes :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Déplace la branche pointée par HEAD ; dans notre cas, nous voulons déplacer <code class="literal">master</code> sur son point avant la fusion (<code class="literal">C6</code>),</span>
</li>
<li>
<span class="principal">Faire ressembler l&#8217;index à HEAD,</span>
</li>
<li>
<span class="principal">Faire ressembler le répertoire de travail à l&#8217;index.</span>
</li>
</ol>
</div>
<p>Le défaut de cette approche est qu&#8217;elle ré-écrit l&#8217;historique, ce qui peut être problématique avec un dépôt partagé.
Reportez-vous à <a id="xref--ch03-git-branching--s_rebase_peril" href="ch03-git-branching.xhtml#s_rebase_peril" class="xref">Les dangers du rebasage</a> pour plus d&#8217;information ; en résumé si d&#8217;autres personnes ont déjà les <em>commits</em> que vous ré-écrivez, il vaudrait mieux éviter un <code class="literal">reset</code>.
Cette approche ne fonctionnera pas non plus si d&#8217;autres <em>commits</em> ont été créés depuis la fusion ; déplacer les références des branches éliminera effectivement ces modifications.</p>
</section>
<section class="sect3" title="Inverser le commit">
<h4 id="s_reverse_commit">Inverser le <em>commit</em></h4>
<p>Si les déplacements des pointeurs de branche ne sont pas envisageables, Git vous donne encore l&#8217;option de créer un nouveau <em>commit</em> qui défait toutes les modifications d&#8217;un autre déjà existant.
Git appelle cette option une « inversion » (<em>revert</em>), et dans ce scénario particulier, vous l&#8217;invoqueriez comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git revert -m 1 HEAD
[master b1d8379] Revert &quot;Merge branch &#39;topic&#39;&quot;</code></pre>
</figure>
<p>L&#8217;option <code class="literal">-m 1</code> indique quel parent est le principal et devrait être conservé.
Si vous invoquez une fusion dans <code class="literal">HEAD</code> (<code class="literal">git merge topic</code>), le nouveau <em>commit</em> a deux parents : le premier est <code class="literal">HEAD</code> (<code class="literal">C6</code>), et le second est le sommet de la branche en cours de fusion (<code class="literal">C4</code>).
Dans ce cas, nous souhaitons défaire toutes les modifications introduites dans le parent numéro 2 (<code class="literal">C4</code>), tout en conservant tout le contenu du parent numéro 1 (<code class="literal">C6</code>).</p>
<p>L&#8217;historique avec le <em>commit</em> d&#8217;inversion ressemble à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-revert.png" alt="Historique après `git revert -m 1`."/>
</div>
<figcaption>Figure 4. Historique après <code class="literal">git revert -m 1</code></figcaption>
</figure>
<p>Le nouveau <em>commit</em> <code class="literal">^M</code> a exactement le même contenu que <code class="literal">C6</code>, et partant de là, c&#8217;est comme si la fusion n&#8217;avait pas eu lieu, mis à part que les <em>commits</em> qui ne sont plus fusionnés sont toujours dans l&#8217;historique de <code class="literal">HEAD</code>.
Git sera confus si vous tentez de re-fusionner <code class="literal">topic</code> dans <code class="literal">master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge topic
Already up-to-date.</code></pre>
</figure>
<p>Il n&#8217;y a rien dans <code class="literal">topic</code> qui ne soit pas déjà joignable depuis <code class="literal">master</code>.
Pire encore, si vous ajoutez du travail à <code class="literal">topic</code> et re-fusionnez, Git n&#8217;ajoutera que les modifications <em>depuis</em> la fusion inversée :</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-revert2.png" alt="Historique avec une mauvaise fusion."/>
</div>
<figcaption>Figure 5. Historique avec une mauvaise fusion</figcaption>
</figure>
<p>Le meilleur contournement de ceci est de dé-inverser la fusion originale, puisque vous voulez ajouter les modifications qui ont été annulées, <strong>puis</strong> de créer un nouveau <em>commit</em> de fusion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git revert ^M
[master 09f0126] Revert &quot;Revert &quot;Merge branch &#39;topic&#39;&quot;&quot;
<span style="font-weight: bold">$</span> git merge topic</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/undomerge-revert3.png" alt="Historique après re-fusion de la fusion annulée."/>
</div>
<figcaption>Figure 6. Historique après re-fusion de la fusion annulée</figcaption>
</figure>
<p>Dans cet exemple, <code class="literal">M</code> et <code class="literal">^M</code> s&#8217;annulent.
<code class="literal">^^M</code> fusionne effectivement les modifications depuis <code class="literal">C3</code> et <code class="literal">C4</code>, et <code class="literal">C8</code> fusionne les modifications depuis <code class="literal">C7</code>, donc à présent, <code class="literal">topic</code> est totalement fusionnée.</p>
</section>
</section>
<section class="sect2" title="Autres types de fusions">
<h3 id="_autres_types_de_fusions">Autres types de fusions</h3>
<p>Jusqu&#8217;ici, nous avons traité les fusions normales entre deux branches qui ont été gérées normalement avec ce qui s&#8217;appelle la stratégie « récursive » de fusion.
Il existe cependant d&#8217;autres manières de fusionner des branches.
Traitons en quelques unes rapidement.</p>
<section class="sect3" title="Préférence our ou theirs">
<h4 id="_préférence_em_our_em_ou_em_theirs_em">Préférence <em>our</em> ou <em>theirs</em></h4>
<p>Premièrement, il existe un autre mode utile que nous pouvons utiliser avec le mode « recursive » normal de fusion.
Nous avons déjà vu les options <code class="literal">ignore-all-space</code> et <code class="literal">ignore-space-change</code> qui sont passées avec <code class="literal">-X</code> mais nous pouvons aussi indiquer à Git de favoriser un côté plutôt que l&#8217;autre lorsqu&#8217;il rencontre un conflit.</p>
<p>Par défaut, quand Git rencontre un conflit entre deux branches en cours de fusion, il va ajouter des marqueurs de conflit de fusion dans le code et marquer le fichier en conflit pour vous laisser le résoudre.
Si vous préférez que Git choisisse simplement un côté spécifique et qu&#8217;il ignore l&#8217;autre côté au lieu de vous laisser fusionner manuellement le conflit, vous pouvez passer <code class="literal">-Xours</code> ou <code class="literal">-Xtheirs</code> à la commande <code class="literal">merge</code>.</p>
<p>Si une des options est spécifiée, Git ne va pas ajouter de marqueurs de conflit.
Toutes les différences qui peuvent être fusionnées seront fusionnées.
Pour toutes les différences qui génèrent un conflit, Git choisira simplement la version du côté que vous avez spécifié, y compris pour les fichiers binaires.</p>
<p>Si nous retournons à l&#8217;exemple « hello world » précédent, nous pouvons voir que la fusion provoque des conflits.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge mundo
Fusion automatique de  hello.rb
CONFLIT (contenu): Conflit de fusion dans hello.rb
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<p>Cependant, si nous la lançons avec <code class="literal">-Xours</code> ou <code class="literal">-Xtheirs</code>, elle n&#8217;en provoque pas.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge -Xours mundo
Fusion automatique de hello.rb
Merge made by the &#39;recursive&#39; strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</figure>
<p>Dans ce dernier cas, au lieu d&#8217;obtenir des marqueurs de conflit dans le fichier avec « hello mundo » d&#8217;un côté et « hola world » de l&#8217;autre, Git choisira simplement « hola world ».
À part cela, toutes les autres modifications qui ne génèrent pas de conflit sont fusionnées sans problème.</p>
<p>Cette option peut aussi être passée à la commande <code class="literal">git merge-file</code> que nous avons utilisée plus tôt en lançant quelque chose comme <code class="literal">git merge-file --ours</code> pour les fusions de fichiers individuels.</p>
<p>Si vous voulez faire quelque chose similaire mais indiquer à Git de ne même pas essayer de fusionner les modifications de l&#8217;autre côté, il existe une option draconienne qui s&#8217;appelle la <em>stratégie</em> de fusion « <em>ours</em> ».</p>
<p>Cela réalisera une fusion factice.
Cela enregistrera un nouveau <em>commit</em> de fusion avec les deux branches comme parents, mais ne regardera même pas la branche en cours de fusion.
Cela enregistrera simplement le code exact de la branche courante comme résultat de la fusion.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge -s ours mundo
Merge made by the &#39;ours&#39; strategy.
<span style="font-weight: bold">$</span> git diff HEAD HEAD~
<span style="font-weight: bold">$</span></code></pre>
</figure>
<p>Vous pouvez voir qu&#8217;il n&#8217;y a pas de différence entre la branche sur laquelle nous étions précédemment et le résultat de la fusion.</p>
<p>Cela peut s&#8217;avérer utile pour faire croire à Git qu&#8217;une branche est déjà fusionnée quand on fusionne plus tard.
Par exemple, disons que vous avez créé une branche depuis une branche « release » et avez travaillé dessus et que vous allez vouloir réintégrer ce travail dans <code class="literal">master</code>.
Dans l&#8217;intervalle, les correctifs de <code class="literal">master</code> doivent être reportés dans la branche <code class="literal">release</code>.
Vous pouvez fusionner la branche de correctif dans la branche <code class="literal">release</code> et aussi faire un <code class="literal">merge -s ours</code> de cette branche dans la branche <code class="literal">master</code> (même si le correctif est déjà présent) de sorte que lorsque fusionnerez plus tard la branche <code class="literal">release</code> , il n&#8217;y aura pas de conflit dû au correctif.</p>
</section>
<section class="sect3" title="Subtree Merging">
<h4 id="s_subtree_merge">Subtree Merging</h4>
<p>L&#8217;idée de la fusion de sous-arbre est que vous avez deux projets, et l&#8217;un des projets se réfère à un sous-dossier de l&#8217;autre et vice-versa.
Quand vous spécifiez une fusion de sous-arbre, Git est souvent assez malin pour se rendre compte que l&#8217;un est un sous-arbre de l&#8217;autre et fusionner comme il faut.</p>
<p>Nous allons explorer à travers un exemple comment ajouter un projet séparé à l&#8217;intérieur d&#8217;un projet existant et ensuite fusionner le code du second dans un sous-dossier du premier.</p>
<p>D&#8217;abord, nous ajouterons l&#8217;application Rack à notre projet.
Nous ajouterons le projet Rack en tant que référence distante dans notre propre projet puis l&#8217;extrairons dans sa propre branche :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add rack_remote https://github.com/rack/rack
<span style="font-weight: bold">$</span> git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
<span style="font-weight: bold">$</span> git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch &quot;rack_branch&quot;</code></pre>
</figure>
<p>Maintenant nous avons la racine du projet Rack dans notre branche <code class="literal">rack_branch</code> et notre propre projet dans la branche <code class="literal">master</code>.
Si vous extrayez un projet puis l&#8217;autre, vous verrez qu&#8217;ils ont des racines de projet différentes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
<span style="font-weight: bold">$</span> git checkout master
Switched to branch &quot;master&quot;
<span style="font-weight: bold">$</span> ls
README</code></pre>
</figure>
<p>C&#8217;est un concept assez étrange.
Toutes les branches de votre dépôt n&#8217;ont pas vraiment besoin d&#8217;être des branches du même projet.
C&#8217;est inhabituel, parce que c&#8217;est rarement utile, mais c&#8217;est assez facile d&#8217;avoir des branches qui contiennent des historiques totalement différents.</p>
<p>Dans notre cas, nous voulons tirer le projet Rack dans notre projet <code class="literal">master</code> en tant que sous-dossier.
Nous pouvons faire cela dans Git avec la commande <code class="literal">git read-tree</code>.
Vous en apprendrez plus sur <code class="literal">read-tree</code> et ses amis dans <a href="ch10-git-internals.xhtml" class="xref">Les tripes de Git</a>, mais pour l&#8217;instant sachez qu&#8217;elle lit l&#8217;arborescence d&#8217;une branche dans votre index courant et dans le répertoire de travail.
Nous venons de rebasculer dans notre branche <code class="literal">master</code>, et nous tirons la branche <code class="literal">rack_branch</code> dans le sous-dossier <code class="literal">rack</code> de notre branche <code class="literal">master</code> de notre projet principal :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git read-tree --prefix=rack/ -u rack_branch</code></pre>
</figure>
<p>Quand nous validons, c&#8217;est comme si nous avions tous les fichiers Rack dans ce sous-dossier – comme si les avions copiés depuis une archive.
Ce qui est intéressant est que nous pouvons assez facilement fusionner les modifications d&#8217;une des branches dans l&#8217;autre.
Donc, si le projet Rack est mis à jour, nous pouvons tirer en amont les modifications en basculant sur cette branche et en tirant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout rack_branch
<span style="font-weight: bold">$</span> git pull</code></pre>
</figure>
<p>Ensuite, nous pouvons fusionner les modifications dans notre brancher <code class="literal">master</code>.
Nous pouvons utiliser <code class="literal">git merge -s subtree</code> et cela marchera bien, mais Git fusionnera lui aussi les historiques ensemble, ce que nous ne voudrons probablement pas.
Pour tirer les modifications et préremplir le message de validation, utilisez les options <code class="literal">--squash</code> et <code class="literal">--no-commit</code> en complément de l&#8217;option de stratégie <code class="literal">-s subtree</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git merge --squash -s subtree --no-commit rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</figure>
<p>Toutes les modifications du projet Rach sont fusionnées et prêtes à être validées localement.
Vous pouvez aussi faire l&#8217;inverse – faire les modifications dans le sous-dossier <code class="literal">rack</code> de votre branche <code class="literal">master</code> et ensuite les fusionner plus tard dans votre branche <code class="literal">rack_branch</code> pour les soumettre aux mainteneurs ou les pousser en amont.</p>
<p>Ceci nous donne un moyen d&#8217;avoir un flux de travail quelque peu similaire au flux de travail des sous-modules sans utiliser les sous-modules (que nous couvrirons dans <a id="xref-s_git_submodules" href="#s_git_submodules" class="xref">Sous-modules</a>).
Npus pouvons garder dans notre dépôt des branches avec d&#8217;autres projets liés et les fusionner façon sous-arbre dans notre projet occasionnellement.
C&#8217;est bien par certains côtés ; par exemple tout le code est validé à un seul endroit.
Cependant, cela a d&#8217;autres défauts comme le fait que c&#8217;est un petit peu plus complexe et c&#8217;est plus facile de faire des erreurs en réintégrant les modifications ou en poussant accidentellement une branche dans un dépôt qui n&#8217;a rien à voir.</p>
<p>Une autre chose un peu étrange est que pour obtenir la différence entre ce que vous avez dans votre sous-dossier <code class="literal">rack</code> et le code dans votre branche <code class="literal">rack_branch</code> – pour voir si vous avez besoin de les fusionner – vous ne pouvez pas utiliser la commande <code class="literal">diff</code> classique.
À la place, vous devez lancer <code class="literal">git diff-tree</code> avec la branche que vous voulez comparer :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff-tree -p rack_branch</code></pre>
</figure>
<p>Ou, pour comparer ce qui est dans votre sous-dossier <code class="literal">rack</code> avec ce qu&#8217;était la branche <code class="literal">master</code> sur le serveur la dernière fois que vous avez tiré, vous pouvez lancer</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff-tree -p rack_remote/master</code></pre>
</figure>
</section>
</section>
</section>
<section class="sect1" title="Rerere">
<h2 id="s_sect_rerere">Rerere</h2>
<p>La fonctionalité <code class="literal">git rerere</code> est une fonction un peu cachée.
Le nom vient de l&#8217;anglais <em>reuse recorded resolution</em> (« <em>ré</em> utiliser les <em>ré</em> solutions en <em>re</em> gistrées ») et comme son nom l&#8217;indique, cela permet de demander à Git de se souvenir comment vous avez résolu un conflit sur une section de diff de manière que la prochaine fois qu&#8217;il rencontre le même conflit, il le résolve automatiquement pour vous.</p>
<p>Il existe pas mal de scénarios pour lesquels cette fonctionalité peut se montrer efficace.
Un exemple mentionné dans la documentation cite le cas d&#8217;une branche au long cours qui finira par fusionner proprement mais ne souhaite pas montrer des fusions intermédiaires.
Avec <code class="literal">rerere</code> activé, vous pouvez fusionner de temps en temps, résoudre les conflits, puis sauvegarder la fusion.
Si vous faites ceci en continu, alors la dernière fusion devrait être assez facile parce que <code class="literal">rerere</code> peut quasiment tout faire automatiquement pour vous.</p>
<p>La même tactique peut être utilisée si vous souhaitez rebaser plusieurs fois une branche tout en ne souhaitant pas avoir à gérer les mêmes conflits de rebasage à chaque fois.
Ou si vous voulez prendre la branche que vous avez fusionnée et si vous avez eu à corriger des conflits, puis décidez de la rebaser pour finir - vous souhaitez sûrement ne pas avoir à recorriger les mêmes conflits.</p>
<p>Une autre situation similaire apparaît quand vous fusionnez ensemble de temps en temps une série de branches thématiques évolutives dans un sommet testable, comme le projet Git lui-même le fait souvent.
Si les tests échouent, vous pouvez rembobiner vos fusions et les rejouer en écartant la branche qui a provoqué l&#8217;erreur sans devoir résoudre à nouveau tous les conflits.</p>
<p>Pour activer la fonctionnalité <code class="literal">rerere</code>, vous devez simplement lancer le paramétrage :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global rerere.enabled true</code></pre>
</figure>
<p>Vous pouvez aussi l&#8217;activer en créant le répertoire <code class="literal">.git/rr-cache</code> dans un dépôt spécifique, mais l&#8217;activation par ligne de commande reste plus claire et permet d&#8217;activer la fonction globalement.</p>
<p>Voyons maintenant un exemple similaire au précédent.
Supposons que nous avons un fichier qui contient ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span>! /usr/bin/env ruby

def hello
  puts &#39;hello world&#39;
end</code></pre>
</figure>
<p>Dans une branche, nous changeons « hello » en « hola », puis dans une autre branche nous changeons « world » en « mundo », comme précédemment.</p>
<figure class="image">
<div class="content">
<img src="images/rerere1.png" alt="rerere1"/>
</div>
</figure>
<p>Quand nous fusionnons les deux branches ensemble, nous obtenons un conflit de fusion :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge i18n-world
Fusion automatique de hello.rb
CONFLIT (contenu): Conflit de fusion dans hello.rb
Recorded preimage for &#39;hello.rb&#39;
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<p>Vous devriez avoir noté la présence d&#8217;un nouvelle ligne <code class="literal">Recorded preimage for FILE</code> (« Enregistrement de la pré-image pour FICHIER »).
À part ce détail, cela ressemble à un conflit de fusion tout à fait normal.
À ce stade, <code class="literal">rerere</code> peut déjà nous dire un certain nombre de choses.
Normalement, vous lanceriez un <code class="literal">git status</code> pour voir l&#8217;état actuel des conflits.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
<span style="font-weight: bold">#</span> On branch master
<span style="font-weight: bold">#</span> Unmerged paths:
<span style="font-weight: bold">#</span>   (use <span style="font-style: italic">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)
<span style="font-weight: bold">#</span>   (use <span style="font-style: italic">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span>	both modified:      hello.rb
<span style="font-weight: bold">#</span></code></pre>
</figure>
<p>Cependant, <code class="literal">git rerere</code> vous indiquera aussi les conflits pour lesquels il a enregistré la pré-image grâce à <code class="literal">git rerere status</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere status
hello.rb</code></pre>
</figure>
<p>Et <code class="literal">git rerere diff</code> montrera l&#8217;état actuel de la résolution ‑ quel était le conflit de départ et comment vous l&#8217;avez résolu.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts &#39;hello mundo&#39;
-=======
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   puts &#39;hola world&#39;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+=======
+  puts &#39;hello mundo&#39;
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world
 end</code></pre>
</figure>
<p>En complément (et bien que ça n&#8217;ait pas vraiment à voir avec <code class="literal">rerere</code>), vous pouvez utiliser <code class="literal">ls-files -u</code> pour voir les fichiers en conflit ainsi que les versions précédentes, à droite et à gauche :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb</code></pre>
</figure>
<p>Maintenant, vous pouvez le résoudre pour que la ligne de code soit simplement <code class="literal">puts 'hola mundo'</code> et vous pouvez relancer la commande <code class="literal">rerere diff</code> pour visualiser ce que rerere va mémoriser :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts &#39;hello mundo&#39;
-=======
-  puts &#39;hola world&#39;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+  puts &#39;hola mundo&#39;
 end</code></pre>
</figure>
<p>Cela indique simplement que quand Git voit un conflit de section dans un fichier <code class="literal">hello.rb</code> qui contient « hello mundo » d&#8217;un côté et « hola world » de l&#8217;autre, il doit résoudre ce conflit en « hola mundo ».</p>
<p>Maintenant, nous pouvons le marquer comme résolu et le valider :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add hello.rb
<span style="font-weight: bold">$</span> git commit
Recorded resolution for &#39;hello.rb&#39;.
[master 68e16e5] Merge branch &#39;i18n&#39;</code></pre>
</figure>
<p>Vous pouvez voir qu&#8217;il a « enregistré la résolution pour FICHIER » (<em>Recorded resolution for FILE</em>).</p>
<figure class="image">
<div class="content">
<img src="images/rerere2.png" alt="rerere2"/>
</div>
</figure>
<p>Maintenant, défaisons la fusion et rebasons plutôt la branche sur la branche master.
Nous pouvons déplacer notre branche en arrière en utilisant <code class="literal">reset</code> comme vu dans <a href="#s_git_reset" class="xref">Reset démystifié</a>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello</code></pre>
</figure>
<p>Notre fusion est défaite.
Rebasons notre branche thématique.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout i18n-world
Basculement sur la branche &#39;i18n-world&#39;

<span style="font-weight: bold">$</span> git rebase master
Premièrement, rembobinons head pour rejouer votre travail par-dessus...
Application : i18n world
Utilisation de l&#39;information de l&#39;index pour reconstruire un arbre de base...
M       hello.rb
Retour à un patch de la base et fusion à 3 points...
Fusion automatique de hello.rb
CONFLIT (contenu) : Conflit de fusion dans hello.rb
Resolved &#39;hello.rb&#39; using previous resolution.
Échec d&#39;intégration des modifications.
Le patch a échoué à 0001 i18n world</code></pre>
</figure>
<p>Ici, nous avons obtenu le conflit de fusion auquel nous nous attendions, mais des lignes supplémentaires sont apparues, en particulier <code class="literal">Resolved FILE using previous resolution</code> (FICHIER résolu en utilisant une résolution précédente).
Si nous inspectons le fichier <code class="literal">hello.rb</code>, il ne contient pas de marqueur de conflit.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat hello.rb
<span style="font-weight: bold">#</span>! /usr/bin/env ruby

def hello
  puts &#39;hola mundo&#39;
end</code></pre>
</figure>
<p><code class="literal">git diff</code> nous montrera comment le conflit a été re-résolu automatiquement :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
-   puts &#39;hola world&#39;
 -  puts &#39;hello mundo&#39;
++  puts &#39;hola mundo&#39;
  end</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/rerere3.png" alt="rerere3"/>
</div>
</figure>
<p>Vous pouvez aussi recréer l&#8217;état de conflit du fichier avec la commande <code class="literal">checkout</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout --conflict=merge hello.rb
<span style="font-weight: bold">$</span> cat hello.rb
<span style="font-weight: bold">#</span>! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts &#39;hola world&#39;
======
  puts &#39;hello mundo&#39;
<span style="font-weight: bold">&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt; theirs
end</code></pre>
</figure>
<p>Nous avons vu un exemple de ceci dans <a id="xref-s_advanced_merging" href="#s_advanced_merging" class="xref">Fusion avancée</a>.
Pour le moment, re-résolvons-le en relançant <code class="literal">rerere</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere
Resolved &#39;hello.rb&#39; using previous resolution.
<span style="font-weight: bold">$</span> cat hello.rb
<span style="font-weight: bold">#</span>! /usr/bin/env ruby

def hello
  puts &#39;hola mundo&#39;
end</code></pre>
</figure>
<p>Nous avons re-résolu le conflit du fichier automatiquement en utilisant la résolution mémorisée par <code class="literal">rerere</code>.
Vous pouvez le valider avec <code class="literal">add</code> et terminer de rebaser.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add hello.rb
<span style="font-weight: bold">$</span> git rebase --continue
Application: i18n one word</code></pre>
</figure>
<p>Dans les cas où vous souhaitez réaliser de nombreuses fusions successives d&#8217;une branche thématique ou si vous souhaitez la synchroniser souvent avec <code class="literal">master</code> sans devoir gérer des tas de conflits de fusion, ou encore si vous rebasez souvent, vous pouvez activer <code class="literal">rerere</code> qui vous simplifiera la vie.</p>
</section>
<section class="sect1" title="Déboguer avec Git">
<h2 id="_déboguer_avec_git">Déboguer avec Git</h2>
<p>Git fournit aussi quelques outils pour vous aider à déboguer votre projet.
Puisque Git est conçu pour fonctionner avec pratiquement tout type de projet, ces outils sont plutôt génériques, mais ils peuvent souvent vous aider à traquer un bogue ou au moins cerner où cela tourne mal.</p>
<section class="sect2" title="Fichier annoté">
<h3 id="s_file_annotation">Fichier annoté</h3>
<p>Si vous traquez un bogue dans votre code et que vous voulez savoir quand il est apparu et pourquoi, annoter les fichiers est souvent le meilleur moyen.
Cela vous montre la dernière validation qui a modifié chaque ligne de votre fichier.
Donc, si vous voyez une méthode dans votre code qui est boguée, vous pouvez visualiser le fichier annoté avec <code class="literal">git blame</code> pour voir quand chaque ligne de la méthode a été modifiée pour la dernière fois et par qui.
Cet exemple utilise l&#8217;option <code class="literal">-L</code> pour limiter la sortie des lignes 12 à 22 :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &#39;master&#39;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #{tree}&quot;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &#39;master&#39;)
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #{tree}&quot;)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #{path}&quot;)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</code></pre>
</figure>
<p>Remarquez que le premier champ est le SHA-1 partiel du dernier <em>commit</em> à avoir modifié la ligne.
Les deux champs suivants sont des valeurs extraites du <em>commit</em> : l&#8217;auteur et la date du <em>commit</em>, vous pouvez donc facilement voir qui a modifié la ligne et quand.
Ensuite arrive le numéro de ligne et son contenu.
Remarquez également les lignes dont le <em>commit</em> est <code class="literal">^4832fe2</code>, elles désignent les lignes qui étaient dans la version du fichier lors du premier <em>commit</em> de ce fichier.
Ce <em>commit</em> contient le premier ajout de ce fichier, et ces lignes n&#8217;ont pas été modifiées depuis.
Tout ça est un peu confus, parce que vous connaissez maintenant au moins trois façons différentes que Git interprète <code class="literal">^</code> pour modifier l&#8217;empreinte SHA, mais au moins, vous savez ce qu&#8217;il signifie ici.</p>
<p>Une autre chose sympa sur Git, c&#8217;est qu&#8217;il ne suit pas explicitement les renommages de fichier.
Il enregistre les contenus puis essaye de deviner ce qui a été renommé implicitement, après coup.
Ce qui nous permet d&#8217;utiliser cette fonctionnalité intéressante pour suivre toutes sortes de mouvements de code.
Si vous passez <code class="literal">-C</code> à <code class="literal">git blame</code>, Git analyse le fichier que vous voulez annoter et essaye de deviner d&#8217;où les bouts de code proviennent par copie ou déplacement.
Récemment, j&#8217;ai remanié un fichier nommé <code class="literal">GITServerHandler.m</code> en le divisant en plusieurs fichiers, dont le fichier <code class="literal">GITPackUpload.m</code>.
En annotant <code class="literal">GITPackUpload.m</code> avec l&#8217;option <code class="literal">-C</code>, je peux voir quelles sections de code en sont originaires :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</code></pre>
</figure>
<p>C&#8217;est vraiment utile, non ?
Normalement, vous obtenez comme <em>commit</em> originel celui dont votre code a été copié, puisque ce fut la première fois que vous avez touché à ces lignes dans ce fichier.
Git vous montre le <em>commit</em> d&#8217;origine, celui où vous avez écrit ces lignes, même si c&#8217;était dans un autre fichier.</p>
</section>
<section class="sect2" title="Recherche dichotomique">
<h3 id="s_binary_search">Recherche dichotomique</h3>
<p>Annoter un fichier peut aider si vous savez déjà où le problème se situe.
Si vous ne savez pas ce qui a cassé le code, il peut y avoir des dizaines, voire des centaines de <em>commits</em> depuis le dernier état où votre code fonctionnait et vous aimeriez certainement exécuter <code class="literal">git bisect</code> pour vous aider.
La commande <code class="literal">bisect</code> effectue une recherche par dichotomie dans votre historique pour vous aider à identifier aussi vite que possible quel <em>commit</em> a vu le bogue naître.</p>
<p>Disons que vous venez juste de pousser une version finale de votre code en production, vous récupérez un rapport de bogue à propos de quelque chose qui n&#8217;arrivait pas dans votre environnement de développement, et vous n&#8217;arrivez pas à trouver pourquoi votre code le fait.
Vous retournez sur votre code et il apparaît que vous pouvez reproduire le bogue mais vous ne savez pas ce qui se passe mal.
Vous pouvez faire une recherche par dichotomie pour trouver ce qui ne va pas.
D&#8217;abord, exécutez <code class="literal">git bisect start</code> pour démarrer la procédure, puis utilisez la commande <code class="literal">git bisect bad</code> pour dire que le <em>commit</em> courant est bogué.
Ensuite, dites à <code class="literal">bisect</code> quand le code fonctionnait, en utilisant <code class="literal">git bisect good [bonne_version]</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect start
<span style="font-weight: bold">$</span> git bisect bad
<span style="font-weight: bold">$</span> git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</code></pre>
</figure>
<p>Git trouve qu&#8217;il y a environ 12 <em>commits</em> entre celui que vous avez marqué comme le dernier bon connu (v1.0) et la version courante qui n&#8217;est pas bonne, et il a récupéré le <em>commit</em> du milieu à votre place.
À ce moment, vous pouvez dérouler vos tests pour voir si le bogue existait dans ce <em>commit</em>.
Si c&#8217;est le cas, il a été introduit quelque part avant ce <em>commit</em> médian, sinon, il l&#8217;a été évidemment après.
Il apparait que le bogue ne se reproduit pas ici, vous le dites à Git en tapant <code class="literal">git bisect good</code> et continuez votre périple :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</code></pre>
</figure>
<p>Vous êtes maintenant sur un autre <em>commit</em>, à mi-chemin entre celui que vous venez de tester et votre <em>commit</em> bogué.
Vous exécutez une nouvelle fois votre test et trouvez que ce <em>commit</em> est bogué, vous le dites à Git avec <code class="literal">git bisect bad</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</code></pre>
</figure>
<p>Ce <em>commit</em>-ci est bon, et Git a maintenant toutes les informations dont il a besoin pour déterminer où le bogue a été créé.
Il vous affiche le SHA-1 du premier <em>commit</em> bogué, quelques informations du <em>commit</em> et quels fichiers ont été modifiés dans celui-ci, vous pouvez donc trouver ce qui s&#8217;est passé pour créer ce bogue :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</code></pre>
</figure>
<p>Lorsque vous avez fini, vous devez exécuter <code class="literal">git bisect reset</code> pour réinitialiser votre HEAD où vous étiez avant de commencer, ou vous travaillerez dans un répertoire de travail non clairement défini :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect reset</code></pre>
</figure>
<p>C&#8217;est un outil puissant qui vous aidera à vérifier des centaines de <em>commits</em> en quelques minutes.
En plus, si vous avez un script qui sort avec une valeur 0 s&#8217;il est bon et autre chose sinon, vous pouvez même automatiser <code class="literal">git bisect</code>.
Premièrement vous lui spécifiez l&#8217;intervalle en lui fournissant les bon et mauvais <em>commits</em> connus.
Vous pouvez faire cela en une ligne en les entrant à la suite de la commande <code class="literal">bisect start</code>, le mauvais <em>commit</em> d&#8217;abord :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect start HEAD v1.0
<span style="font-weight: bold">$</span> git bisect run test-error.sh</code></pre>
</figure>
<p>Cela exécute automatiquement <code class="literal">test-error.sh</code> sur chaque <em>commit</em> jusqu&#8217;à ce que Git trouve le premier <em>commit</em> bogué.
Vous pouvez également exécuter des commandes comme <code class="literal">make</code> ou <code class="literal">make tests</code> ou quoi que ce soit qui exécute des tests automatisés à votre place.</p>
</section>
</section>
<section class="sect1" title="Sous-modules">
<h2 id="s_git_submodules">Sous-modules</h2>
<p>Il arrive souvent lorsque vous travaillez sur un projet que vous deviez utiliser un autre projet comme dépendance.
Cela peut être une bibliothèque qui est développée par une autre équipe ou que vous développez séparément pour l&#8217;utiliser dans plusieurs projets parents.
Ce scénario provoque un problème habituel : vous voulez être capable de gérer deux projets séparés tout en utilisant l&#8217;un dans l&#8217;autre.</p>
<p>Voici un exemple.
Supposons que vous développez un site web et que vous créez des flux Atom.
Plutôt que d&#8217;écrire votre propre code de génération Atom, vous décidez d&#8217;utiliser une bibliothèque.
Vous allez vraisemblablement devoir soit inclure ce code depuis un gestionnaire partagé comme CPAN ou Ruby gem, soit copier le code source dans votre propre arborescence de projet.
Le problème d&#8217;inclure la bibliothèque en tant que bibliothèque externe est qu&#8217;il est difficile de la personnaliser de quelque manière que ce soit et encore plus de la déployer, car vous devez vous assurer de la disponibilité de la bibliothèque chez chaque client.
Mais le problème d&#8217;inclure le code dans votre propre projet est que n&#8217;importe quelle personnalisation que vous faites est difficile à fusionner lorsque les modifications du développement principal arrivent.</p>
<p>Git gère ce problème avec les sous-modules.
Les sous-modules vous permettent de gérer un dépôt Git comme un sous-répertoire d&#8217;un autre dépôt Git.
Cela vous laisse la possibilité de cloner un dépôt dans votre projet et de garder isolés les <em>commits</em> de ce dépôt.</p>
<section class="sect2" title="Démarrer un sous-module">
<h3 id="s_starting_submodules">Démarrer un sous-module</h3>
<p>Détaillons le développement d&#8217;un projet simple qui a été divisé en un projet principal et quelques sous-projets.</p>
<p>Commençons par ajouter le dépôt d&#8217;un projet Git existant comme sous-module d&#8217;un dépôt sur lequel nous travaillons.
Pour ajouter un nouveau sous-module, nous utilisons la commande <code class="literal">git submodule add</code> avec l&#8217;URL du projet que nous souhaitons suivre.
Dans cette exemple, nous ajoutons une bibliothèque nommée « DbConnector ».</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/DbConnector
Clonage dans &#39;DbConnector&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Dépaquetage des objets: 100% (11/11), fait.
Vérification de la connectivité... fait.</code></pre>
</figure>
<p>Par défaut, les sous-modules ajoutent le sous-projet dans un répertoire portant le même nom que le dépôt, dans notre cas « DbConnector ».
Vous pouvez ajouter un chemin différent à la fin de la commande si vous souhaitez le placer ailleurs.</p>
<p>Si vous lancez <code class="literal">git status</code> à ce moment, vous noterez quelques différences.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
Sur la branche master
Votre branche est à jour avec &#39;origin/master&#39;.

Modifications qui seront validées :
  (utilisez &quot;git reset &lt;fichier&gt;...&quot; pour désindexer)

	nouveau fichier :   .gitmodules
	nouveau fichier :   DbConnector</code></pre>
</figure>
<p>Premièrement, un fichier <code class="literal">.gitmodules</code> vient d&#8217;apparaître.
C&#8217;est le fichier de configuration qui stocke la liaison entre l&#8217;URL du projet et le sous-répertoire local dans lequel vous l&#8217;avez tiré.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .gitmodules
[submodule &quot;DbConnector&quot;]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector</code></pre>
</figure>
<p>Si vous avez plusieurs sous-modules, vous aurez plusieurs entrées dans ce fichier.
Il est important de noter que ce fichier est en gestion de version comme vos autres fichiers, à l&#8217;instar de votre fichier <code class="literal">.gitignore</code>.
Il est poussé et tiré comme le reste de votre projet.
C&#8217;est également le moyen que les autres personnes qui clonent votre projet ont de savoir où récupérer le projet du sous-module.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Comme l&#8217;URL dans le fichier <code class="literal">.gitmodules</code> est ce que les autres personnes essaieront en premier de cloner et de tirer, assurez-vous que cette URL est effectivement accessible par les personnes concernées.
Par exemple, si vous utilisez une URL différente pour pousser que celle que les autres utiliseront pour tirer, utilisez l&#8217;URL à laquelle les autres ont accès.
Vous pouvez surcharger cette URL localement pour votre usage propre avec la commande <code class="literal">git config submodule.DbConnector.url PRIVATE_URL</code>.</p>
</div>
</aside>
<p>L&#8217;autre information dans la sortie de <code class="literal">git status</code> est l&#8217;entrée du répertoire du projet.
Si vous exécutez <code class="literal">git diff</code>, vous verrez quelque chose d&#8217;intéressant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</code></pre>
</figure>
<p>Même si <code class="literal">DbConnector</code> est un sous-répertoire de votre répertoire de travail, Git le voit comme un sous-module et ne suit pas son contenu (si vous n&#8217;êtes pas dans ce répertoire).
En échange, Git l&#8217;enregistre comme un <em>commit</em> particulier de ce dépôt.</p>
<p>Si vous souhaitez une sortie diff plus agréable, vous pouvez passer l&#8217;option <code class="literal">--submodule</code> à <code class="literal">git diff</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule &quot;DbConnector&quot;]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)</code></pre>
</figure>
<p>Au moment de valider, vous voyez quelque chose comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;added DbConnector module&#39;</span>
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector</code></pre>
</figure>
<p>Remarquez le mode 160000 pour l&#8217;entrée <code class="literal">DbConnector</code>.
C&#8217;est un mode spécial de Git qui signifie globalement que vous êtes en train d&#8217;enregistrer un <em>commit</em> comme un répertoire plutôt qu&#8217;un sous-répertoire ou un fichier.</p>
</section>
<section class="sect2" title="Cloner un projet avec des sous-modules">
<h3 id="s_cloning_submodules">Cloner un projet avec des sous-modules</h3>
<p>Maintenant, vous allez apprendre à cloner un projet contenant des sous-modules.
Quand vous récupérez un tel projet, vous obtenez les différents répertoires qui contiennent les sous-modules, mais encore aucun des fichiers :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/chaconinc/MainProject
Clonage dans &#39;MainProject&#39;...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Dépaquetage des objets: 100% (14/14), fait.
Vérification de la connectivité... fait.
<span style="font-weight: bold">$</span> cd MainProject
<span style="font-weight: bold">$</span> ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
<span style="font-weight: bold">$</span> cd DbConnector/
<span style="font-weight: bold">$</span> ls
<span style="font-weight: bold">$</span></code></pre>
</figure>
<p>Le répertoire <code class="literal">DbConnector</code> est présent mais vide.
Vous devez exécuter deux commandes : <code class="literal">git submodule init</code> pour initialiser votre fichier local de configuration, et <code class="literal">git submodule update</code> pour tirer toutes les données de ce projet et récupérer le <em>commit</em> approprié tel que listé dans votre super-projet :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule init
Sous-module &#39;DbConnector&#39; (https://github.com/chaconinc/DbConnector) enregistré pour le chemin &#39;DbConnector&#39;
<span style="font-weight: bold">$</span> git submodule update
Clonage dans &#39;DbConnector&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path &#39;DbConnector&#39;: checked out &#39;c3f01dc8862123d317dd46284b05b6892c7b29bc&#39;</code></pre>
</figure>
<p>Votre répertoire <code class="literal">DbConnector</code> est maintenant dans l&#8217;état exact dans lequel il était la dernière fois que vous avez validé.</p>
<p>Il existe une autre manière plus simple d&#8217;arriver au même résultat.
Si vous passez l&#8217;option <code class="literal">--recurse-submodules</code> à la commande <code class="literal">git clone</code>, celle-ci initialisera et mettra à jour automatiquement chaque sous-module du dépôt.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone --recurse-submodules https://github.com/chaconinc/MainProject
Clonage dans &#39;MainProject&#39;...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Dépaquetage des objets: 100% (14/14), fait.
Vérification de la connectivité... fait.
Submodule &#39;DbConnector&#39; (https://github.com/chaconinc/DbConnector) registered for path &#39;DbConnector&#39;
Clonage dans &#39;DbConnector&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Dépaquetage des objets: 100% (11/11), fait.
Vérification de la connectivité... fait.
chemin du sous-module &#39;DbConnector&#39; : &#39;c3f01dc8862123d317dd46284b05b6892c7b29bc&#39; extrait</code></pre>
</figure>
</section>
<section class="sect2" title="Travailler sur un projet comprenant des sous-modules">
<h3 id="_travailler_sur_un_projet_comprenant_des_sous_modules">Travailler sur un projet comprenant des sous-modules</h3>
<p>Nous avons à présent une copie d&#8217;un projet comprenant des sous-modules, et nous allons collaborer à la fois sur le projet principal et sur le projet du sous-module.</p>
<section class="sect3" title="Tirer des modifications amont">
<h4 id="_tirer_des_modifications_amont">Tirer des modifications amont</h4>
<p>Le modèle le plus simple d&#8217;utilisation des sous-modules est le cas de la simple consommation d&#8217;un sous-projet duquel on souhaite obtenir les mises à jour de temps en temps mais auquel on n&#8217;apporte pas de modification dans la copie de travail.
Examinons un exemple simple.</p>
<p>Quand vous souhaitez vérifier si le sous-module a évolué, vous pouvez vous rendre dans le répertoire correspondant et lancer <code class="literal">git fetch</code> puis <code class="literal">git merge</code> de la branche amont pour mettre à jour votre code local.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -&gt; origin/master
<span style="font-weight: bold">$</span> git merge origin/master
Mise à jour c3f01dc..d0354fc
Avance rapide
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)</code></pre>
</figure>
<p>Si vous revenez maintenant dans le projet principal et lancez <code class="literal">git diff --submodule</code>, vous pouvez remarquer que le sous-module a été mis à jour et vous pouvez obtenir une liste des <em>commits</em> qui y ont été ajoutés.
Si vous ne voulez pas taper <code class="literal">--submodule</code> à chaque fois que vous lancez <code class="literal">git diff</code>, vous pouvez le régler comme format par défaut en positionnant le paramètre de configuration <code class="literal">diff.submodule</code> à la valeur « <code class="literal">log</code> ».</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global diff.submodule log
<span style="font-weight: bold">$</span> git diff
Submodule DbConnector c3f01dc..d0354fc:
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</figure>
<p>Si vous validez à ce moment, vous fixez la version du sous-module à la version actuelle quand d&#8217;autres personnes mettront à jour votre projet.</p>
<p>Il existe aussi un moyen plus facile, si vous préférez ne pas avoir à récupérer et fusionner manuellement les modifications dans le sous-répertoire.
Si vous lancez la commande <code class="literal">git submodule update --remote</code>, Git se rendra dans vos sous-modules et réalisera automatiquement le <code class="literal">fetch</code> et le <code class="literal">merge</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Dépaquetage des objets: 100% (4/4), fait.
Depuis https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -&gt; origin/master
chemin du sous-module &#39;DbConnector&#39;: checked out &#39;d0354fc054692d3906c85c3af05ddce39a1c0644&#39; extrait</code></pre>
</figure>
<p>Cette commande considère par défaut que vous souhaitez mettre à jour la copie locale vers la branche <code class="literal">master</code> du dépôt du sous-module.
Vous pouvez, cependant, indiquer une autre branche.
Par exemple, si le sous-module <code class="literal">DbConnector</code> suit la branche <code class="literal">stable</code> du dépôt amont, vous pouvez l&#8217;indiquer soit dans votre fichier <code class="literal">.gitmodules</code> (pour que tout le monde le suive de même) ou juste dans votre fichier local <code class="literal">.git/config</code>.
Voyons ceci dans le cas du fichier <code class="literal">.gitmodules</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config -f .gitmodules submodule.DbConnector.branch stable

<span style="font-weight: bold">$</span> git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Dépaquetage des objets: 100% (4/4), fait.
Depuis https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -&gt; origin/stable
chemin du sous-module &#39;DbConnector&#39; : &#39;c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687&#39; extrait</code></pre>
</figure>
<p>Si vous ne spécifiez pas la partie <code class="literal">-f .gitmodules</code>, la commande ne fera qu&#8217;une modification locale, mais il semble plus logique d&#8217;inclure cette information dans l&#8217;historique du projet pour que tout le monde soit au diapason.</p>
<p>Quand vous lancez <code class="literal">git status</code>, Git vous montrera que nous avons de nouveaux <em>commits</em> (« <em>new commits</em> ») pour le sous-module.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
Sur la branche master
Votre branche est à jour avec &#39;origin/master&#39;.

Modifications qui ne seront pas validées :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
  (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)

  modifié :   .gitmodules
  modifié :   DbConnector (new commits)

aucune modification n&#39;a été ajoutée à la validation (utilisez &quot;git add&quot; ou &quot;git commit -a&quot;)</code></pre>
</figure>
<p>Si vous activez le paramètre de configuration <code class="literal">status.submodulesummary</code>, Git vous montrera aussi un résumé des modifications dans vos sous-modules :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config status.submodulesummary 1

<span style="font-weight: bold">$</span> git status
Sur la branche master
Votre branche est à jour avec &#39;origin/master&#39;.

Modifications qui ne seront pas validées :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
  (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)

	modifié :   .gitmodules
	modifié :   DbConnector (new commits)

Sous-modules modifiés mais non mis à jour :

* DbConnector c3f01dc...c87d55d (4):
  &gt; catch non-null terminated lines</code></pre>
</figure>
<p>Ici, si vous lancez <code class="literal">git diff</code>, vous pouvez voir que le fichier <code class="literal">.gitmodules</code> a été modifié mais aussi qu&#8217;il y a un certain nombre de <em>commits</em> qui ont été tirés et sont prêts à être validés dans le projet du sous-module.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule &quot;DbConnector&quot;]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</figure>
<p>C&#8217;est une information intéressante car vous pouvez voir le journal des modifications que vous vous apprêtez à valider dans votre sous-module.
Une fois validées, vous pouvez encore visualiser cette information en lançant <code class="literal">git log -p</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule &quot;DbConnector&quot;]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</figure>
<p>Par défaut, Git essaiera de mettre à jour <strong>tous</strong> les sous-modules lors d&#8217;une commande <code class="literal">git submodule update --remote</code>, donc si vous avez de nombreux sous-modules, il est préférable de spécifier le sous-module que vous souhaitez mettre à jour.</p>
</section>
<section class="sect3" title="Travailler sur un sous-module">
<h4 id="_travailler_sur_un_sous_module">Travailler sur un sous-module</h4>
<p>Il y a fort à parier que si vous utilisez des sous-modules, vous le faites parce que vous souhaitez en réalité travailler sur le code du sous-module en même temps que sur celui du projet principal (ou à travers plusieurs sous-modules).
Sinon, vous utiliseriez plutôt un outil de gestion de dépendances plus simple (tel que Maven ou Rubygems).</p>
<p>De ce fait, détaillons un exemple de modifications réalisées dans le sous-module en même temps que dans le projet principal et de validation et de publication des modifications dans le même temps.</p>
<p>Jusqu&#8217;à maintenant, quand nous avons lancé la commande <code class="literal">git submodule update</code> pour récupérer les modifications depuis les dépôts des sous-modules, Git récupérait les modifications et mettait les fichiers locaux à jour mais en laissant le sous-répertoire dans un état appelé « HEAD détachée ».
Cela signifie qu&#8217;il n&#8217;y pas de branche locale de travail (comme <code class="literal">master</code>, par exemple) pour y valider les modifications.
Donc, toutes les modifications que vous y faites ne sont pas suivies non plus.</p>
<p>Pour rendre votre sous-module plus adapté à la modification, vous avez besoin de deux choses.
Vous devez vous rendre dans chaque sous-module et extraire une branche de travail.
Ensuite vous devez dire à Git ce qu&#8217;il doit faire si vous avez réalisé des modifications et que vous lancez <code class="literal">git submodule update --remote</code> pour tirer les modifications amont.
Les options disponibles sont soit de les fusionner dans votre travail local, soit de tenter de rebaser le travail local par dessus les modifications distantes.</p>
<p>En premier, rendons-nous dans le répertoire de notre sous-module et extrayons une branche.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout stable
Basculement sur la branche &#39;stable&#39;</code></pre>
</figure>
<p>Attaquons-nous au choix de politique de gestion.
Pour le spécifier manuellement, nous pouvons simplement ajouter l&#8217;option <code class="literal">--merge</code> à l&#8217;appel de <code class="literal">update</code>.
Nous voyons ici qu&#8217;une modification était disponible sur le serveur pour ce sous-module et qu&#8217;elle a été fusionnée.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Dépaquetage des objets: 100% (4/4), fait.
Depuis https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -&gt; origin/stable
Mise à jour de c87d55d..92c7337
Avance rapide
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
chemin du sous-module &#39;DbConnector&#39;: fusionné dans &#39;92c7337b30ef9e0893e758dac2459d07362ab5ea&#39;</code></pre>
</figure>
<p>Si nous nous rendons dans le répertoire <code class="literal">DbConnector</code>, les nouvelles modifications sont déjà fusionnées dans notre branche locale <code class="literal">stable</code>.
Voyons maintenant ce qui arrive si nous modifions localement la bibliothèque et que quelqu&#8217;un pousse une autre modification en amont dans le même temps.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd DbConnector/
<span style="font-weight: bold">$</span> vim src/db.c
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;unicode support&#39;</span>
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Maintenant, si nous mettons à jour notre sous-module, nous pouvons voir ce qui arrive lors d&#8217;un rebasage de deux modifications concurrentes.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote --rebase
Premièrement, rembobinons head pour rejouer votre travail par-dessus...
Application : unicode support
chemin du sous-module &#39;DbConnector&#39;: rebasé dans &#39;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&#39;</code></pre>
</figure>
<p>Si vous oubliez de spécifier <code class="literal">--rebase</code> ou <code class="literal">--merge</code>, Git mettra juste à jour le sous-module vers ce qui est sur le serveur et réinitialisera votre projet à l&#8217;état « HEAD détachée ».</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote
chemin du sous-module &#39;DbConnector&#39; : &#39;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&#39; extrait</code></pre>
</figure>
<p>Si cela arrive, ne vous inquiétez pas, vous pouvez simplement revenir dans le répertoire et extraire votre branche (qui contiendra encore votre travail) et fusionner ou rebaser <code class="literal">origin/stable</code> (ou la branche distante que vous souhaitez) à la main.</p>
<p>Si vous n&#8217;avez pas validé vos modifications dans votre sous-module, et que vous lancez une mise à jour de sous-module qui causerait des erreurs, Git récupérera les modifications mais n&#8217;écrasera pas le travail non validé dans votre répertoire de sous-module.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Dépaquetage des objets: 100% (4/4), fait.
Depuis https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -&gt; origin/stable
error: Vos modifications locales seraient écrasées par checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Impossible d&#39;extraire &#39;c75e92a2b3855c9e5b66f915308390d9db204aca&#39; dans le chemin du sous-module &#39;DbConnector&#39;</code></pre>
</figure>
<p>Si vous avez réalisé des modifications qui entrent en conflit avec des modifications amont, Git vous en informera quand vous mettrez à jour.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLIT (contenu): Conflit de fusion dans scripts/setup.sh
La fusion automatique a échoué ; réglez les conflits et validez le résultat
Impossible de fusionner &#39;c75e92a2b3855c9e5b66f915308390d9db204aca&#39; dans le chemin du sous-module &#39;DbConnector&#39;</code></pre>
</figure>
<p>Vous pouvez vous rendre dans le répertoire du sous-module et résoudre le conflit normalement.</p>
</section>
<section class="sect3" title="Publier les modifications dans un sous-module">
<h4 id="s_publishing_submodules">Publier les modifications dans un sous-module</h4>
<p>Nous avons donc des modifications dans notre répertoire de sous-module, venant à la fois du dépôt amont et de modifications locales non publiées.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
Submodule DbConnector c87d55d..82d2ad3:
  &gt; Merge from origin/stable
  &gt; updated setup script
  &gt; unicode support
  &gt; remove unnessesary method
  &gt; add new option for conn pooling</code></pre>
</figure>
<p>Si nous validons dans le projet principal et que nous le poussons en amont sans pousser les modifications des sous-modules, les autres personnes qui voudront essayer notre travail vont avoir de gros problèmes vu qu&#8217;elles n&#8217;auront aucun moyen de récupérer les modifications des sous-modules qui en font partie.
Ces modifications n&#8217;existent que dans notre copie locale.</p>
<p>Pour être sur que cela n&#8217;arrive pas, vous pouvez demander à Git de vérifier que tous vos sous-modules ont été correctement poussés avant de pouvoir pousser le projet principal.
La commande <code class="literal">git push</code> accepte un argument <code class="literal">--recurse-submodules</code> qui peut avoir pour valeur « <em>check</em> » ou « <em>on-demand</em> ».
L&#8217;option « check » fera échouer <code class="literal">push</code> si au moins une des modifications des sous-modules n&#8217;a pas été poussée.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.</code></pre>
</figure>
<p>Comme vous pouvez le voir, il donne aussi quelques conseils utiles sur ce que nous pourrions vouloir faire ensuite.
L&#8217;option simple consiste à se rendre dans chaque sous-module et à pousser manuellement sur les dépôts distants pour s&#8217;assurer qu&#8217;ils sont disponibles publiquement, puis de réessayer de pousser le projet principal.</p>
<p>L&#8217;autre option consiste à utiliser la valeur « on-demand » qui essaiera de faire tout ceci pour vous.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push --recurse-submodules=on-demand
Pushing submodule &#39;DbConnector&#39;
Décompte des objets: 9, fait.
Delta compression using up to 8 threads.
Compression des objets: 100% (8/8), fait.
Écriture des objets: 100% (9/9), 917 bytes | 0 bytes/s, fait.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -&gt; stable
Décompte des objets: 2, fait.
Delta compression using up to 8 threads.
Compression des objets: 100% (2/2), fait.
Écriture des objets: 100% (2/2), 266 bytes | 0 bytes/s, fait.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -&gt; master</code></pre>
</figure>
<p>Comme vous pouvez le voir, Git s&#8217;est rendu dans le module <code class="literal">DbConnector</code> et l&#8217;a poussé avant de pousser le projet principal.
Si la poussée du sous-module échoue pour une raison quelconque, la poussée du projet principal sera annulée.</p>
</section>
<section class="sect3" title="Fusion de modifications de sous-modules">
<h4 id="_fusion_de_modifications_de_sous_modules">Fusion de modifications de sous-modules</h4>
<p>Si vous changez la référence d&#8217;un sous-module en même temps qu&#8217;une autre personne, il se peut que cela pose problème.
Particulièrement, si les historiques des sous-modules ont divergé et sont appliqués à des branches divergentes dans un super-projet, rapprocher toutes les modifications peut demander un peu de travail.</p>
<p>Si un des <em>commits</em> est un ancêtre direct d&#8217;un autre (c&#8217;est-à-dire une fusion en avance rapide), alors Git choisira simplement ce dernier pour la fusion et cela se résoudra tout seul.
Cependant, Git ne tentera pas de fusion, même très simple, pour vous.
Si les <em>commits</em> d&#8217;un sous-module divergent et doivent être fusionnés, vous obtiendrez quelque chose qui ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Dépaquetage des objets: 100% (2/2), fait.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -&gt; origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Fusion automatique de DbConnector
CONFLIT (sous-module): Conflit de fusion dans DbConnector
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<p>Donc, ce qui s&#8217;est passé en substance est que Git a découvert que les deux points de fusion des branches à fusionner dans l&#8217;historique du sous-module sont divergents et doivent être fusionnés.
Il l&#8217;explique par « <em>merge following commits not found</em> » (fusion  suivant les <em>commits</em> non trouvée), ce qui n&#8217;est pas clair mais que nous allons expliquer d&#8217;ici peu.</p>
<p>Pour résoudre le problème, vous devez comprendre l&#8217;état dans lequel le sous-module devrait se trouver.
Étrangement, Git ne vous donne pas d&#8217;information utile dans ce cas, pas même les SHA-1 des <em>commits</em> des deux côtés de l&#8217;historique.
Heureusement, c&#8217;est assez facile à comprendre.
Si vous lancez <code class="literal">git diff</code>, vous pouvez obtenir les SHA-1 des <em>commits</em> enregistrés dans chacune des branches que vous essayiez de fusionner.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector</code></pre>
</figure>
<p>Donc, dans ce cas, <code class="literal">eb41d76</code> est le <em>commit</em> dans notre sous-module que <strong>nous</strong> avions et <code class="literal">c771610</code> est le <em>commit</em> amont.
Si nous nous rendons dans le répertoire du sous-module, il devrait déjà être sur <code class="literal">eb41d76</code> parce que la fusion ne l&#8217;a pas touché.
S&#8217;il n&#8217;y est pas, vous pouvez simplement créer et extraire une branche qui pointe dessus.</p>
<p>Ce qui importe, c&#8217;est le SHA-1 du <em>commit</em> venant de l&#8217;autre branche.
C&#8217;est ce que nous aurons à fusionner.
Vous pouvez soit essayer de fusionner avec le SHA-1 directement ou vous pouvez créer une branche à partir du <em>commit</em> puis essayer de la fusionner.
Nous suggérons d&#8217;utiliser cette dernière méthode, ne serait-ce que pour obtenir un message de fusion plus parlant.</p>
<p>Donc, rendons-nous dans le répertoire du sous-module, créons une branche basée sur ce second SHA-1 obtenu avec <code class="literal">git diff</code> et fusionnons manuellement.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd DbConnector

<span style="font-weight: bold">$</span> git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

<span style="font-weight: bold">$</span> git branch try-merge c771610
<span style="font-weight: bold">(DbConnector) $</span> git merge try-merge
Fusion automatique de src/main.c
CONFLIT (contenu): Conflit de fusion dans src/main.c
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<p>Nous avons eu un conflit de fusion ici, donc si nous le résolvons et validons, alors nous pouvons simplement mettre à jour le projet principal avec le résultat.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim src/main.c <i class="conum" data-value="1">①</i>
<span style="font-weight: bold">$</span> git add src/main.c
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;fusion de nos modifications&#39;</span>
[master 9fd905e] fusion de nos modifications

<span style="font-weight: bold">$</span> cd .. <i class="conum" data-value="2">②</i>
<span style="font-weight: bold">$</span> git diff <i class="conum" data-value="3">③</i>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
<span style="font-weight: bold">$</span> git add DbConnector <i class="conum" data-value="4">④</i>

<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&quot;Fusion du travail de Tom&quot;</span> <i class="conum" data-value="5">⑤</i>
[master 10d2c60] Fusion du travail de Tom</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> Nous résolvons le conflit</li>
<li><i class="conum" data-value="2">②</i> Ensuite, nous retournons dans le projet principal</li>
<li><i class="conum" data-value="3">③</i> Nous pouvons revérifier les SHA-1</li>
<li><i class="conum" data-value="4">④</i> Nous résolvons l&#8217;entrée en conflit dans le sous-module</li>
<li><i class="conum" data-value="5">⑤</i> Enfin, nous validons la résolution.</li>
</ol>
</div>
<p>Cela peut paraître compliqué mais ce n&#8217;est pas très difficile.</p>
<p>Curieusement, il existe un autre cas que Git gère seul.
Si un <em>commit</em> de fusion existe dans le répertoire du sous-module qui contient <strong>les deux</strong> <em>commits</em> dans ses ancêtres, Git va le suggérer comme solution possible.
Il voit qu&#8217;à un certain point de l&#8217;historique du projet du sous-module, quelqu&#8217;un a fusionné les branches contenant ces deux <em>commits</em>, donc vous désirerez peut-être utiliser celui-ci.</p>
<p>C&#8217;est pourquoi le message d&#8217;erreur précédent s&#8217;intitulait « <em>merge following commits not found</em> », parce que justement, il ne pouvait pas trouver <strong>le <em>commit</em> de fusion</strong>.
C&#8217;est déroutant car qui s&#8217;attendrait à ce qu&#8217;il <strong>essaie</strong> de le chercher ?</p>
<p>S&#8217;il trouve un seul <em>commit</em> de fusion acceptable, vous verrez ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a &quot;DbConnector&quot;

which will accept this suggestion.
Fusion automatique de DbConnector
CONFLIT (submodule): Conflit de fusion dans DbConnector
La fusion automatique a échoué ; réglez les conflits et validez le résultat.</code></pre>
</figure>
<p>Ce qu&#8217;il suggère de faire est de mettre à jour l&#8217;index comme si vous aviez lancé <code class="literal">git add</code>, ce qui élimine le conflit, puis de valider.
Vous ne devriez cependant pas le faire.
Vous pouvez plus simplement vous rendre dans le répertoire du sous-module, visualiser la différence, avancer en avance rapide sur le <em>commit</em>, le tester puis le valider.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd DbConnector/
<span style="font-weight: bold">$</span> git merge 9fd905e
Mise à jour eb41d76..9fd905e
Avance rapide

<span style="font-weight: bold">$</span> cd ..
<span style="font-weight: bold">$</span> git add DbConnector
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;Avance rapide sur un fils commun dans le sous-module&#39;</span></code></pre>
</figure>
<p>Cela revient au même, mais de cette manière vous pouvez au moins vérifier que ça fonctionne et vous avez le code dans votre répertoire de sous-module quand c&#8217;est terminé.</p>
</section>
</section>
<section class="sect2" title="Trucs et astuces pour les sous-modules">
<h3 id="_trucs_et_astuces_pour_les_sous_modules">Trucs et astuces pour les sous-modules</h3>
<p>Il existe quelques commandes qui permettent de travailler plus facilement avec les sous-modules.</p>
<section class="sect3" title="Submodule foreach">
<h4 id="_submodule_foreach">Submodule foreach</h4>
<p>Il existe une commande submodule <code class="literal">foreach</code> qui permet de lancer une commande arbitraire dans chaque sous-module.
C&#8217;est particulièrement utile si vous avez plusieurs sous-modules dans le même projet.</p>
<p>Par exemple, supposons que nous voulons développer une nouvelle fonctionnalité ou faire un correctif et que nous avons déjà du travail en cours dans plusieurs sous-modules.
Nous pouvons facilement remiser tout le travail en cours dans tous les sous-modules.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule foreach <span style="font-style: italic">&#39;git stash&#39;</span>
Entering &#39;CryptoLibrary&#39;
No local changes to save
Entering &#39;DbConnector&#39;
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable</code></pre>
</figure>
<p>Ensuite, nous pouvons créer une nouvelle branche et y basculer dans tous nos sous-modules.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule foreach <span style="font-style: italic">&#39;git checkout -b featureA&#39;</span>
Entering &#39;CryptoLibrary&#39;
Basculement sur la nouvelle branche &#39;featureA&#39;
Entering &#39;DbConnector&#39;
Basculement sur la nouvelle branche  &#39;featureA&#39;</code></pre>
</figure>
<p>Vous comprenez l&#8217;idée.
Une commande vraiment utile permet de produire un joli diff unifié des modifications dans le projet principal ainsi que dans tous les sous-projets.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff; git submodule foreach <span style="font-style: italic">&#39;git diff&#39;</span>
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering &#39;DbConnector&#39;
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;</code></pre>
</figure>
<p>Ici, nous pouvons voir que nous définissons une fonction dans un sous-module et que nous l&#8217;appelons dans le projet principal.
C&#8217;est un exemple exagérément simplifié, mais qui aide à mieux comprendre l&#8217;utilité de cette commande.</p>
</section>
<section class="sect3" title="Alias utiles">
<h4 id="_alias_utiles">Alias utiles</h4>
<p>Vous pourriez être intéressé de définir quelques alias pour des commandes longues pour lesquelles vous ne pouvez pas régler la configuration par défaut.
Nous avons traité la définition d&#8217;alias Git dans <a id="xref--ch02-git-basics--s_git_aliases" href="ch02-git-basics.xhtml#s_git_aliases" class="xref">Les alias Git</a>, mais voici un exemple d&#8217;alias que vous pourriez trouver utiles si vous voulez travailler sérieusement avec les sous-modules de Git.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config alias.sdiff <span style="font-style: italic">&#39;!&#39;&quot;git diff &amp;&amp; git submodule foreach &#39;git diff&#39;&quot;</span>
<span style="font-weight: bold">$</span> git config alias.spush <span style="font-style: italic">&#39;push --recurse-submodules=on-demand&#39;</span>
<span style="font-weight: bold">$</span> git config alias.supdate <span style="font-style: italic">&#39;submodule update --remote --merge&#39;</span></code></pre>
</figure>
<p>De cette manière, vous pouvez simplement lancer <code class="literal">git supdate</code> lorsque vous souhaitez mettre à jour vos sous-module ou <code class="literal">git spush</code> pour pousser avec une gestion de dépendance de sous-modules.</p>
</section>
</section>
<section class="sect2" title="Les problèmes avec les sous-modules">
<h3 id="_les_problèmes_avec_les_sous_modules">Les problèmes avec les sous-modules</h3>
<p>Cependant, utiliser des sous-modules ne se déroule pas sans accroc.</p>
<p>Commuter des branches qui contiennent des sous-modules peut également s&#8217;avérer difficile.
Si vous créez une nouvelle branche, y ajoutez un sous-module, et revenez ensuite à une branche dépourvue de ce sous-module, vous aurez toujours le répertoire de ce sous-module comme un répertoire non suivi :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b add-crypto
Basculement sur la nouvelle branche &#39;add-crypto&#39;

<span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/CryptoLibrary
Clonage dans &#39;CryptoLibrary&#39;...
...

<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;adding crypto library&#39;</span>
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

<span style="font-weight: bold">$</span> git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Basculement sur la branche &#39;master&#39;
Votre branche est à jour avec &#39;origin/master&#39;.

<span style="font-weight: bold">$</span> git status
Sur la branche master
Votre branche est à jour avec &#39;origin/master&#39;.

Fichiers non suivis :
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour inclure dans ce qui sera validé)

	CryptoLibrary/

aucune modification ajoutée à la validation mais des fichiers non suivis sont présents (utilisez &quot;git add&quot; pour les suivre)</code></pre>
</figure>
<p>Supprimer le répertoire n&#8217;est pas difficile, mais sa présence est assez déroutante.
Si vous le supprimez puis que vous rebasculez sur la branche qui contient le sous-module, vous devrez lancer <code class="literal">submodule update --init</code> pour le repopuler.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -ffdx
Suppression de CryptoLibrary/

<span style="font-weight: bold">$</span> git checkout add-crypto
Basculement sur la branche &#39;add-crypto&#39;

<span style="font-weight: bold">$</span> ls CryptoLibrary/

<span style="font-weight: bold">$</span> git submodule update --init
Submodule path &#39;CryptoLibrary&#39;: checked out &#39;b8dda6aa182ea4464f3f3264b11e0268545172af&#39;

<span style="font-weight: bold">$</span> ls CryptoLibrary/
Makefile	includes	scripts		src</code></pre>
</figure>
<p>Une fois de plus, ce n&#8217;est réellement difficile, mais cela peut être déroutant.</p>
<p>Une autre difficulté commune consiste à basculer de sous-répertoires en sous-modules.
Si vous suiviez des fichiers dans votre projet et que vous voulez les déplacer dans un sous-module, vous devez être très prudent ou Git sera inflexible.
Présumons que vous avez les fichiers dans un sous-répertoire de votre projet, et que vous voulez les transformer en un sous-module.
Si vous supprimez le sous-répertoire et que vous exécutez <code class="literal">submodule add</code>, Git vous hurle dessus avec :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm -Rf CryptoLibrary/
<span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/CryptoLibrary
&#39;CryptoLibrary&#39; already exists in the index</code></pre>
</figure>
<p>Vous devez d&#8217;abord supprimer le répertoire <code class="literal">CryptoLibrary</code> de l&#8217;index.
Vous pourrez ensuite ajouter le sous-module :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm -r CryptoLibrary
<span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into &#39;CryptoLibrary&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</figure>
<p>Maintenant, supposons que vous avez fait cela dans une branche.
Si vous essayez de basculer dans une ancienne branche où ces fichiers sont toujours dans l&#8217;arbre de projet plutôt que comme sous-module, vous aurez cette erreur :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting</code></pre>
</figure>
<p>Vous pouvez le forcer à basculer avec <code class="literal">checkout -f</code>, mais soyez attentif à ce qu&#8217;il soit propre ou les modifications seraient écrasées.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Basculement sur la branche &#39;master&#39;</code></pre>
</figure>
<p>Ensuite, lorsque vous rebasculez, vous aurez un répertoire <code class="literal">CryptoLibrary</code> vide et <code class="literal">git submodule update</code> pourrait ne pas le remettre en état.
Vous allez devoir vous rendre dans le répertoire de votre sous-module et lancer <code class="literal">git checkout .</code> pour retrouver tous vos fichiers.
Vous pouvez lancer ceci dans un script <code class="literal">submodule foreach</code> dans le cas de multiples sous-modules.</p>
<p>Il est important de noter que depuis les versions de Git récentes, les sous-modules conservent leurs données Git dans le répertoire <code class="literal">.git</code> du projet principal, ce qui à la différence des versions antérieures, permet de supprimer le dossier du sous-module sans perdre les <em>commits</em> et les branches qu&#8217;il contenait.</p>
<p>Avec ces outils, les sous-modules peuvent être une méthode assez simple et efficace pour développer simultanément sur des projets connexes mais séparés.</p>
</section>
</section>
<section class="sect1" title="Empaquetage (bundling)">
<h2 id="s_bundling">Empaquetage (<em>bundling</em>)</h2>
<p>Bien que nous ayons déjà abordé les méthodes les plus communes de transfert de données Git par réseau (HTTP, SSH, etc.), il existe en fait une méthode supplémentaire qui n&#8217;est pas beaucoup utilisée mais qui peut s&#8217;avérer utile.</p>
<p>Git est capable d&#8217;empaqueter ses données dans un fichier unique.
Ceci peut servir dans de nombreux scénarios.
Le réseau peut être en panne et vous souhaitez envoyer des modifications à vos collègues.
Peut-être êtes-vous en train de travailler à distance et vous ne pouvez pas vous connecter au réseau local pour des raisons de sécurité.
Peut-être que votre carte réseau ou votre carte wifi vient de tomber en panne.
Peut-être encore n&#8217;avez-vous pas accès à un serveur partagé, et vous souhaitez envoyer à quelqu&#8217;un des mises à jour sans devoir transférer 40 <em>commits</em> via <code class="literal">format-patch</code>.</p>
<p>Ce sont des situations où la commande <code class="literal">git bundle</code> est utile.
La commande <code class="literal">bundle</code> va empaqueter tout ce qui serait normalement poussé sur le réseau avec une commande <code class="literal">git push</code> dans un fichier binaire qui peut être envoyé à quelqu&#8217;un par courriel ou copié sur une clé USB, puis de le dépaqueter dans un autre dépôt.</p>
<p>Voyons un exemple simple.
Supposons que vous avez un dépôt avec deux <em>commits</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit</code></pre>
</figure>
<p>Si vous souhaitez envoyer ce dépôt à quelqu&#8217;un et que vous n&#8217;avez pas accès en poussée à un dépôt, ou que simplement vous ne voulez pas en créer un, vous pouvez l&#8217;empaqueter avec <code class="literal">git bundle create</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle create repo.bundle HEAD master
Décompte des objets: 6, fait.
Delta compression using up to 2 threads.
Compression des objets: 100% (2/2), fait.
Écriture des objets : 100% (6/6), 441 bytes, fait.
Total 6 (delta 0), reused 0 (delta 0)</code></pre>
</figure>
<p>À présent, vous avez un fichier <code class="literal">repo.bundle</code> qui contient toutes les données nécessaires pour recréer la branche <code class="literal">master</code> du dépôt.
Avec la commande <code class="literal">bundle</code>, vous devez lister toutes les références ou les intervalles spécifiques de <em>commits</em> que vous voulez inclure.
Si vous le destinez à être cloné ailleurs, vous devriez aussi ajouter HEAD comme référence, comme nous l&#8217;avons fait.</p>
<p>Vous pouvez envoyer ce fichier <code class="literal">repo.bundle</code> par courriel, ou le copier sur une clé USB et la tendre à un collègue.</p>
<p>De l&#8217;autre côté, supposons qu&#8217;on vous a envoyé ce fichier <code class="literal">repo.bundle</code> et que vous voulez travailler sur le projet.
Vous pouvez cloner le fichier binaire dans un répertoire, de la même manière que vous le feriez pour une URL.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone repo.bundle repo
Initialized empty Git repository in /private/tmp/bundle/repo/.git/
<span style="font-weight: bold">$</span> cd repo
<span style="font-weight: bold">$</span> git log --oneline
9a466c5 second commit
b1ec324 first commit</code></pre>
</figure>
<p>Si vous n&#8217;incluez pas HEAD dans les références, vous devez aussi spécifier <code class="literal">-b master</code> ou n&#8217;importe quelle branche incluse dans le paquet car sinon, il ne saura pas quelle branche extraire.</p>
<p>Maintenant, supposons que vous faites 3 <em>commits</em> et que vous voulez renvoyer ces nouveaux <em>commits</em> via courriel ou clé USB.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit</code></pre>
</figure>
<p>Nous devons déjà déterminer l&#8217;intervalle de <em>commits</em> que nous voulons inclure dans le colis.
À la différence des protocoles réseau qui calculent automatiquement l&#8217;ensemble minimum des données à transférer, nous allons devoir les définir manuellement.
Ici, vous pourriez tout à fait lancer la même commande et empaqueter le dépôt complet, ce qui marcherait mais c&#8217;est mieux de n&#8217;empaqueter que la différence ‑ seulement les 3 <em>commits</em> que nous avons localement créés.</p>
<p>Pour le faire, vous allez devoir calculer la différence.
Comme décrit dans <a id="xref-s_commit_ranges" href="#s_commit_ranges" class="xref">Plages de <em>commits</em></a>, vous pouvez faire référence à un intervalle de <em>commits</em> de différentes manières.
Pour désigner les trois <em>commits</em> que nous avons dans notre branche master et qui n&#8217;était pas dans la branche que nous avons initialement clonée, nous pouvons utiliser quelque chose comme <code class="literal">origin/master..master</code> ou <code class="literal">master ^origin/master</code>.
Vous pouvez tester cela avec la sortie de la commande <code class="literal">log</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo</code></pre>
</figure>
<p>Comme nous avons maintenant la liste des <em>commits</em> que nous voulons inclure dans le colis, empaquetons-les.
Cela est réalisé avec la commande <code class="literal">git bundle create</code>, suivie d&#8217;un nom de fichier et des intervalles des <em>commits</em> que nous souhaitons inclure.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle create commits.bundle master ^9a466c5
Comptage des objets : 11, fait.
Delta compression using up to 2 threads.
Compression des objets : 100% (3/3), fait.
Écriture de objets : 100% (9/9), 775 bytes, fait.
Total 9 (delta 0), reused 0 (delta 0)</code></pre>
</figure>
<p>Nous avons à présent un fichier <code class="literal">commits.bundle</code> dans notre répertoire.
Si nous le prenons et l&#8217;envoyons à un partenaire, il pourra l&#8217;importer dans le dépôt d&#8217;origine, même si du travail a été ajouté entre temps.</p>
<p>Quand il récupère le colis, il peut l&#8217;inspecter pour voir ce qu&#8217;il contient avant de l&#8217;importer dans son dépôt.
La première commande est <code class="literal">bundle verify</code> qui va s&#8217;assurer que le fichier est une fichier bundle Git valide et que le dépôt contient tous les ancêtres nécessaires pour appliquer correctement le colis.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle verify ../commits.bundle
Le colis contient 1 référence :
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
Le colis exige cette référence
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle est correct</code></pre>
</figure>
<p>Si la personne avait créé un colis ne contenant que les deux derniers commits qu&#8217;il avait ajoutés, plutôt que les trois, le dépôt initial n&#8217;aurait pas pu l&#8217;importer, car il aurait manqué un commit dans l&#8217;historique à reconstituer.
La commande <code class="literal">verify</code> aurait ressemblé plutôt à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle verify ../commits-bad.bundle
error: Le dépôt ne dispose pas des commits prérequis suivants :
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</code></pre>
</figure>
<p>Cependant, notre premier colis est valide, et nous pouvons récupérer des <em>commits</em> depuis celui-ci.
Si vous souhaitez voir les branches présentes dans le colis qui peuvent être importées, il y a aussi une commande pour donner la liste des sommets des branches :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master</code></pre>
</figure>
<p>La sous-commande <code class="literal">verify</code> vous indiquera aussi les sommets.
L&#8217;objectif est de voir ce qui peut être tiré, pour que vous puissiez utiliser les commandes <code class="literal">fetch</code> et <code class="literal">pull</code> pour importer des <em>commits</em> depuis le colis.
Ici, nous allons récupérer la branche <code class="literal">master</code> du colis dans une branche appelée <code class="literal">other-master</code> dans notre dépôt :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch ../commits.bundle master:other-master
Depuis ../commits.bundle
 * [nouvelle branche]      master     -&gt; other-master</code></pre>
</figure>
<p>Maintenant, nous pouvons voir que nous avons importé les <em>commits</em> sur la branche <code class="literal">other-master</code> ainsi que tous les <em>commits</em> que nous avons validés entre-temps dans notre propre branche <code class="literal">master</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit</code></pre>
</figure>
<p>Ainsi, <code class="literal">git bundle</code> peut vraiment être utile pour partager du code ou réaliser des opérations nécessitant du réseau quand il n&#8217;y a pas de réseau ou de dépôt partagé.</p>
</section>
<section class="sect1" title="Replace">
<h2 id="s_replace">Replace</h2>
<p>Git manipule des objets immuables mais il fournit un moyen de faire comme s&#8217;il pouvait remplacer des objets de sa base de données par d&#8217;autres objets.</p>
<p>La commande <code class="literal">replace</code> vous permet de spécifier un objet dans Git et de lui indiquer : « chaque fois que tu vois ceci, fais comme si c&#8217;était cette autre chose ».
Ceci sert principalement à remplacer un <em>commit</em> par un autre dans votre historique.</p>
<p>Par exemple, supposons que vous avez un énorme historique de code et que vous souhaitez scinder votre dépôt en un historique court pour les nouveaux développeurs et un plus important et long pour ceux intéressés par des statistiques.
Vous pouvez générer un historique depuis l&#8217;autre avec <code class="literal">replace</code> en remplaçant le <em>commit</em> le plus ancien du nouvel historique par le dernier <em>commit</em> de l&#8217;historique ancien.
C&#8217;est sympa parce que cela signifie que vous n&#8217;avez pas besoin de réécrire tous les <em>commits</em> du nouvel historique, comme vous devriez le faire pour les joindre tous les deux (à cause de l&#8217;effet de lien des SHA-1).</p>
<p>Voyons ce que ça donne.
Prenons un dépôt existant, découpons-le en deux dépôts, un récent et un historique, puis nous verrons comment les recombiner sans modifier les valeurs SHA-1 du dépôt récent, grâce à <code class="literal">replace</code>.</p>
<p>Nous allons utiliser un dépôt simple avec cinq <em>commit</em> simples :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>Nous souhaitons couper ceci en deux lignes d&#8217;historiques.
Une ligne ira de <em>first commit</em> à <em>fourth commit</em> et sera la ligne historique.
La seconde ligne ira de <em>fourth commit</em> à <em>fifth commit</em> et sera ligne récente.</p>
<figure class="image">
<div class="content">
<img src="images/replace1.png" alt="replace1"/>
</div>
</figure>
<p>Bien, la création de la ligne historique est simple, nous n&#8217;avons qu&#8217;à créer une branche dans l&#8217;historique et la pousser vers la branche <code class="literal">master</code> d&#8217;un nouveau dépôt distant.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch history c6e1e95
<span style="font-weight: bold">$</span> git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/replace2.png" alt="replace2"/>
</div>
</figure>
<p>Maintenant, nous pouvons pousser la nouvelle branche <code class="literal">history</code> vers la branche <code class="literal">master</code> du nouveau dépôt :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add project-history https://github.com/schacon/project-history
<span style="font-weight: bold">$</span> git push project-history history:master
Décompte des objets : 12, fait.
Delta compression using up to 2 threads.
Compression des objets : 100% (4/4), fait.
Écriture des objets : 100% (12/12), 907 bytes, fait.
Total 12 (delta 0), reused 0 (delta 0)
Dépaquetage des objets : 100% (12/12), fait.
To git@github.com:schacon/project-history.git
 * [nouvelle branche]      history -&gt; master</code></pre>
</figure>
<p>Bien, notre projet historique est publié.
Maintenant, la partie la plus compliquée consiste à tronquer l&#8217;historique récent pour le raccourcir.
Nous avons besoin d&#8217;un recouvrement pour pouvoir remplacer un <em>commit</em> dans un historique par un équivalent dans l&#8217;autre, donc nous allons tronquer l&#8217;historique à <em>fourth commit</em> et <em>fifth commit</em>, pour que <em>fourth commit</em> soit en recouvrement.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>Il peut être utile de créer un <em>commit</em> de base qui contient les instructions sur la manière d&#8217;étendre l&#8217;historique, de sorte que les autres développeurs puissent savoir comment s&#8217;y prendre s&#8217;ils butent sur le premier <em>commit</em> et ont besoin de plus d&#8217;histoire.
Donc, ce que nous allons faire, c&#8217;est créer un objet <em>commit</em> initial comme base avec les instructions, puis rebaser les <em>commits</em> restants (quatre et cinq) dessus.</p>
<p>Nous avons besoin de choisir un point de découpe, qui pour nous est <em>third commit</em>, soit le SHA-1 <code class="literal">9c68fdc</code>.
Donc, notre <em>commit</em> de base sera créé sur cet arbre.
Nous pouvons créer notre <em>commit</em> de base en utilisant la commande <code class="literal">commit-tree</code>, qui accepte juste un arbre et nous fournit un SHA-1 d&#8217;un objet <em>commit</em> orphelin tout nouveau.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;get history from blah blah blah&#39;</span> | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>La commande <code class="literal">commit-tree</code> fait partie de ce qu&#8217;on appelle les commandes de « plomberie ».
Ce sont des commandes qui ne sont pas destinées à être utilisées directement, mais plutôt au sein d'<strong>autres</strong> commandes Git en tant que petits utilitaires.
Dans les occasions où nous faisons des choses plus bizarres que de coutume comme actuellement, elles nous permettent de faire des actions de bas niveau qui ne sont pas destinées à une utilisation quotidienne.
Pour en savoir plus sur les commandes de plomberie, référez-vous à <a id="xref--ch10-git-internals--s_plumbing_porcelain" href="ch10-git-internals.xhtml#s_plumbing_porcelain" class="xref">Plomberie et porcelaine</a>.</p>
</div>
</aside>
<figure class="image">
<div class="content">
<img src="images/replace3.png" alt="replace3"/>
</div>
</figure>
<p>OK, donc maintenant avec un <em>commit</em> de base, nous pouvons rebaser le reste de notre historique dessus avec la commande <code class="literal">git rebase --onto</code>.
L&#8217;argument <code class="literal">--onto</code> sera l&#8217;empreinte SHA-1 que nous venons tout juste de récupérer avec la commande <code class="literal">commit-tree</code> et le point de rebasage sera <code class="literal">third commit</code> (le parent du premier <em>commit</em> que nous souhaitons garder, <code class="literal">9c68fdc</code>).</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/replace4.png" alt="replace4"/>
</div>
</figure>
<p>Bien, nous avons donc réécrit l&#8217;historique récent à la suite du <em>commit</em> de base qui contient les instructions pour reconstruire l&#8217;historique complet.
Nous pouvons pousser ce nouvel historique vers un nouveau projet et quand des personnes clonent ce dépôt, elles ne voient que les deux <em>commits</em> les plus récents et un <em>commit</em> avec des instructions.</p>
<p>Inversons les rôles et plaçons-nous dans la position d&#8217;une personne qui clone le projet pour la première fois et souhaite obtenir l&#8217;historique complet.
Pour obtenir les données d&#8217;historique après avoir cloné ce dépôt tronqué, on doit ajouter un second dépôt distant pointant vers le dépôt historique et tout récupérer  :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/project
<span style="font-weight: bold">$</span> cd project

<span style="font-weight: bold">$</span> git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

<span style="font-weight: bold">$</span> git remote add project-history https://github.com/schacon/project-history
<span style="font-weight: bold">$</span> git fetch project-history
From https://github.com/schacon/project-history
 * [nouvelle branche]      master     -&gt; project-history/master</code></pre>
</figure>
<p>À présent, le collaborateur aurait les <em>commits</em> récents dans la branche <code class="literal">master</code> et les <em>commits</em> historiques dans la branche <code class="literal">project-history/master</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

<span style="font-weight: bold">$</span> git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>Pour combiner ces deux branches, vous pouvez simplement lancer <code class="literal">git replace</code> avec le <em>commit</em> que vous souhaitez remplacer suivi du <em>commit</em> qui remplacera.
Donc nous voulons remplacer <code class="literal">fourth commit</code> dans la branche <code class="literal">master</code> par <code class="literal">fourth commit</code> de la branche <code class="literal">project-history/master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git replace 81a708d c6e1e95</code></pre>
</figure>
<p>Maintenant, quand on regarde l&#8217;historique de la branche <code class="literal">master</code>, il apparaît comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>Sympa, non ? Sans devoir changer tous les SHA-1 en amont, nous avons pu remplacer un <em>commit</em> dans notre historique avec un autre entièrement différent et tous les outils normaux (<code class="literal">bisect</code>, <code class="literal">blame</code>, etc) fonctionnent de manière transparente.</p>
<figure class="image">
<div class="content">
<img src="images/replace5.png" alt="replace5"/>
</div>
</figure>
<p>Ce qui est intéressant, c&#8217;est que <code class="literal">fourth commit</code> a toujours un SHA-1 de <code class="literal">81a708d</code>, même s&#8217;il utilise en fait les données du <em>commit</em> <code class="literal">c6e1e95</code> par lequel nous l&#8217;avons remplacé.
Même si vous lancez une commande comme <code class="literal">cat-file</code>, il montrera les données remplacées :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon &lt;schacon@gmail.com&gt; 1268712581 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1268712581 -0700

fourth commit</code></pre>
</figure>
<p>Souvenez-vous que le parent réel de <code class="literal">81a708d</code> était notre <em>commit</em> de base (<code class="literal">622e88e</code>) et non <code class="literal">9c68fdce</code> comme indiqué ici.</p>
<p>Une autre chose intéressante est que les données sont conservées dans nos références :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git <span style="font-weight: bold">for</span>-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040</code></pre>
</figure>
<p>Ceci signifie qu&#8217;il est facile de partager notre remplacement avec d&#8217;autres personnes, puisque nous pouvons pousser ceci sur notre serveur et d&#8217;autres personnes pourrons le télécharger.
Ce n&#8217;est pas très utile dans le cas de la reconstruction d&#8217;historique que nous venons de voir (puisque tout le monde téléchargerait quand même les deux historiques, pourquoi alors les séparer ?), mais cela peut être utile dans d&#8217;autres circonstances.</p>
</section>
<section class="sect1" title="Stockage des identifiants">
<h2 id="s_credential_caching">Stockage des identifiants</h2>
<p>

Si vous utilisez le transport SSH pour vous connecter à vos dépôts distants, il est possible d&#8217;avoir une clé sans mot de passe qui permet de transférer des données en sécurité sans devoir entrer un nom d&#8217;utilisateur et un mot de passe.
Cependant, ce n&#8217;est pas possible avec les protocoles HTTP ‑ toute connexion nécessite un nom d&#8217;utilisateur et un mot de passe.
Cela devient même plus difficile avec des systèmes à authentification à deux facteurs, où le mot de passe utilisé est généré dynamiquement au hasard et devient imprononçable.</p>
<p>Heureusement, Git dispose d&#8217;un système de gestion d&#8217;identifiants qui peut faciliter cette gestion.
Git propose de base quelques options :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">Par défaut, rien n&#8217;est mis en cache.
Toutes les connexions vous demanderont votre nom d&#8217;utilisateur et votre mot de passe.</span>
</li>
<li>
<span class="principal">Le mode « cache » conserve en mémoire les identifiants pendant un certain temps.
Aucun mot de passe n&#8217;est stocké sur le disque et les identifiants sont oubliés après 15 minutes.</span>
</li>
<li>
<span class="principal">Le mode « store » sauvegarde les identifiants dans un fichier texte simple sur le disque, et celui-ci n&#8217;expire jamais.
Ceci signifie que tant que vous ne changerez pas votre mot de passe sur le serveur Git, vous n&#8217;aurez plus à entrer votre mot de passe.
Le défaut de cette approche et que vos mots de passe sont stockés en clair dans un fichier texte dans votre répertoire personnel.</span>
</li>
<li>
<span class="principal">Si vous utilisez un Mac, Git propose un mode « osxkeychain », qui met en cache les identifiants dans un trousseau sécurisé attaché à votre compte système.</span>
</li>
<li>
<span class="principal">Si vous utilisez Windows, vous pouvez installer une application appelée « winstore ».
C&#8217;est similaire à l&#8217;assistant « osxkeychain » décrit ci-dessus, mais utilise le <em>Windows Credential Store</em> pour sauvegarder les informations sensibles.
<em>winstore</em> peut être téléchargé à <a href="https://gitcredentialstore.codeplex.com" class="link">https://gitcredentialstore.codeplex.com</a>.</span>
</li>
</ul>
</div>
<p>Vous pouvez choisir une de ces méthodes en paramétrant une valeur de configuration Git :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global credential.helper cache</code></pre>
</figure>
<p>Certains de ces assistants ont des options.
L&#8217;assistant « store » accepte un argument <code class="literal">--file &lt;chemin&gt;</code> qui permet de personnaliser l&#8217;endroit où le fichier texte est sauvegardé (par défaut, c&#8217;est <code class="literal">~/.git-credentials</code>).
L&#8217;assistant <code class="literal">cache</code> accepte une option <code class="literal">--timeout &lt;secondes&gt;</code> qui modifie la période de maintien en mémoire (par défaut, 900, soit 15 minutes).
Voici un exemple de configuration de l&#8217;option « store » avec un nom de fichier personnalisé :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global credential.helper store --file ~/.my-credentials</code></pre>
</figure>
<p>Git vous permet même de configurer plusieurs assistants.
Lors de la recherche d&#8217;identifiants pour un serveur donné, Git les interrogera dans l&#8217;ordre jusqu&#8217;à la première réponse.
Pour la sauvegarde des identifiants, Git enverra le nom d&#8217;utilisateur et le mot de passe à <strong>tous</strong> les assistants et ceux-ci pourront choisir ce qu&#8217;ils en font.
Voici à quoi ressemblerait un <code class="literal">.gitconfig</code> si vous utilisiez un fichier d&#8217;identifiants sur une clé USB mais souhaiteriez utilisez l&#8217;option de cache pour éviter des frappes trop fréquentes si la clé n&#8217;est pas insérée.</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[credential]</span>
    helper = <span style="font-style: italic">store --file /mnt/thumbdrive/.git-credentials</span>
<span style="font-style: italic">    helper = cache --timeout 30000</span></code></pre>
</figure>
<section class="sect2" title="Sous le capot">
<h3 id="_sous_le_capot">Sous le capot</h3>
<p>Comment tout ceci fonctionne-t-il ?
La commande d&#8217;origine de Git pour le système d&#8217;assistants d&#8217;indentification est <code class="literal">git credential</code>, qui accepte une commande comme argument, puis d&#8217;autres informations via stdin.</p>
<p>Un exemple peut aider à mieux comprendre cela.
Supposons qu&#8217;un assistant d&#8217;identification a été configuré et que l&#8217;assistant a stocké les identifiants pour <code class="literal">mygithost</code>.
Voici une session qui utilise la commande « fill » qui est invoquée quand Git essaie de trouver les identifiants pour un hôte :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git credential fill <i class="conum" data-value="1">①</i>
protocol=https <i class="conum" data-value="2">②</i>
host=mygithost
 <i class="conum" data-value="3">③</i>
protocol=https <i class="conum" data-value="4">④</i>
host=mygithost
username=bob
password=s3cre7
<span style="font-weight: bold">$</span> git credential fill <i class="conum" data-value="5">⑤</i>
protocol=https
host=unknownhost

Username for &#39;https://unknownhost&#39;: bob
Password for &#39;https://bob@unknownhost&#39;:
protocol=https
host=unknownhost
username=bob
password=s3cre7</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> C&#8217;est la ligne de commande qui démarre l&#8217;interaction.</li>
<li><i class="conum" data-value="2">②</i> Git-credential attend la saisie d&#8217;informations sur stdin.
Nous lui fournissons les informations que nous connaissons : le protocole et le nom d&#8217;hôte.</li>
<li><i class="conum" data-value="3">③</i> Une ligne vide indique que l&#8217;entrée est complète et le système d&#8217;identification devrait répondre avec les informations qu&#8217;il connaît.</li>
<li><i class="conum" data-value="4">④</i> Git-credential prend alors la main et écrit sur la sortie standard les informations qu&#8217;il a trouvées.</li>
<li><i class="conum" data-value="5">⑤</i> Si aucune information d&#8217;identification n&#8217;a été trouvée, Git demande le nom d&#8217;utilisateur et le mot de passe, et les fournit sur la sortie standard d&#8217;origine (ici elles sont rattachées à la même console).</li>
</ol>
</div>
<p>Le système d&#8217;aide à l&#8217;identification invoque en fait un programme complètement séparé de Git lui-même.
Lequel est invoqué et comment il est invoqué dépendent de la valeur de configuration <code class="literal">credential.helper</code>.
Cette valeur peut prendre plusieurs formes :</p>
<div class="table">
<div class="content">
<table class="table table-framed-topbot table-grid-rows" style="width: 100%">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Valeur de configuration</th>
<th>Comportement</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">foo</code></p></td>
<td><p>lance <code class="literal">git-credential-foo</code></p></td>
</tr>
<tr>
<td><p><code class="literal">foo -a --opt=bcd</code></p></td>
<td><p>lance <code class="literal">git-credential-foo -a --opt=bcd</code></p></td>
</tr>
<tr>
<td><p><code class="literal">/chemin/absolu/foo -xyz</code></p></td>
<td><p>lance <code class="literal">/chemin/absolu/foo -xyz</code></p></td>
</tr>
<tr>
<td><p><code class="literal">!f() { echo "password=s3cre7"; }; f</code></p></td>
<td><p>Le code après <code class="literal">!</code> est évalué dans un shell</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Donc les assistants décrits ci-dessus sont en fait appelés <code class="literal">git-credential-cache</code>, <code class="literal">git-credential-store</code>, et ainsi de suite et nous pouvons les configurer pour accepter des arguments en ligne de commande.</p>
<p>La forme générale pour ceci est <code class="literal">git-credential-foo [args] &lt;action&gt;</code>.
Le protocole stdin/stdout est le même que pour git-credential, mais en utilisant un ensemble d&#8217;actions légèrement différent :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal"><code class="literal">get</code> est une requête pour une paire nom d&#8217;utilisateur/mot de passe.</span>
</li>
<li>
<span class="principal"><code class="literal">store</code> est une requête pour sauvegarder des identifiants dans la mémoire de l&#8217;assistant.</span>
</li>
<li>
<span class="principal"><code class="literal">erase</code> purge de la mémoire de l&#8217;assistant les identifiants répondants aux critères.</span>
</li>
</ul>
</div>
<p>Pour les actions <code class="literal">store</code> et <code class="literal">erase</code>, aucune réponse n&#8217;est exigée (Git les ignore de toute façon).
Pour l&#8217;action <code class="literal">get</code> cependant, Git est très intéressé par ce que l&#8217;assistant peut en dire.
Si l&#8217;assistant n&#8217;a rien à en dire d&#8217;utile, il peut simplement sortir sans rien produire, mais s&#8217;il sait quelque chose, il devrait augmenter l&#8217;information fournie avec celle qu&#8217;il a stockée.
La sortie est traitée comme une série de déclarations d&#8217;affectation ; tout ce qui est fourni remplacera ce que Git connaît déjà.</p>
<p>Voici le même exemple que ci-dessus, mais en sautant git-credential et en s&#8217;attaquant directement à git-credential-store :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git credential-store --file ~/git.store store <i class="conum" data-value="1">①</i>
protocol=https
host=mygithost
username=bob
password=s3cre7
<span style="font-weight: bold">$</span> git credential-store --file ~/git.store get <i class="conum" data-value="2">②</i>
protocol=https
host=mygithost

username=bob <i class="conum" data-value="3">③</i>
password=s3cre7</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> Ici nous indiquons à <code class="literal">git-credential-store</code> de sauvegarder des identifiants : le nom d&#8217;utilisateur (<em>username</em>) « bob » et le mot de passe (<em>password</em>) « s3cre7 » doivent être utilisés quand <code class="literal">https://mygithost</code> est accédé.</li>
<li><i class="conum" data-value="2">②</i> Maintenant, nous allons récupérer ces identifiants.
Nous fournissons les parties de l&#8217;information de connexion que nous connaissons (<code class="literal">https://mygithost</code>), suivi d&#8217;une ligne vide.</li>
<li><i class="conum" data-value="3">③</i> <code class="literal">git-credential-store</code> répond avec le nom d&#8217;utilisateur et le mot de passe que nous avons précédemment stockés.</li>
</ol>
</div>
<p>Voici à quoi ressemble le fichier <code class="literal">~/git.store</code> :</p>
<figure class="listing">
<pre class="source language-"><code>https://bob:s3cre7@mygithost</code></pre>
</figure>
<p>C&#8217;est juste une série de lignes, chacune contenant des URLs contenant les informations d&#8217;identification.
Les assistants <code class="literal">osxkeychain</code> et <code class="literal">winstore</code> utilisent le format natif de leurs banques de stockage, tandis que <code class="literal">cache</code> utilise son propre format en mémoire (qu&#8217;aucun autre processus ne peut lire).</p>
</section>
<section class="sect2" title="Un cache d&#8217;identifiants personnalisé">
<h3 id="_un_cache_d_identifiants_personnalisé">Un cache d&#8217;identifiants personnalisé</h3>
<p>Étant donné que <code class="literal">git-credential-store</code> et consort sont des programmes séparés de Git, il y a peu à penser que <em>n&#8217;importe quel</em> programme peut être un assistant d&#8217;identification Git.
Les assistants fournis par Git gèrent de nombreux cas d&#8217;utilisation habituels, mais pas tous.
Par exemple, supposons que votre équipe dispose de certains identifiants qui sont partagés par tous, pour le déploiement.
Ils sont stockés dans un répertoire partagé, mais vous ne les copiez pas dans votre propre magasin d&#8217;identifiants parce qu&#8217;ils changent souvent.
Aucun assistant existant ne gère ce cas ; voyons ce qu&#8217;il faudrait pour écrire le nôtre.
Ce programme doit présenter certaines fonctionnalités clé :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">La seule action à laquelle nous devons répondre est <code class="literal">get</code> ; <code class="literal">store</code> et <code class="literal">erase</code> sont des opérations d&#8217;écriture, donc nous sortirons directement et proprement dans ces cas.</span>
</li>
<li>
<span class="principal">Le format du fichier d&#8217;identifiants partagés est identique à celui utilisé par <code class="literal">git-credential-store</code>.</span>
</li>
<li>
<span class="principal">L&#8217;emplacement de ce fichier est assez standard, mais nous devrions pouvoir laisser l&#8217;utilisateur spécifier une chemin en cas de besoin.</span>
</li>
</ol>
</div>
<p>Une fois de plus, nous écrirons cette extension en Ruby, mais n&#8217;importe quel langage fonctionnera, tant que Git peut lancer un exécutable à la fin.
Voici le code source complet de ce nouvel assistant d&#8217;identification :</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

require <span style="font-style: italic">&#39;optparse&#39;</span>

path = File.expand_path <span style="font-style: italic">&#39;~/.git-credentials&#39;</span> <i class="conum" data-value="1">①</i>
OptionParser.new <span style="font-weight: bold">do</span> |opts|
    opts.banner = <span style="font-style: italic">&#39;USAGE: git-credential-read-only [options] &lt;action&gt;&#39;</span>
    opts.on(<span style="font-style: italic">&#39;-f&#39;</span>, <span style="font-style: italic">&#39;--file PATH&#39;</span>, <span style="font-style: italic">&#39;Specify path for backing store&#39;</span>) <span style="font-weight: bold">do</span> |argpath|
        path = File.expand_path argpath
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>.parse!

exit(0) <span style="font-weight: bold">unless</span> ARGV[0].downcase == <span style="font-style: italic">&#39;get&#39;</span> <i class="conum" data-value="2">②</i>
exit(0) <span style="font-weight: bold">unless</span> File.exists? path

known = {} <i class="conum" data-value="3">③</i>
<span style="font-weight: bold">while</span> line = STDIN.gets
    <span style="font-weight: bold">break</span> <span style="font-weight: bold">if</span> line.strip == <span style="font-style: italic">&#39;&#39;</span>
    k,v = line.strip.split <span style="font-style: italic">&#39;=&#39;</span>, 2
    known[k] = v
<span style="font-weight: bold">end</span>

File.readlines(path).each <span style="font-weight: bold">do</span> |fileline| <i class="conum" data-value="4">④</i>
    prot,user,pass,host = fileline.scan(<span style="font-style: italic">/^(.*?):\/\/(.*?):(.*?)@(.*)$/</span>).first
    <span style="font-weight: bold">if</span> prot == known[<span style="font-style: italic">&#39;protocol&#39;</span>] <span style="font-weight: bold">and</span> host == known[<span style="font-style: italic">&#39;host&#39;</span>] <span style="font-weight: bold">then</span>
        puts <span style="font-style: italic">&quot;protocol=</span><span style="font-weight: bold; font-style: italic">#{</span>prot<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        puts <span style="font-style: italic">&quot;host=</span><span style="font-weight: bold; font-style: italic">#{</span>host<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        puts <span style="font-style: italic">&quot;username=</span><span style="font-weight: bold; font-style: italic">#{</span>user<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        puts <span style="font-style: italic">&quot;password=</span><span style="font-weight: bold; font-style: italic">#{</span>pass<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        exit(0)
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> Ici, nous analysons les options de la ligne de commande, pour permettre à l&#8217;utilisateur de spécifier un fichier. Par défaut, c&#8217;est <code class="literal">~/.git-credentials</code>.</li>
<li><i class="conum" data-value="2">②</i> Ce programme ne répondra que si l&#8217;action est <code class="literal">get</code> et si le fichier magasin existe.</li>
<li><i class="conum" data-value="3">③</i> Cette boucle lit depuis stdin jusqu&#8217;à la première ligne vide.
Les entrées sont stockées dans le <em>hash</em> <code class="literal">known</code> pour référence ultérieure.</li>
<li><i class="conum" data-value="4">④</i> Cette boucle lit le contenu du fichier magasin, et recherche les correspondances.
Si le protocole et l&#8217;hôte depuis <code class="literal">known</code> correspondent à la ligne, le programme imprime les résultats sur stdout et sort.</li>
</ol>
</div>
<p>Nous allons sauvegarder notre assistant comme <code class="literal">git-credential-read-only</code>, le placer quelque part dans notre <code class="literal">PATH</code> et le marquer exécutable.
Voici à quoi ressemble une session interactive :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7</code></pre>
</figure>
<p>Puisque son nom commence par <code class="literal">git-</code>, nous pouvons utiliser une syntaxe simple pour la valeur de configuration :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global credential.helper read-only --file /mnt/shared/creds</code></pre>
</figure>
<p>Comme vous pouvez le voir, étendre ce système est plutôt direct et peut résoudre des problèmes communs pour vous et votre équipe.</p>
</section>
</section>
<section class="sect1" title="Résumé">
<h2 id="_résumé_2">Résumé</h2>
<p>Vous venez de voir certains des outils avancés vous permettant de manipuler vos <em>commits</em> et votre index plus précisément.
Lorsque vous remarquez des bogues, vous devriez être capable de trouver facilement quelle validation les a introduits, quand et par qui.
Si vous voulez utiliser des sous-projets dans votre projet, vous avez appris plusieurs façons de les gérer.
À partir de maintenant, vous devez être capable de faire la plupart de ce dont vous avez besoin avec Git en ligne de commande et de vous y sentir à l&#8217;aise.</p>
</section>
</section>
</body>
</html>