<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
<meta charset="UTF-8"/>
<title>Les branches avec Git</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Les branches avec Git" epub:type="chapter" id="ch03-git-branching">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Les</b> <b>branches</b> <b>avec</b> <b>Git</b></small></h1>
</div>
</header>
<p>
Presque tous les VCS proposent une certaine forme de gestion de branches.
Créer une branche signifie diverger de la ligne principale de développement et continuer à travailler sans impacter cette ligne.
Pour de nombreux VCS, il s&#8217;agit d&#8217;un processus coûteux qui nécessite souvent la création d&#8217;une nouvelle copie du répertoire de travail, ce qui peut prendre longtemps dans le cas de gros projets.</p>
<p>Certaines personnes considèrent le modèle de gestion de branches de Git comme ce qu&#8217;il a de plus remarquable et il offre sûrement à Git une place à part au sein de la communauté des VCS.
En quoi est-il si spécial ?
La manière dont Git gère les branches est incroyablement légère et permet de réaliser les opérations sur les branches de manière quasi instantanée et, généralement, de basculer entre les branches aussi rapidement.
À la différence de nombreux autres VCS, Git encourage des méthodes qui privilégient la création et la fusion fréquentes de branches, jusqu&#8217;à plusieurs fois par jour.
Bien comprendre et maîtriser cette fonctionnalité vous permettra de faire de Git un outil puissant et unique et peut totalement changer votre manière de développer.</p>
<section class="sect1" title="Les branches en bref">
<h2 id="s_git_branches_overview">Les branches en bref</h2>
<p>Pour réellement comprendre la manière dont Git gère les branches, nous devons revenir en arrière et examiner de plus près comment Git stocke ses données.
Si vous vous souvenez bien du chapitre <a id="xref--ch01-introduction" href="ch01-introduction.xhtml" class="xref">Démarrage rapide</a>, Git ne stocke pas ses données comme une série de modifications ou de différences successives mais plutôt comme une série d&#8217;instantanés (appelés <em>snapshots</em>).</p>
<p>Lorsque vous faites un commit, Git stocke un objet <em>commit</em> qui contient un pointeur vers l&#8217;instantané (<em>snapshot</em>) du contenu que vous avez indexé.
Cet objet contient également les noms et prénoms de l&#8217;auteur, le message que vous avez renseigné ainsi que des pointeurs vers le ou les <em>commits</em> qui précèdent directement ce <em>commit</em> : aucun parent pour le <em>commit</em> initial, un parent pour un <em>commit</em> normal et de multiples parents pour un <em>commit</em> qui résulte de la fusion d&#8217;une ou plusieurs branches.</p>
<p>Pour visualiser ce concept, supposons que vous avez un répertoire contenant trois fichiers que vous indexez puis validez.
L&#8217;indexation des fichiers calcule une empreinte (<em>checksum</em>) pour chacun (via la fonction de hachage SHA-1 mentionnée au chapitre <a href="ch01-introduction.xhtml" class="xref">Démarrage rapide</a>), stocke cette version du fichier dans le dépôt Git (Git les nomme <em>blobs</em>) et ajoute cette empreinte à la zone d&#8217;index (<em>staging area</em>) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add README test.rb LICENSE
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial commit of my project&#39;</span></code></pre>
</figure>
<p>Lorsque vous créez le <em>commit</em> en lançant la commande <code class="literal">git commit</code>, Git calcule l&#8217;empreinte de chaque sous-répertoire (ici, seulement pour le répertoire racine) et stocke ces objets de type arbre dans le dépôt Git.
Git crée alors un objet <em>commit</em> qui contient les méta-données et un pointeur vers l&#8217;arbre de la racine du projet de manière à pouvoir recréer l&#8217;instantané à tout moment.</p>
<p>Votre dépôt Git contient à présent cinq objets :
un <em>blob</em> pour le contenu de chacun de vos trois fichiers, un arbre (<em>tree</em>) qui liste le contenu du répertoire et spécifie quels noms de fichiers sont attachés à quels <em>blobs</em> et enfin un objet <em>commit</em> portant le pointeur vers l&#8217;arbre de la racine ainsi que toutes les méta-données attachées au <em>commit</em>.</p>
<figure class="image">
<div class="content">
<img src="images/commit-and-tree.png" alt="Un commit et son arbre."/>
</div>
<figcaption>Figure 1. Un commit et son arbre</figcaption>
</figure>
<p>Si vous faites des modifications et validez à nouveau, le prochain <em>commit</em> stocke un pointeur vers le <em>commit</em> le précédant immédiatement.</p>
<figure class="image">
<div class="content">
<img src="images/commits-and-parents.png" alt="Commits et leurs parents."/>
</div>
<figcaption>Figure 2. Commits et leurs parents</figcaption>
</figure>
<p>Une branche dans Git est simplement un pointeur léger et déplaçable vers un de ces <em>commits</em>.
La branche par défaut dans Git s&#8217;appelle <code class="literal">master</code>.
Au fur et à mesure des validations, la branche <code class="literal">master</code> pointe vers le dernier des <em>commits</em> réalisés.
À chaque validation, le pointeur de la branche <code class="literal">master</code> avance automatiquement.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>La branche ``master`` n&#8217;est pas une branche spéciale.
Elle est identique à toutes les autres branches.
La seule raison pour laquelle chaque dépôt en a une est que la commande <code class="literal">git init</code> la crée par défaut et que la plupart des gens ne s&#8217;embêtent pas à la changer.</p>
</div>
</aside>
<figure class="image">
<div class="content">
<img src="images/branch-and-history.png" alt="Une branche et l'historique de ses _commits_."/>
</div>
<figcaption>Figure 3. Une branche et l&#8217;historique de ses <em>commits</em></figcaption>
</figure>
<section class="sect2" title="Créer une nouvelle branche">
<h3 id="s_create_new_branch">Créer une nouvelle branche</h3>
<p>
Que se passe-t-il si vous créez une nouvelle branche ?
Eh bien, cela crée un nouveau pointeur pour vous.
Supposons que vous créez une nouvelle branche nommée <code class="literal">test</code>.
Vous utilisez pour cela la commande <code class="literal">git branch</code> : </p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch testing</code></pre>
</figure>
<p>Cela crée un nouveau pointeur vers le <em>commit</em> courant.</p>
<figure class="image">
<div class="content">
<img src="images/two-branches.png" alt="Deux branches pointant vers la même série de _commits_."/>
</div>
<figcaption>Figure 4. Deux branches pointant vers la même série de <em>commits</em></figcaption>
</figure>
<p>Comment Git connaît-il alors la branche sur laquelle vous vous trouvez ?
Il conserve à cet effet un pointeur spécial appelé <code class="literal">HEAD</code>.
Vous remarquez que sous cette appellation se cache un concept très différent de celui utilisé dans les autres VCS tels que Subversion ou CVS.
Dans Git, il s&#8217;agit simplement d&#8217;un pointeur sur la branche locale où vous vous trouvez.
Dans ce cas, vous vous trouvez toujours sur <code class="literal">master</code>.
En effet, la commande <code class="literal">git branch</code> n&#8217;a fait que créer une nouvelle branche — elle n&#8217;a pas fait basculer la copie de travail vers cette branche.</p>
<figure class="image">
<div class="content">
<img src="images/head-to-master.png" alt="HEAD pointant vers une branche."/>
</div>
<figcaption>Figure 5. HEAD pointant vers une branche</figcaption>
</figure>
<p>Vous pouvez vérifier cela facilement grâce à la commande <code class="literal">git log</code> qui vous montre vers quoi les branches pointent. Il s&#8217;agit de l&#8217;option <code class="literal">--decorate</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --decorate
f30ab (HEAD, master, test) add feature #32 - ability to add new
34ac2 fixed bug #ch1328 - stack overflow under certain conditions
98ca9 initial commit of my project</code></pre>
</figure>
<p>Vous pouvez voir les branches ``master``  et ``test`` qui se situent au niveau du <em>commit</em> <code class="literal">f30ab</code>.</p>
</section>
<section class="sect2" title="Basculer entre les branches">
<h3 id="s_switching_branches">Basculer entre les branches</h3>
<p>
Pour basculer sur une branche existante, il suffit de lancer la commande <code class="literal">git checkout</code>.
Basculons sur la nouvelle branche <code class="literal">testing</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout testing</code></pre>
</figure>
<p>Cela déplace <code class="literal">HEAD</code> pour le faire pointer vers la branche <code class="literal">testing</code>.</p>
<figure class="image">
<div class="content">
<img src="images/head-to-testing.png" alt="HEAD pointe vers la branche courante."/>
</div>
<figcaption>Figure 6. HEAD pointe vers la branche courante</figcaption>
</figure>
<p>Qu&#8217;est-ce que cela signifie ?
Et bien, faisons une autre validation :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim test.rb
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;made a change&#39;</span></code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/advance-testing.png" alt="La branche HEAD avance à chaque _commit_."/>
</div>
<figcaption>Figure 7. La branche HEAD avance à chaque <em>commit</em></figcaption>
</figure>
<p>C&#8217;est intéressant parce qu&#8217;à présent, votre branche <code class="literal">test</code> a avancé tandis que la branche <code class="literal">master</code> pointe toujours sur le <em>commit</em> sur lequel vous étiez lorsque vous avez lancé la commande <code class="literal">git checkout</code> pour changer de branche.
Retournons sur la branche <code class="literal">master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/checkout-master.png" alt="HEAD est déplacé lors d'un _checkout_."/>
</div>
<figcaption>Figure 8. HEAD est déplacé lors d&#8217;un <em>checkout</em></figcaption>
</figure>
<p>Cette commande a réalisé deux actions.
Elle a remis le pointeur <code class="literal">HEAD</code> sur la branche <code class="literal">master</code> et elle a replacé les fichiers de votre répertoire de travail dans l&#8217;état du <em>snapshot</em> pointé par <code class="literal">master</code>.
Cela signifie aussi que les modifications que vous réalisez à partir de ce point divergeront de l&#8217;ancienne version du projet.
Cette commande annule les modifications réalisées dans la branche <code class="literal">test</code> pour vous permettre de repartir dans une autre direction.</p>
<aside class="admonition note" title="Note: Changer de branche modifie les fichiers dans votre répertoire de travail" epub:type="note">
<h2>Changer de branche modifie les fichiers dans votre répertoire de travail</h2>
<div class="content">
<p>Il est important de noter que lorsque vous changez de branche avec Git, les fichiers de votre répertoire de travail sont modifiés.
Si vous basculez vers une branche plus ancienne, votre répertoire de travail sera remis dans l&#8217;état dans lequel il était lors du dernier <em>commit</em> sur cette branche.
Si git n&#8217;est pas en mesure d&#8217;effectuer cette action proprement, il ne vous laissera pas changer de branche.</p>
</div>
</aside>
<p>Réalisons quelques autres modifications et validons à nouveau :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim test.rb
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;made other changes&#39;</span></code></pre>
</figure>
<p>Maintenant, l&#8217;historique du projet a divergé (voir <a id="xref-divergent_history" href="#divergent_history" class="xref">Divergence d&#8217;historique</a>).
Vous avez créé une branche et basculé dessus, y avez réalisé des modifications, puis vous avez rebasculé sur la branche principale et réalisé d&#8217;autres modifications.
Ces deux modifications sont isolées dans des branches séparées : vous pouvez basculer d&#8217;une branche à l&#8217;autre et les fusionner quand vous êtes prêt.
Et vous avez fait tout ceci avec de simples commandes : <code class="literal">branch</code>, <code class="literal">checkout</code> et <code class="literal">commit</code>.</p>
<figure id="divergent_history" class="image">
<div class="content">
<img src="images/advance-master.png" alt="Divergence d'historique."/>
</div>
<figcaption>Figure 9. Divergence d&#8217;historique</figcaption>
</figure>
<p>Vous pouvez également voir ceci grâce à la commande <code class="literal">git log</code>.
La commande <code class="literal">git log --oneline --decorate --graph --all</code> va afficher l&#8217;historique de vos <em>commits</em>, affichant les endroits où sont positionnés vos pointeurs de branche ainsi que la manière dont votre historique a divergé.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (test) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #ch1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project</code></pre>
</figure>
<p>Parce qu&#8217;une branche Git n&#8217;est en fait qu&#8217;un simple fichier contenant les 40 caractères de l&#8217;empreinte SHA-1 du <em>commit</em> sur lequel elle pointe, les branches ne coûtent quasiment rien à créer et à détruire.
Créer une branche est aussi simple et rapide qu&#8217;écrire 41 caractères dans un fichier (40 caractères plus un retour chariot).</p>
<p>C&#8217;est une différence de taille avec la manière dont la plupart des VCS gèrent les branches, qui implique de copier tous les fichiers du projet dans un second répertoire.
Cela peut durer plusieurs secondes ou même quelques minutes selon la taille du projet, alors que pour Git, le processus est toujours instantané.
De plus, comme nous enregistrons les parents quand nous validons les modifications, la détermination de l&#8217;ancêtre commun approprié pour la fusion est réalisée automatiquement pour nous et est généralement une opération très facile.
Ces fonctionnalités encouragent naturellement les développeurs à créer et utiliser souvent des branches.</p>
<p>Voyons pourquoi vous devriez en faire autant.</p>
</section>
</section>
<section class="sect1" title="Branches et fusions : les bases">
<h2 id="_branches_et_fusions_les_bases">Branches et fusions : les bases</h2>
<p>Prenons un exemple simple faisant intervenir des branches et des fusions (<em>merges</em>) que vous pourriez trouver dans le monde réel.
Vous effectuez les tâches suivantes :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">vous travaillez sur un site web ;</span>
</li>
<li>
<span class="principal">vous créez une branche pour un nouvel article en cours ;</span>
</li>
<li>
<span class="principal">vous commencez à travailler sur cette branche.</span>
</li>
</ol>
</div>
<p>À cette étape, vous recevez un appel pour vous dire qu&#8217;un problème critique a été découvert et qu&#8217;il faut le régler au plus tôt.
Vous faites donc ce qui suit :</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">vous basculez sur la branche de production ;</span>
</li>
<li>
<span class="principal">vous créez une branche pour y ajouter le correctif ;</span>
</li>
<li>
<span class="principal">après l&#8217;avoir testé, vous fusionnez la branche du correctif et poussez le résultat en production ;</span>
</li>
<li>
<span class="principal">vous rebasculez sur la branche initiale et continuez votre travail.</span>
</li>
</ol>
</div>
<section class="sect2" title="Branches">
<h3 id="s_basic_branching">Branches</h3>
<p>
Commençons par supposer que vous travaillez sur votre projet et avez déjà quelques <em>commits</em>.</p>
<figure class="image">
<div class="content">
<img src="images/basic-branching-1.png" alt="Historique de _commits_ simple."/>
</div>
<figcaption>Figure 10. Historique de <em>commits</em> simple</figcaption>
</figure>
<p>Vous avez décidé de travailler sur le problème numéroté #53 dans l&#8217;outil de gestion des tâches que votre entreprise utilise, quel qu&#8217;il soit.
Pour créer une branche et y basculer tout de suite, vous pouvez lancer la commande <code class="literal">git checkout</code> avec l&#8217;option <code class="literal">-b</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b iss53
Switched to a new branch &quot;iss53&quot;</code></pre>
</figure>
<p>Cette commande est un raccourci pour :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch iss53
<span style="font-weight: bold">$</span> git checkout iss53</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/basic-branching-2.png" alt="Création d'un nouveau pointeur de branche."/>
</div>
<figcaption>Figure 11. Création d&#8217;un nouveau pointeur de branche</figcaption>
</figure>
<p>Vous travaillez sur votre site web et validez vos modifications.
Ce faisant, la branche <code class="literal">iss53</code> avance parce que vous l&#8217;avez extraite (c&#8217;est-à-dire que votre pointeur <code class="literal">HEAD</code> pointe dessus) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim index.html
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&quot;ajout d&#39;un pied de page [problème 53]&quot;</span></code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/basic-branching-3.png" alt="La branche iss53 a avancé avec votre travail."/>
</div>
<figcaption>Figure 12. La branche iss53 a avancé avec votre travail</figcaption>
</figure>
<p>À ce moment-là, vous recevez un appel qui vous apprend qu&#8217;il y a un problème sur le site web qu&#8217;il faut résoudre immédiatement.
Avec Git, vous n&#8217;avez pas à déployer en même temps votre correctif et les modifications déjà validées pour <code class="literal">iss53</code> et vous n&#8217;avez pas non plus à vous fatiguer à annuler ces modifications avant de pouvoir appliquer votre correctif sur ce qu&#8217;il y a en production.
Tout ce que vous avez à faire, c&#8217;est simplement de rebasculer sur la branche <code class="literal">master</code>.</p>
<p>Cependant, avant de le faire, notez que si votre copie de travail ou votre zone d&#8217;index contiennent des modifications non validées qui sont en conflit avec la branche que vous extrayez, Git ne vous laissera pas changer de branche.
Le mieux est d&#8217;avoir votre copie de travail propre au moment de changer de branche.
Il y a des moyens de contourner ceci (précisément par le remisage et l&#8217;amendement de <em>commit</em>) dont nous parlerons plus loin, au chapitre <a id="xref--ch07-git-tools--s_git_stashing" href="ch07-git-tools.xhtml#s_git_stashing" class="xref">Remisage et nettoyage</a>.
Pour l&#8217;instant, nous supposons que vous avez validé tous vos changements et que vous pouvez donc rebasculer vers votre branche <code class="literal">master</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
Switched to branch &#39;master&#39;</code></pre>
</figure>
<p>À cet instant, votre répertoire de copie de travail est exactement dans l&#8217;état dans lequel vous l&#8217;aviez laissé avant de commencer à travailler sur le problème #53 et vous pouvez vous consacrer à votre correctif.
C&#8217;est un point important à garder en mémoire : quand vous changez de branche, Git réinitialise votre répertoire de travail pour qu&#8217;il soit le même que la dernière fois que vous avez effectué un <em>commit</em> sur cette branche.
Il ajoute, retire et modifie automatiquement les fichiers de manière à s&#8217;assurer que votre copie de travail soit identique à ce qu&#8217;elle était lors de votre dernier <em>commit</em> sur cette branche.</p>
<p>Vous avez ensuite un correctif à faire.
Pour ce faire, créons une branche <code class="literal">correctif</code> sur laquelle travailler jusqu&#8217;à résolution du problème :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b correctif
Switched to a new branch &#39;correctif&#39;
<span style="font-weight: bold">$</span> vim index.html
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&quot;correction de l&#39;adresse email incorrecte&quot;</span>
[correctif 1fb7853] &quot;correction de l&#39;adresse email incorrecte&quot;
 1 file changed, 2 insertions(+)</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/basic-branching-4.png" alt="Branche de correctif basée sur `master`."/>
</div>
<figcaption>Figure 13. Branche de correctif basée sur <code class="literal">master</code></figcaption>
</figure>
<p>Vous pouvez lancer vos tests, vous assurer que la correction est efficace et la fusionner dans la branche <code class="literal">master</code> pour la déployer en production.
Vous réalisez ceci au moyen de la commande <code class="literal">git merge</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git merge correctif
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</figure>
<p>Vous noterez la mention <code class="literal">fast-forward</code> lors de cette fusion (<em>merge</em>).
Comme le <em>commit</em> <code class="literal">C4</code> pointé par la branche <code class="literal">hotfix</code> que vous avez fusionnée était directement devant le <em>commit</em> <code class="literal">C2</code> sur lequel vous vous trouvez, Git a simplement déplacé le pointeur (vers l&#8217;avant).
Autrement dit, lorsque l&#8217;on cherche à fusionner un <em>commit</em> qui peut être atteint en parcourant l&#8217;historique depuis le <em>commit</em> d&#8217;origine, Git se contente d&#8217;avancer le pointeur car il n&#8217;y a pas de travaux divergents à fusionner — ceci s&#8217;appelle un <code class="literal">fast-forward</code> (avance rapide).</p>
<p>Votre modification est maintenant dans l&#8217;instantané (<em>snapshot</em>) du <em>commit</em> pointé par la branche <code class="literal">master</code> et vous pouvez déployer votre correctif.</p>
<figure class="image">
<div class="content">
<img src="images/basic-branching-5.png" alt="Avancement du pointeur de `master` sur `correctif`."/>
</div>
<figcaption>Figure 14. Avancement du pointeur de <code class="literal">master</code> sur <code class="literal">correctif</code></figcaption>
</figure>
<p>Après le déploiement de votre correctif super-important, vous voilà prêt à retourner travailler sur le sujet qui vous occupait avant l&#8217;interruption.
Cependant, vous allez avant cela effacer la branche <code class="literal">correctif</code> dont vous n&#8217;avez plus besoin puisque la branche <code class="literal">master</code> pointe au même endroit.
Vous pouvez l&#8217;effacer avec l&#8217;option <code class="literal">-d</code> de la commande <code class="literal">git branch</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -d correctif
Deleted branch correctif (3a0874c).</code></pre>
</figure>
<p>Maintenant, vous pouvez retourner travailler sur la branche qui contient vos travaux en cours pour le problème #53 :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout iss53
Switched to branch &quot;iss53&quot;
<span style="font-weight: bold">$</span> vim index.html
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;Nouveau pied de page terminé [issue 53]&#39;</span>
[iss53 ad82d7a] Nouveau pied de page terminé [issue 53]
1 file changed, 1 insertion(+)</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/basic-branching-6.png" alt="Le travail continue sur `iss53`."/>
</div>
<figcaption>Figure 15. Le travail continue sur <code class="literal">iss53</code></figcaption>
</figure>
<p>Il est utile de noter que le travail réalisé dans la branche <code class="literal">correctif</code> n&#8217;est pas contenu dans les fichiers de la branche <code class="literal">iss53</code>.
Si vous avez besoin de les y rapatrier, vous pouvez fusionner la branche <code class="literal">master</code> dans la branche <code class="literal">iss53</code> en lançant la commande <code class="literal">git merge master</code>, ou vous pouvez retarder l&#8217;intégration de ces modifications jusqu&#8217;à ce que vous décidiez plus tard de rapatrier la branche <code class="literal">iss53</code> dans <code class="literal">master</code>.</p>
</section>
<section class="sect2" title="Fusions (Merges)">
<h3 id="s_basic_merging">Fusions (<em>Merges</em>)</h3>
<p>Supposons que vous ayez décidé que le travail sur le problème #53 était terminé et prêt à être fusionné dans la branche <code class="literal">master</code>.
Pour ce faire, vous allez fusionner votre branche <code class="literal">iss53</code> de la même manière que vous l&#8217;avez fait plus tôt pour la branche <code class="literal">correctif</code>.
Tout ce que vous avez à faire est d&#8217;extraire la branche dans laquelle vous souhaitez fusionner et lancer la commande <code class="literal">git merge</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
Switched to branch &#39;master&#39;
<span style="font-weight: bold">$</span> git merge iss53
Merge made by the &#39;recursive&#39; strategy.
README |    1 +
1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Le comportement semble légèrement différent de celui observé pour la fusion précédente de la branche <code class="literal">correctif</code>.
Dans ce cas, à un certain moment, l&#8217;historique de développement a divergé.
Comme le <em>commit</em> sur la branche sur laquelle vous vous trouvez n&#8217;est plus un ancêtre direct de la branche que vous cherchez à fusionner, Git doit effectuer quelques actions.
Dans ce cas, Git réalise une simple fusion à trois sources (<em>three-way merge</em>), en utilisant les deux instantanés pointés par les sommets des branches ainsi que leur plus proche ancêtre commun.</p>
<figure class="image">
<div class="content">
<img src="images/basic-merging-1.png" alt="Trois instantanés utilisés dans une fusion classique."/>
</div>
<figcaption>Figure 16. Trois instantanés utilisés dans une fusion classique</figcaption>
</figure>
<p>Au lieu d&#8217;avancer simplement le pointeur de branche, Git crée un nouvel instantané qui résulte de la fusion à trois sources et crée automatiquement un nouveau <em>commit</em> qui pointe dessus.
On appelle ceci un <em>commit</em> de fusion (<em>merge commit</em>) qui est spécial en cela qu&#8217;il a plus d&#8217;un parent.</p>
<figure class="image">
<div class="content">
<img src="images/basic-merging-2.png" alt="Un _commit_ de fusion."/>
</div>
<figcaption>Figure 17. Un <em>commit</em> de fusion</figcaption>
</figure>
<p>Il est à noter que Git détermine par lui-même le meilleur ancêtre commun à utiliser comme base de la fusion. Ce comportement est très différent de celui de CVS ou Subversion (avant la version 1.5), où le développeur en charge de la fusion doit trouver par lui-même la meilleure base.
Cela rend la fusion beaucoup plus facile dans Git que dans les autres systèmes.</p>
<p>À présent que votre travail a été fusionné, vous n&#8217;avez plus besoin de la branche <code class="literal">iss53</code>.
Vous pouvez fermer le ticket dans votre outil de suivi des tâches et supprimer la branche :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -d iss53</code></pre>
</figure>
</section>
<section class="sect2" title="Conflits de fusions (Merge conflicts)">
<h3 id="s_basic_merge_conflicts">Conflits de fusions (<em>Merge conflicts</em>)</h3>
<p>
Quelques fois, le processus ci-dessus ne se déroule pas aussi bien.
Si vous avez modifié différemment la même partie du même fichier dans les deux branches que vous souhaitez fusionner, Git ne sera pas capable de réaliser proprement la fusion.
Si votre résolution du problème #53 a modifié la même section de fichier que le <code class="literal">correctif</code>, vous obtiendrez un conflit qui ressemblera à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>Git n&#8217;a pas automatiquement créé le <em>commit</em> de fusion.
Il a arrêté le processus le temps que vous résolviez le conflit.
Si vous voulez vérifier, à tout moment après l&#8217;apparition du conflit, quels fichiers n&#8217;ont pas été fusionnés, vous pouvez lancer la commande <code class="literal">git status</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:      index.html

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</figure>
<p>Tout ce qui comporte des conflits et n&#8217;a pas été résolu est listé comme <code class="literal">unmerged</code>.
Git ajoute des marques de résolution de conflit standards dans les fichiers qui comportent des conflits, pour que vous puissiez les ouvrir et résoudre les conflits manuellement.
Votre fichier contient des sections qui ressemblent à ceci :</p>
<figure class="listing">
<pre class="source language-html"><code><span></span><span style="border: 1px solid #FF0000">&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; <span style="font-weight: bold">HEAD:index.html</span>
<span style="border: 1px solid #FF0000">&lt;</span>div id=<span style="font-style: italic">&quot;footer&quot;</span>&gt;contact : email.support@github.com&lt;/<span style="font-weight: bold">div</span>&gt;
======
&lt;<span style="font-weight: bold">div</span> id=<span style="font-style: italic">&quot;footer&quot;</span>&gt;
 please contact us at support@github.com
&lt;/<span style="font-weight: bold">div</span>&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></pre>
</figure>
<p>Cela signifie que la version dans <code class="literal">HEAD</code> (votre branche <code class="literal">master</code>, parce que c&#8217;est celle que vous aviez extraite quand vous avez lancé votre commande de fusion) est la partie supérieure de ce bloc (tout ce qui se trouve au-dessus de la ligne <code class="literal">=======</code>), tandis que la version de votre branche <code class="literal">iss53</code> se trouve en dessous.
Pour résoudre le conflit, vous devez choisir une partie ou l&#8217;autre ou bien fusionner leurs contenus vous-même.
Par exemple, vous pourriez choisir de résoudre ce conflit en remplaçant tout le bloc par ceci :</p>
<figure class="listing">
<pre class="source language-html"><code><span></span>&lt;<span style="font-weight: bold">div</span> id=<span style="font-style: italic">&quot;footer&quot;</span>&gt;
please contact us at email.support@github.com
&lt;/<span style="font-weight: bold">div</span>&gt;</code></pre>
</figure>
<p>Cette résolution comporte des éléments de chaque section et les lignes <code class="literal">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code class="literal">=======</code> et <code class="literal">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> ont été complètement effacées.
Après avoir résolu chacune de ces sections dans chaque fichier comportant un conflit, lancez <code class="literal">git add</code> sur chaque fichier pour le marquer comme résolu.
Placer le fichier dans l&#8217;index marque le conflit comme résolu pour Git.</p>
<p>Si vous souhaitez utiliser un outil graphique pour résoudre ces conflits, vous pouvez lancer <code class="literal">git mergetool</code> qui démarre l&#8217;outil graphique de fusion approprié et vous permet de naviguer dans les conflits :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mergetool

This message is displayed because &#39;merge.tool&#39; is not configured.
See &#39;git mergetool --tool-help&#39; or &#39;git help config&#39; for more details.
&#39;git mergetool&#39; will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for &#39;index.html&#39;:
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):</code></pre>
</figure>
<p>Si vous souhaitez utiliser un outil de fusion autre que celui par défaut (Git a choisi <code class="literal">opendiff</code> dans ce cas car la commande a été lancée depuis un Mac), vous pouvez voir tous les outils supportés après l&#8217;indication « <em>of the following tools:</em> ».
Entrez simplement le nom de l&#8217;outil que vous préféreriez utiliser.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Si vous avez besoin d&#8217;outils plus avancés pour résoudre des conflits complexes, vous trouverez davantage d&#8217;informations au chapitre <a id="xref--ch07-git-tools--s_advanced_merging" href="ch07-git-tools.xhtml#s_advanced_merging" class="xref">Fusion avancée</a>.</p>
</div>
</aside>
<p>Après avoir quitté l&#8217;outil de fusion, Git vous demande si la fusion a été réussie.
Si vous répondez par la positive à l&#8217;outil, il ajoute le fichier dans l&#8217;index pour le marquer comme résolu.</p>
<p>Vous pouvez lancer à nouveau la commande <code class="literal">git status</code> pour vérifier que tous les conflits ont été résolus :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
All conflicts fixed but you are still merging.
  (use &quot;git commit&quot; to conclude merge)

Changes to be committed:

    modified:   index.html</code></pre>
</figure>
<p>Si cela vous convient et que vous avez vérifié que tout ce qui comportait des conflits a été ajouté à l&#8217;index, vous pouvez entrer la commande <code class="literal">git commit</code> pour finaliser le <em>commit</em> de fusion.
Le message de validation par défaut ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Merge branch &#39;iss53&#39;

Conflicts:
    index.html
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> It looks like you may be committing a merge.
<span style="font-weight: bold">#</span> If this is not correct, please remove the file
<span style="font-weight: bold">#</span>	.git/MERGE_HEAD
<span style="font-weight: bold">#</span> and try again.


<span style="font-weight: bold">#</span> Please enter the commit message <span style="font-weight: bold">for</span> your changes. Lines starting
<span style="font-weight: bold">#</span> with <span style="font-style: italic">&#39;#&#39;</span> will be ignored, and an empty message aborts the commit.
<span style="font-weight: bold">#</span> On branch master
<span style="font-weight: bold">#</span> All conflicts fixed but you are still merging.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Changes to be committed:
<span style="font-weight: bold">#</span>	modified:   index.html
<span style="font-weight: bold">#</span></code></pre>
</figure>
<p>Vous pouvez modifier ce message pour inclure les détails sur la manière dont le conflit a été résolu si vous pensez que cela peut être utile lors d&#8217;une revue ultérieure. Indiquez pourquoi vous avez fait ces choix, si ce n&#8217;est pas clair.</p>
</section>
</section>
<section class="sect1" title="Gestion des branches">
<h2 id="s_branch_management">Gestion des branches</h2>
<p>
Maintenant que vous avez créé, fusionné et supprimé des branches, regardons de plus près les outils de gestion des branches qui s&#8217;avèreront utiles lors d&#8217;une utilisation intensive des branches.</p>
<p>La commande <code class="literal">git branch</code> permet en fait bien plus que la simple création et suppression de branches.
Si vous la lancez sans argument, vous obtenez la liste des branches courantes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch
  iss53
* master
  test</code></pre>
</figure>
<p>Notez le caractère <code class="literal">*</code> qui préfixe la branche <code class="literal">master</code> : il indique la branche courante (c&#8217;est-à-dire la branche sur laquelle le pointeur <code class="literal">HEAD</code> se situe).
Ceci signifie que si, dans cette situation, vous validez des modifications (grâce à <code class="literal">git commit</code>), le pointeur de la branche <code class="literal">master</code> sera mis à jour pour inclure vos modifications.
Pour visualiser la liste des derniers <em>commits</em> sur chaque branche, vous pouvez utiliser le commande <code class="literal">git branch -v</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch &#39;iss53&#39;
  test 782fd34 add scott to the author list in the readmes</code></pre>
</figure>
<p><code class="literal">--merged</code> et <code class="literal">--no-merged</code> sont des options très utiles qui permettent de filtrer les branches de cette liste selon que vous les avez ou ne les avez pas encore fusionnées avec la branche courante.
Pour voir quelles branches ont déjà été fusionnées dans votre branche courante, lancez <code class="literal">git branch --merged</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch --merged
  iss53
* master</code></pre>
</figure>
<p>Comme vous avez déjà fusionné <code class="literal">iss53</code> un peu plus tôt, vous la voyez dans votre liste.
Les branches de cette liste qui ne comportent pas le préfixe <code class="literal">*</code> peuvent généralement être effacées sans risque au moyen de <code class="literal">git branch -d</code> puisque vous avez déjà intégré leurs modifications dans une autre branche et ne risquez donc pas de perdre quoi que ce soit.</p>
<p>Pour visualiser les branches qui contiennent des travaux qui n&#8217;ont pas encore été fusionnés, vous pouvez utiliser la commande <code class="literal">git branch --no-merged</code>  :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch --no-merged
  test</code></pre>
</figure>
<p>Ceci affiche votre autre branche.
Comme elle contient des modifications qui n&#8217;ont pas encore été intégrées, essayer de les supprimer par la commande <code class="literal">git branch -d</code> se solde par un échec :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -d test
error: The branch &#39;test&#39; is not fully merged.
If you are sure you want to delete it, run &#39;git branch -D test&#39;.</code></pre>
</figure>
<p>Si vous souhaitez réellement supprimer cette branche et perdre ainsi le travail réalisé, vous pouvez tout de même forcer la suppression avec l&#8217;option <code class="literal">-D</code>, comme l&#8217;indique le message.</p>
</section>
<section class="sect1" title="Travailler avec les branches">
<h2 id="_travailler_avec_les_branches">Travailler avec les branches</h2>
<p>Maintenant que vous avez acquis les bases concernant les branches et les fusions (<em>merges</em>), que pouvez-vous ou devez-vous en faire ?
Ce chapitre traite des différents processus que cette gestion de branche légère permet de mettre en place, de manière à vous aider à décider si vous souhaitez en incorporer un dans votre cycle de développement.</p>
<section class="sect2" title="Branches au long cours">
<h3 id="_branches_au_long_cours">Branches au long cours</h3>
<p>
Comme Git utilise une <em>fusion à 3 sources</em>, fusionner une même branche dans une autre plusieurs fois sur une longue période est généralement facile.
Cela signifie que vous pouvez avoir plusieurs branches ouvertes en permanence pour différentes phases de votre cycle de développement. Vous pourrez fusionner régulièrement ces branches entre elles.</p>
<p>De nombreux développeurs travaillent avec Git selon une méthode qui utilise cette approche. Il s&#8217;agit, par exemple, de n&#8217;avoir que du code entièrement stable et testé dans leur branche <code class="literal">master</code> ou bien même uniquement du code qui a été ou sera publié au sein d&#8217;une <em>release</em>.
Ils ont alors en parallèle une autre branche appelée <code class="literal">develop</code> ou <code class="literal">next</code>. Cette branche accueille les développements en cours qui font encore l&#8217;objet de tests de stabilité — cette branche n&#8217;est pas nécessairement toujours stable mais quand elle le devient, elle peut être intégrée (via une fusion) dans <code class="literal">master</code>.
Cette branche permet d&#8217;intégrer des branches thématiques (<em>topic branches</em> : branches de faible durée de vie telles que votre branche <code class="literal">iss53</code>), une fois prêtes, de manière à s&#8217;assurer qu&#8217;elles passent l&#8217;intégralité des tests et n&#8217;introduisent pas de bugs.</p>
<p>En réalité, nous parlons de pointeurs qui se déplacent le long des lignes des <em>commits</em> réalisés.
Les branches stables sont plus basses dans l&#8217;historique des <em>commits</em> tandis que les branches des derniers développements sont plus hautes dans l&#8217;historique.</p>
<figure class="image">
<div class="content">
<img src="images/lr-branches-1.png" alt="Vue linéaire de branches dans un processus de _stabilité progressive_."/>
</div>
<figcaption>Figure 18. Vue linéaire de branches dans un processus de <em>stabilité progressive</em></figcaption>
</figure>
<p>Il est généralement plus simple d&#8217;y penser en termes de silos de tâches où un ensemble de <em>commits</em> évolue progressivement vers un silo plus stable une fois qu&#8217;il a été complètement testé.</p>
<figure id="lrbranch_b" class="image">
<div class="content">
<img src="images/lr-branches-2.png" alt="Vue _en silo_ de branches dans un processus de _stabilité progressive_."/>
</div>
<figcaption>Figure 19. Vue <em>en silo</em> de branches dans un processus de <em>stabilité progressive</em></figcaption>
</figure>
<p>Vous pouvez reproduire ce schéma sur plusieurs niveaux de stabilité.
Des projets plus gros ont aussi une branche <code class="literal">proposed</code> ou <code class="literal">pu</code> (<em>proposed updates</em>) qui intègre elle-même des branches qui ne sont pas encore prêtes à être intégrées aux branches <code class="literal">next</code> ou <code class="literal">master</code>.
L&#8217;idée est que les branches évoluent à différents niveaux de stabilité : quand elles atteignent un niveau plus stable, elles peuvent être fusionnées dans la branche de stabilité supérieure.
Une fois encore, disposer de multiples branches au long cours n&#8217;est pas nécessaire mais s&#8217;avère souvent utile, spécialement dans le cadre de projets importants et complexes.</p>
</section>
<section class="sect2" title="Les branches thématiques">
<h3 id="s_topic_branch">Les branches thématiques</h3>
<p>
Les branches thématiques, elles, sont utiles quelle que soit la taille du projet.
Une branche thématique est une branche ayant une courte durée de vie créée et utilisée pour une fonctionnalité ou une tâche particulière.
C&#8217;est une méthode que vous n&#8217;avez probablement jamais utilisée avec un autre VCS parce qu&#8217;il y est généralement trop lourd de créer et fusionner des branches.
Mais dans Git, créer, développer, fusionner et supprimer des branches plusieurs fois par jour est monnaie courante.</p>
<p>Vous avez déjà vu ces branches dans la section précédente avec les branches <code class="literal">iss53</code> et <code class="literal">correctif</code> que vous avez créées.
Vous y avez réalisé quelques <em>commits</em> et vous les avez supprimées immédiatement après les avoir fusionnées dans votre branche principale.
Cette technique vous permet de changer de contexte rapidement et complètement. Parce que votre travail est isolé dans des silos où toutes les modifications sont liées à une thématique donnée, il est beaucoup plus simple de réaliser des revues de code.
Vous pouvez conserver vos modifications dans ces branches pendant des minutes, des jours ou des mois puis les fusionner quand elles sont prêtes, indépendamment de l&#8217;ordre dans lequel elles ont été créées ou traitées.</p>
<p>Prenons l&#8217;exemple suivant : alors que vous développez (sur <code class="literal">master</code>), vous créez une nouvelle branche pour un problème (<code class="literal">prob91</code>), travaillez un peu sur ce problème puis créez une seconde branche pour essayer de trouver une autre manière de le résoudre (<code class="literal">prob91v2</code>). Vous retournez ensuite sur la branche <code class="literal">master</code> pour y travailler pendant un moment puis finalement créez une dernière branche (<code class="literal">ideeidiote</code>) contenant une idée dont vous doutez de la pertinence.
Votre historique de <em>commits</em> pourrait ressembler à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/topic-branches-1.png" alt="Branches thématiques multiples."/>
</div>
<figcaption>Figure 20. Branches thématiques multiples</figcaption>
</figure>
<p>Maintenant, supposons que vous décidiez que vous préférez la seconde solution pour le problème (<code class="literal">prob91v2</code>) et que vous ayez montré la branche <code class="literal">ideeidiote</code> à vos collègues qui vous ont dit qu&#8217;elle était géniale.
Vous pouvez jeter la branche <code class="literal">prob91</code> originale (perdant ainsi les <em>commits</em> <code class="literal">C5</code> et <code class="literal">C6</code>) et fusionner les deux autres branches.
Votre historique ressemble à présent à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/topic-branches-2.png" alt="Historique après la fusion de `ideeidiote` et `prob91v2`."/>
</div>
<figcaption>Figure 21. Historique après la fusion de <code class="literal">ideeidiote</code> et <code class="literal">prob91v2</code></figcaption>
</figure>
<p>Nous verrons au chapitre <a id="xref--ch05-distributed-git" href="ch05-distributed-git.xhtml" class="xref">Git distribué</a>, d&#8217;autres méthodes et processus possibles pour vos projets Git. Nous vous invitons à prendre  connaissance de ce chapitre avant de vous décider pour une méthode particulière de gestion de vos branches pour votre prochain projet.</p>
<p>Il est important de se souvenir que lors de la réalisation de toutes ces actions, ces branches sont complètement locales.
Lorsque vous créez et fusionnez des branches, ceci est réalisé uniquement dans votre dépôt Git local et aucune communication avec un serveur n&#8217;a lieu.</p>
</section>
</section>
<section class="sect1" title="Branches distantes">
<h2 id="s_remote_branches">Branches distantes</h2>
<p>
Les références distantes sont des références (pointeurs) vers les éléments de votre dépôt distant tels que les branches, les tags, etc&#8230;&#8203;
Vous pouvez obtenir la liste complète de ces références distantes avec la commade <code class="literal">git ls-remote (remote)</code>, ou <code class="literal">git remote show (remote)</code>.
Néanmoins, une manière plus courante consiste à tirer parti des branches distantes.</p>
<p>Les branches distantes sont des références (des pointeurs) vers l&#8217;état des branches sur votre dépôt distant.
Ce sont des branches locales qu&#8217;on ne peut pas modifier ; elles sont modifiées automatiquement pour vous lors de communications réseau.
Les branches distantes agissent comme des marques-pages pour vous aider à vous souvenir de l&#8217;état des branches sur votre dépôt distant lors de votre dernière connexion.</p>
<p>Elles prennent la forme de <code class="literal">(distant)/(branche)</code>.
Par exemple, si vous souhaitiez visualiser l&#8217;état de votre branche <code class="literal">master</code> sur le dépôt distant <code class="literal">origin</code> lors de votre dernière communication, il vous suffirait de vérifier la branche <code class="literal">origin/master</code>.
Si vous étiez en train de travailler avec un collègue et qu&#8217;il avait publié la branche <code class="literal">iss53</code>, vous pourriez avoir votre propre branche <code class="literal">iss53</code> ; mais la branche sur le serveur pointerait sur le <em>commit</em> de <code class="literal">origin/iss53</code>.</p>
<p>Cela peut être un peu déconcertant, essayons d&#8217;éclaircir les choses par un exemple.
Supposons que vous avez un serveur Git sur le réseau à l&#8217;adresse <code class="literal">git.notresociete.com</code>.
Si vous clonez à partir de ce serveur, la commande <code class="literal">clone</code> de Git le nomme automatiquement <code class="literal">origin</code>, tire tout son historique, crée un pointeur sur l&#8217;état actuel de la branche <code class="literal">master</code> et l&#8217;appelle localement <code class="literal">origin/master</code>.
Git crée également votre propre branche <code class="literal">master</code> qui démarre au même endroit que la branche <code class="literal">master</code> d&#8217;origine, pour que vous puissiez commencer à travailler.</p>
<aside class="admonition note" title="Note: origin n&#8217;est pas spécial" epub:type="note">
<h2><code class="literal">origin</code> n&#8217;est pas spécial</h2>
<div class="content">
<p>De la même manière que le nom de branche <code class="literal">master</code> n&#8217;a aucun sens particulier pour Git, le nom <code class="literal">origin</code> n&#8217;est pas spécial. Tandis que <code class="literal">master</code> est le nom attribué par défaut à votre branche initiale lorsque vous lancez la commande <code class="literal">git init</code> et c&#8217;est la seule raison pour laquelle ce nom est utilisé aussi largement, <code class="literal">origin</code> est le nom utilisé par défaut pour un dépôt distant lorsque vous lancez <code class="literal">git clone</code>. Si vous lancez à la place <code class="literal">git clone -o booyah</code>, votre branche distante par défaut s&#8217;appellera <code class="literal">booyah/master</code>.</p>
</div>
</aside>
<figure class="image">
<div class="content">
<img src="images/remote-branches-1.png" alt="Dépôts distant et local après un _clone_."/>
</div>
<figcaption>Figure 22. Dépôts distant et local après un <em>clone</em></figcaption>
</figure>
<p>Si vous travaillez sur votre branche locale <code class="literal">master</code> et que dans le même temps, quelqu&#8217;un publie sur <code class="literal">git.notresociete.com</code> et met à jour cette même branche <code class="literal">master</code>, alors vos deux historiques divergent.
Tant que vous restez sans contact avec votre serveur distant, votre pointeur vers <code class="literal">origin/master</code> n&#8217;avance pas.</p>
<figure class="image">
<div class="content">
<img src="images/remote-branches-2.png" alt="Les travaux locaux et distants peuvent diverger."/>
</div>
<figcaption>Figure 23. Les travaux locaux et distants peuvent diverger</figcaption>
</figure>
<p>Lancez la commande <code class="literal">git fetch origin</code> pour synchroniser vos travaux.
Cette commande recherche le serveur hébergeant <code class="literal">origin</code> (dans notre cas, <code class="literal">git.notresociete.com</code>), y récupère toutes les nouvelles données et met à jour votre base de donnée locale en déplaçant votre pointeur <code class="literal">origin/master</code> vers une nouvelle position, plus à jour.</p>
<figure class="image">
<div class="content">
<img src="images/remote-branches-3.png" alt="`git fetch` met à jour vos références distantes."/>
</div>
<figcaption>Figure 24. <code class="literal">git fetch</code> met à jour vos références distantes</figcaption>
</figure>
<p>Pour démontrer l&#8217;usage de multiples serveurs distants et le fonctionnement des branches distantes pour ces projets distants, supposons que vous avez un autre serveur Git interne qui n&#8217;est utilisé que par une équipe de développeurs.
Ce serveur se trouve sur <code class="literal">git.equipe1.notresociete.com</code>.
Vous pouvez l&#8217;ajouter aux références distantes de votre projet en lançant la commande <code class="literal">git remote add</code> comme nous l&#8217;avons décrit au chapitre <a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Les bases de Git</a>.
Nommez ce serveur distant <code class="literal">equipeun</code> qui sera le raccourci pour l&#8217;URL complète.</p>
<figure class="image">
<div class="content">
<img src="images/remote-branches-4.png" alt="Ajout d'un nouveau server en tant que référence distante."/>
</div>
<figcaption>Figure 25. Ajout d&#8217;un nouveau server en tant que référence distante</figcaption>
</figure>
<p>Maintenant, vous pouvez lancez <code class="literal">git fetch equipeun</code> pour récupérer l&#8217;ensemble des informations du serveur distant <code class="literal">equipeun</code> que vous ne possédez pas.
Comme ce serveur contient déjà un sous-ensemble des données du serveur <code class="literal">origin</code>, Git ne récupère aucune donnée mais initialise une branche distante appelée <code class="literal">equipeun/master</code> qui pointe sur le même <em>commit</em> que celui vers lequel pointe la branche <code class="literal">master</code> de <code class="literal">equipeun</code>.</p>
<figure class="image">
<div class="content">
<img src="images/remote-branches-5.png" alt="Suivi d'une branche distante `equipeun/master`."/>
</div>
<figcaption>Figure 26. Suivi d&#8217;une branche distante <code class="literal">equipeun/master</code></figcaption>
</figure>
<section class="sect2" title="Pousser les branches">
<h3 id="s_pushing_branches">Pousser les branches</h3>
<p>
Lorsque vous souhaitez partager une branche avec le reste du monde, vous devez la pousser sur un serveur distant sur lequel vous avez accès en écriture.
Vos branches locales ne sont pas automatiquement synchronisées sur les serveurs distants — vous devez pousser explicitement les branches que vous souhaitez partager.
De cette manière, vous pouvez utiliser des branches privées pour le travail que vous ne souhaitez pas partager et ne pousser que les branches sur lesquelles vous souhaitez collaborer.</p>
<p>Si vous possédez une branche nommée <code class="literal">correctionserveur</code> sur laquelle vous souhaitez travailler avec d&#8217;autres, vous pouvez la poussez de la même manière que vous avez poussé votre première branche.
Lancez <code class="literal">git push (serveur distant) (branche)</code> : </p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin correctionserveur
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      correctionserveur -&gt; correctionserveur</code></pre>
</figure>
<p>Il s&#8217;agit en quelque sorte d&#8217;un raccourci.
Git développe automatiquement le nom de branche <code class="literal">correctionserveur</code> en <code class="literal">refs/heads/correctionserveur:refs/heads/correctionserveur</code>, ce qui signifie "Prendre ma branche locale <code class="literal">correctionserveur</code> et la pousser pour mettre à jour la branche distante <code class="literal">correctionserveur</code>".
Nous traiterons plus en détail la partie <code class="literal">refs/heads/</code> au chapitre <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Les tripes de Git</a> mais généralement, vous pouvez l&#8217;oublier.
Vous pouvez aussi lancer <code class="literal">git push origin correctionserveur:correctionserveur</code>, qui réalise la même chose — ce qui signifie « Prendre ma branche <code class="literal">correctionserveur</code> et en faire la branche <code class="literal">correctionserveur</code> distante ».
Vous pouvez utiliser ce format pour pousser une branche locale vers une branche distante nommée différemment.
Si vous ne souhaitez pas l&#8217;appeler <code class="literal">correctionserveur</code> sur le serveur distant, vous pouvez lancer à la place <code class="literal">git push origin correctionserveur:branchegeniale</code> pour pousser votre branche locale <code class="literal">correctionserveur</code> sur la branche <code class="literal">branchegeniale</code> sur le dépôt distant.</p>
<aside class="admonition note" title="Note: Ne renseignez pas votre mot de passe à chaque fois" epub:type="note">
<h2>Ne renseignez pas votre mot de passe à chaque fois</h2>
<div class="content">
<p>Si vous utilisez une URL en HTTPS, le serveur Git vous demandera votre nom d&#8217;utilisateur et votre mot de passe pour vous authentifier. Par défaut, vous devez entrer ces informations sur votre terminal et le serveur pourra alors déterminer si vous être autorisé à pousser.</p>
<p>Si vous ne voulez pas entrer ces informations à chaque fois que vous poussez, vous pouvez mettre en place un "cache d&#8217;identification" (<em>credential cache</em>). Son fonctionnement le plus simple consiste à garder ces informations en mémoire pour quelques minutes mais vous pouvez configurer ce délai en lançant la commande <code class="literal">git config --global credential.helper cache</code>.</p>
<p>Pour davantage d&#8217;informations sur les différentes options de cache d&#8217;identification disponibles, vous pouvez vous référer au chapitre <a id="xref--ch07-git-tools--s_credential_caching" href="ch07-git-tools.xhtml#s_credential_caching" class="xref">Stockage des identifiants</a>.</p>
</div>
</aside>
<p>La prochaine fois qu&#8217;un de vos collègues récupère les données depuis le serveur, il récupérera, au sein de la branche distante <code class="literal">origin/correctionserveur</code>, une référence vers l&#8217;état de la branche <code class="literal">correctionserveur</code> sur le serveur :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      correctionserveur    -&gt; origin/correctionserveur</code></pre>
</figure>
<p>Il est important de noter que lorsque vous récupérez une nouvelle branche depuis un serveur distant, vous ne créez pas automatiquement une copie locale éditable.
En d&#8217;autres termes, il n&#8217;y a pas de branche <code class="literal">correctionserveur</code>, seulement un pointeur sur la branche <code class="literal">origin/correctionserveur</code> qui n&#8217;est pas modifiable.</p>
<p>Pour fusionner ce travail dans votre branche de travail actuelle, vous pouvez lancer la commande <code class="literal">git merge origin/correctionserveur</code>.
Si vous souhaitez créer votre propre branche <code class="literal">correctionserveur</code> pour pouvoir y travailler, vous pouvez faire qu&#8217;elle repose sur le pointeur distant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b correctionserveur origin/correctionserveur
Branch correctionserveur set up to track remote branch correctionserveur from origin.
Switched to a new branch &#39;correctionserveur&#39;</code></pre>
</figure>
<p>Cette commande vous fournit une branche locale modifiable basée sur l&#8217;état actuel de <code class="literal">origin/correctionserveur</code>.</p>
</section>
<section class="sect2" title="Suivre les branches">
<h3 id="s_tracking_branches">Suivre les branches</h3>
<p>
L&#8217;extraction d&#8217;une branche locale à partir d&#8217;une branche distante crée automatiquement ce qu&#8217;on appelle une "branche de suivi" (<em>tracking branch</em>) et la branche qu&#8217;elle suit est appelée "branche amont" (<em>upstream branch</em>).
Les branches de suivi sont des branches locales qui sont en relation directe avec une branche distante.
Si vous vous trouvez sur une branche de suivi et que vous tapez <code class="literal">git push</code>, Git sélectionne automatiquement le serveur vers lequel pousser vos modifications.
De même, un <code class="literal">git pull</code> sur une de ces branches récupère toutes les références distantes et fusionne automatiquement la branche distante correspondante dans la branche actuelle.</p>
<p>Lorsque vous clonez un dépôt, il crée généralement automatiquement une branche <code class="literal">master</code> qui suit <code class="literal">origin/master</code>.
C&#8217;est pourquoi les commandes <code class="literal">git push</code> et <code class="literal">git pull</code> fonctionnent directement sans autre configuration.
Vous pouvez néanmoins créer d&#8217;autres branches de suivi si vous le souhaitez, qui suivront des branches sur d&#8217;autres dépôts distants ou ne suivront pas la branche <code class="literal">master</code>.
Un cas d&#8217;utilisation simple est l&#8217;exemple précédent, en lançant <code class="literal">git checkout -b [branche] [nomdistant]/[branche]</code>.
C&#8217;est une opération suffisamment courante pour que Git propose l&#8217;option abrégée <code class="literal">--track</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout --track origin/correctionserveur
Branch correctionserveur set up to track remote branch correctionserveur from origin.
Switched to a new branch &#39;correctionserveur&#39;</code></pre>
</figure>
<p>Pour créer une branche locale avec un nom différent de celui de la branche distante, vous pouvez simplement utiliser la première version avec un nom différent de branche locale :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b cs origin/correctionserveur
Branch cs set up to track remote branch correctionserveur from origin.
Switched to a new branch &#39;cs&#39;</code></pre>
</figure>
<p>À présent, votre branche locale <code class="literal">cs</code> poussera vers et tirera automatiquement depuis <code class="literal">origin/correctionserveur</code>.</p>
<p>Si vous avez déjà une branche locale et que vous voulez l&#8217;associer à une branche distante que vous venez de récupérer ou que vous voulez changer la branche distante que vous suivez, vous pouvez ajouter l&#8217;option <code class="literal">-u</code> ou <code class="literal">--set-upstream-to</code> à la commande <code class="literal">git branch</code> à tout moment.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -u origin/correctionserveur
Branch correctionserveur set up to track remote branch correctionserveur from origin.</code></pre>
</figure>
<aside class="admonition note" title="Note: Raccourci vers upstream" epub:type="note">
<h2>Raccourci vers <em>upstream</em></h2>
<div class="content">
<p>Quand vous avez une branche de suivi configurée, vous pouvez faire référence à sa branche amont grâce au raccourci <code class="literal">@{upstream}</code> ou <code class="literal">@{u}</code>. Ainsi, si vous êtes sur la branche <code class="literal">master</code> et sa branche de suivi <code class="literal">origin/master</code>, vous pouvez utiliser quelque chose comme <code class="literal">git merge @{u}</code> au lieu de <code class="literal">git merge origin/master</code> si vous le souhaitez.</p>
</div>
</aside>
<p>Si vous voulez voir quelles branches de suivi vous avez configurées, vous pouvez passer l&#8217;option <code class="literal">-vv</code> à <code class="literal">git branch</code>. Celle-ci va lister l&#8217;ensemble de vos branches locales avec quelques informations supplémentaires, y compris quelle est la branche suivie et si votre branche locale est devant, derrière ou les deux à la fois.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* correctionserveur f8674d9 [equipe1/correction-serveur-ok: ahead 3, behind 1] this should do it
  test   5ea463a trying something new</code></pre>
</figure>
<p>Vous pouvez constater ici que votre branche <code class="literal">iss53</code> suit <code class="literal">origin/iss53</code> et est <em>"devant de deux"</em>, ce qui signifie qu&#8217;il existe deux <em>commits</em> locaux qui n&#8217;ont pas été poussés au serveur. On peut aussi voir que la branche <code class="literal">master</code> suit <code class="literal">origin/master</code> et est à jour. On peut voir ensuite que notre branche <code class="literal">correctionserveur</code> suit la branche <code class="literal">correction-serveur-ok</code> sur notre serveur <code class="literal">equipe1</code> et est <em>"devant de trois"</em> et <em>"derrière de un"</em>, ce qui signifie qu&#8217;il existe un <em>commit</em> qui n&#8217;a pas été encore intégré localement et trois <em>commits</em> locaux qui n&#8217;ont pas été poussés. Finalement, on peut voir que notre branche <code class="literal">test</code> ne suit aucune branche distante.</p>
<p>Il est important de noter que ces nombres se basent uniquement sur l&#8217;état de votre branche distante la dernière fois qu&#8217;elle a été synchronisée depuis le serveur. Cette commande n&#8217;effectue aucune recherche sur les serveurs et ne travaille que sur les données locales qui ont été mises en cache depuis ces serveurs. Si vous voulez mettre complètement à jour ces nombres, vous devez préalablement synchroniser (<em>fetch</em>) toutes vos branches distantes depuis les serveurs. Vous pouvez le faire de cette façon : <code class="literal">$ git fetch --all; git branch -vv</code>.</p>
</section>
<section class="sect2" title="Tirer une branche (Pulling)">
<h3 id="_tirer_une_branche_em_pulling_em">Tirer une branche (<em>Pulling</em>)</h3>
<p>
Bien que la commande <code class="literal">git fetch</code> récupère l&#8217;ensemble des changements présents sur serveur et qui n&#8217;ont pas déjà été rapatriés localement, elle ne modifie en rien votre répertoire de travail.
Cette commande récupère simplement les données pour vous et vous laisse les fusionner par vous-même.
Cependant, il existe une commande appelée <code class="literal">git pull</code> qui consiste essentiellement en un <code class="literal">git fetch</code> immédiatement suivi par un <code class="literal">git merge</code> dans la plupart des cas.
Si vous disposez d&#8217;une branche de suivi configurée comme illustré dans le chapitre précédent, soit par une configuration explicite soit en ayant laissé les commandes <code class="literal">clone</code> ou <code class="literal">checkout</code> les créer pour vous, <code class="literal">git pull</code> va examiner quel serveur et quelle branche votre branche courante suit actuellement, synchroniser depuis ce serveur et ensuite essayer de fusionner cette branche distante avec la vôtre.</p>
<p>Il est généralement préférable de simplement utiliser les commandes <code class="literal">fetch</code> et <code class="literal">merge</code> explicitement plutôt que de laisser faire la magie de <code class="literal">git pull</code> qui peut s&#8217;avérer source de confusion.</p>
</section>
<section class="sect2" title="Suppression de branches distantes">
<h3 id="s_delete_branches">Suppression de branches distantes</h3>
<p>
Supposons que vous en avez terminé avec une branche distante - disons que vous et vos collaborateurs avez terminé une fonctionnalité et l&#8217;avez fusionnée dans la branche <code class="literal">master</code> du serveur distant (ou la branche correspondant à votre code stable).
Vous pouvez effacer une branche distante en ajoutant l&#8217;option <code class="literal">--delete</code> à <code class="literal">git push</code>.
Si vous souhaitez effacer votre branche <code class="literal">correctionserveur</code> du serveur, vous pouvez lancer ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin --delete correctionserveur
To https://github.com/schacon/simplegit
 - [deleted]         correctionserveur</code></pre>
</figure>
<p>En résumé, cela ne fait que supprimer le pointeur sur le serveur. Le serveur Git garde généralement les données pour un temps jusqu&#8217;à ce qu&#8217;un processus de nettoyage (<em>garbage collection</em>) passe. De cette manière, si une suppression accidentelle a eu lieu, les données sont souvent très facilement récupérables.</p>
</section>
</section>
<section class="sect1" title="Rebaser (Rebasing)">
<h2 id="s_rebasing">Rebaser (<em>Rebasing</em>)</h2>
<p>
Dans Git, il y a deux façons d&#8217;intégrer les modifications d&#8217;une branche dans une autre : en fusionnant (<code class="literal">merge</code>) et en rebasant (<code class="literal">rebase</code>).
Dans ce chapitre, vous apprendrez la signification de rebaser, comment le faire, pourquoi c&#8217;est un outil incroyable et dans quels cas il est déconseillé de l&#8217;utiliser.</p>
<section class="sect2" title="Les bases">
<h3 id="_les_bases">Les bases</h3>
<p>Si vous revenez à un exemple précédent du chapitre <a id="xref-s_basic_merging" href="#s_basic_merging" class="xref">Fusions (<em>Merges</em>)</a>, vous remarquerez que votre travail a divergé et que vous avez ajouté des <em>commits</em> sur deux branches différentes.</p>
<figure class="image">
<div class="content">
<img src="images/basic-rebase-1.png" alt="Historique divergeant simple."/>
</div>
<figcaption>Figure 27. Historique divergeant simple</figcaption>
</figure>
<p>Comme nous l&#8217;avons déjà expliqué, le moyen le plus simple pour intégrer ces branches est la fusion via la commande <code class="literal">merge</code>.
Cette commande réalise une <em>fusion à trois branches</em> entre les deux derniers instantanés (<em>snapshots</em>) de chaque branche (C3 et C4) et l&#8217;ancêtre commun le plus récent (C2), créant un nouvel instantané (et un <em>commit</em>).</p>
<figure class="image">
<div class="content">
<img src="images/basic-rebase-2.png" alt="Fusion pour intégrer des travaux aux historiques divergeants."/>
</div>
<figcaption>Figure 28. Fusion pour intégrer des travaux aux historiques divergeants</figcaption>
</figure>
<p>Cependant, il existe un autre moyen : vous pouvez prendre le <em>patch</em> de la modification introduite en <code class="literal">C4</code> et le réappliquer sur <code class="literal">C3</code>.
Dans Git, cette action est appelée "rebaser" (<em>rebasing</em>).
Avec la commande <code class="literal">rebase</code>, vous pouvez prendre toutes les modifications qui ont été validées sur une branche et les rejouer sur une autre.</p>
<p>Dans cet exemple, vous lanceriez les commandes suivantes :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout experience
<span style="font-weight: bold">$</span> git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>
</figure>
<p>Cela fonctionne en cherchant l&#8217;ancêtre commun le plus récent des deux branches (celle sur laquelle vous vous trouvez et celle sur laquelle vous rebasez), en récupérant toutes les différences introduites par chaque <em>commit</em> de la branche courante, en les sauvant dans des fichiers temporaires, en réinitialisant la branche courante sur le même <em>commit</em> que la branche de destination et en appliquant finalement chaque modification dans le même ordre.</p>
<figure class="image">
<div class="content">
<img src="images/basic-rebase-3.png" alt="Rebasage des modifications introduites par `C4` sur `C3`."/>
</div>
<figcaption>Figure 29. Rebasage des modifications introduites par <code class="literal">C4</code> sur <code class="literal">C3</code></figcaption>
</figure>
<p>À ce moment, vous pouvez retourner sur la branche <code class="literal">master</code> et réaliser une fusion en avance rapide (<em>fast-forward merge</em>).</p>
<figure class="image">
<div class="content">
<img src="images/basic-rebase-4.png" alt="Avance rapide de la branche `master`."/>
</div>
<figcaption>Figure 30. Avance rapide de la branche <code class="literal">master</code></figcaption>
</figure>
<p>À présent, l&#8217;instantané pointé par <code class="literal">C4'</code> est exactement le même que celui pointé par <code class="literal">C5</code> dans l&#8217;exemple de fusion.
Il n&#8217;y a pas de différence entre les résultats des deux types d&#8217;intégration, mais rebaser rend l&#8217;historique plus clair.
Si vous examinez le journal de la branche rebasée, elle est devenue linéaire : toutes les modifications apparaissent en série même si elles ont eu lieu en parallèle.</p>
<p>Vous aurez souvent à faire cela pour vous assurer que vos <em>commits</em> s&#8217;appliquent proprement sur une branche distante — par exemple, sur un projet où vous souhaitez contribuer mais que vous ne maintenez pas.
Dans ce cas, vous réaliseriez votre travail dans une branche puis vous rebaseriez votre travail sur <code class="literal">origin/master</code> quand vous êtes prêt à soumettre vos patchs au projet principal.
De cette manière, le mainteneur n&#8217;a pas à réaliser de travail d&#8217;intégration — juste une avance rapide ou simplement une application propre.</p>
<p>Il faut noter que l&#8217;instantané pointé par le <em>commit</em> final, qu&#8217;il soit le dernier des <em>commits</em> d&#8217;une opération de rebasage ou le <em>commit</em> final issu d&#8217;une fusion, sont en fait le même instantané — c&#8217;est juste que l&#8217;historique est différent.
Rebaser rejoue les modifications d&#8217;une ligne de <em>commits</em> sur une autre dans l&#8217;ordre d&#8217;apparition, alors que la fusion joint et fusionne les deux têtes.</p>
</section>
<section class="sect2" title="Rebases plus intéressants">
<h3 id="_rebases_plus_intéressants">Rebases plus intéressants</h3>
<p>Vous pouvez aussi faire rejouer votre rebasage sur autre chose qu&#8217;une branche.
Prenez un historique tel que <a id="xref-rbdiag_e" href="#rbdiag_e" class="xref">Un historique avec deux branches thématiques qui sortent l&#8217;une de l&#8217;autre</a> par exemple.
Vous avez créé une branche thématique (<code class="literal">serveur</code>) pour ajouter des fonctionnalités côté serveur à votre projet et avez réalisé un <em>commit</em>.
Ensuite, vous avez créé une branche pour ajouter des modifications côté client (<code class="literal">client</code>) et avez validé plusieurs fois.
Finalement, vous avez rebasculé sur la branche <code class="literal">serveur</code> et avez réalisé quelques <em>commits</em> supplémentaires.</p>
<figure id="rbdiag_e" class="image">
<div class="content">
<img src="images/interesting-rebase-1.png" alt="Un historique avec deux branches thématiques qui sortent l'une de l'autre."/>
</div>
<figcaption>Figure 31. Un historique avec deux branches thématiques qui sortent l&#8217;une de l&#8217;autre</figcaption>
</figure>
<p>Supposons que vous décidez que vous souhaitez fusionner vos modifications du côté client dans votre ligne principale pour une publication (<em>release</em>) mais vous souhaitez retenir les modifications de la partie serveur jusqu&#8217;à ce qu&#8217;elles soient un peu mieux testées.
Vous pouvez récupérer les modifications du côté client qui ne sont pas sur le serveur (<code class="literal">C8</code> et <code class="literal">C9</code>) et les rejouer sur la branche <code class="literal">master</code> en utilisant l&#8217;option <code class="literal">--onto</code> de <code class="literal">git rebase</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase --onto master serveur client</code></pre>
</figure>
<p>Cela signifie en substance "Extraire la branche client, déterminer les patchs depuis l&#8217;ancêtre commun des branches <code class="literal">client</code> et <code class="literal">serveur</code> puis les rejouer sur <code class="literal">master</code> ".
C&#8217;est assez complexe, mais le résultat est assez impressionnant.</p>
<figure class="image">
<div class="content">
<img src="images/interesting-rebase-2.png" alt="Rebaser deux branches thématiques l'une sur l'autre."/>
</div>
<figcaption>Figure 32. Rebaser deux branches thématiques l&#8217;une sur l&#8217;autre</figcaption>
</figure>
<p>Maintenant, vous pouvez faire une avance rapide sur votre branche <code class="literal">master</code> (cf. <a id="xref-rbdiag_g" href="#rbdiag_g" class="xref">Avance rapide sur votre branche <code class="literal">master</code> pour inclure les modifications de la branche client</a>):</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git merge client</code></pre>
</figure>
<figure id="rbdiag_g" class="image">
<div class="content">
<img src="images/interesting-rebase-3.png" alt="Avance rapide sur votre branche `master` pour inclure les modifications de la branche client."/>
</div>
<figcaption>Figure 33. Avance rapide sur votre branche <code class="literal">master</code> pour inclure les modifications de la branche client</figcaption>
</figure>
<p>Supposons que vous décidiez de tirer (<em>pull</em>) votre branche <code class="literal">serveur</code> aussi.
Vous pouvez rebaser la branche <code class="literal">serveur</code> sur la branche <code class="literal">master</code> sans avoir à l&#8217;extraire avant en utilisant <code class="literal">git rebase [branchedebase] [branchethematique]</code> — qui extrait la branche thématique (dans notre cas, <code class="literal">serveur</code>) pour vous et la rejoue sur la branche de base (<code class="literal">master</code>) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase master serveur</code></pre>
</figure>
<p>Cette commande rejoue les modifications de <code class="literal">serveur</code> sur le sommet de la branche <code class="literal">master</code>, comme indiqué dans <a id="xref-rbdiag_h" href="#rbdiag_h" class="xref">Rebasage de la branche serveur sur le sommet de la branche <code class="literal">master</code>.</a>.</p>
<figure id="rbdiag_h" class="image">
<div class="content">
<img src="images/interesting-rebase-4.png" alt="Rebasage de la branche serveur sur le sommet de la branche `master`."/>
</div>
<figcaption>Figure 34. Rebasage de la branche serveur sur le sommet de la branche <code class="literal">master</code>.</figcaption>
</figure>
<p>Vous pouvez ensuite faire une avance rapide sur la branche de base (<code class="literal">master</code>) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git merge serveur</code></pre>
</figure>
<p>Vous pouvez effacer les branches <code class="literal">client</code> et <code class="literal">serveur</code> une fois que tout le travail est intégré et que vous n&#8217;en avez plus besoin, éliminant tout l&#8217;historique de ce processus, comme visible sur <a id="xref-rbdiag_i" href="#rbdiag_i" class="xref">Historique final des <em>commits</em></a> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -d client
<span style="font-weight: bold">$</span> git branch -d serveur</code></pre>
</figure>
<figure id="rbdiag_i" class="image">
<div class="content">
<img src="images/interesting-rebase-5.png" alt="Historique final des _commits_."/>
</div>
<figcaption>Figure 35. Historique final des <em>commits</em></figcaption>
</figure>
</section>
<section class="sect2" title="Les dangers du rebasage">
<h3 id="s_rebase_peril">Les dangers du rebasage</h3>
<p>
Ah… mais les joies de rebaser ne viennent pas sans leurs contreparties, qui peuvent être résumées en une ligne :</p>
<p><strong>Ne rebasez jamais des <em>commits</em> qui ont déjà été poussés sur un dépôt public.</strong></p>
<p>Si vous suivez ce conseil, tout ira bien.
Sinon, de nombreuses personnes vont vous haïr et vous serez méprisé par vos amis et votre famille.</p>
<p>Quand vous rebasez des données, vous abandonnez les <em>commits</em> existants et vous en créez de nouveaux qui sont similaires mais différents.
Si vous poussez des <em>commits</em> quelque part, que d&#8217;autres les tirent et se basent dessus pour travailler, et qu&#8217;après coup, vous réécrivez ces <em>commits</em> à l&#8217;aide de <code class="literal">git rebase</code> et les poussez à nouveau, vos collaborateurs devront re-fusionner leur travail et les choses peuvent rapidement devenir très désordonnées quand vous essaierez de tirer leur travail dans votre dépôt.</p>
<p>Examinons un exemple expliquant comment rebaser un travail déjà publié sur un dépôt public peut générer des gros problèmes.
Supposons que vous clonez un dépôt depuis un serveur central et réalisez quelques travaux dessus.
Votre historique de <em>commits</em> ressemble à ceci :</p>
<figure class="image">
<div class="content">
<img src="images/perils-of-rebasing-1.png" alt="Cloner un dépôt et baser du travail dessus."/>
</div>
<figcaption>Figure 36. Cloner un dépôt et baser du travail dessus</figcaption>
</figure>
<p>À présent, une autre personne travaille et inclut une fusion, puis elle pousse ce travail sur le serveur central.
Vous le récupérez et vous fusionnez la nouvelle branche distante dans votre copie, ce qui donne l&#8217;historique suivant :</p>
<figure class="image">
<div class="content">
<img src="images/perils-of-rebasing-2.png" alt="Récupération de _commits_ et fusion dans votre copie."/>
</div>
<figcaption>Figure 37. Récupération de <em>commits</em> et fusion dans votre copie</figcaption>
</figure>
<p>Ensuite, la personne qui a poussé le travail que vous venez de fusionner décide de faire marche arrière et de rebaser son travail. Elle lance un <code class="literal">git push --force</code> pour forcer l&#8217;écrasement de l&#8217;historique sur le serveur.
Vous récupérez alors les données du serveur, qui vous amènent les nouveaux <em>commits</em>.</p>
<figure id="s_pre_merge_rebase_work" class="image">
<div class="content">
<img src="images/perils-of-rebasing-3.png" alt="Quelqu'un pousse des _commits_ rebasés, en abandonnant les _commits_ sur lesquels vous avez fondé votre travail."/>
</div>
<figcaption>Figure 38. Quelqu&#8217;un pousse des <em>commits</em> rebasés, en abandonnant les <em>commits</em> sur lesquels vous avez fondé votre travail</figcaption>
</figure>
<p>Vous êtes désormais tous les deux dans le pétrin.
Si vous faites un <code class="literal">git pull</code>, vous allez créer un <em>commit</em> de fusion incluant les deux historiques et votre dépôt ressemblera à ça :</p>
<figure id="s_merge_rebase_work" class="image">
<div class="content">
<img src="images/perils-of-rebasing-4.png" alt="Vous fusionnez le même travail une nouvelle fois dans un nouveau _commit_ de fusion."/>
</div>
<figcaption>Figure 39. Vous fusionnez le même travail une nouvelle fois dans un nouveau <em>commit</em> de fusion</figcaption>
</figure>
<p>Si vous lancez <code class="literal">git log</code> lorsque votre historique ressemble à ceci, vous verrez deux <em>commits</em> qui ont la même date d&#8217;auteur et les mêmes messages, ce qui est déroutant.
De plus, si vous poussez cet historique sur le serveur, vous réintroduirez tous ces <em>commits</em> rebasés sur le serveur central, ce qui va encore plus dérouter les autres développeurs.
C&#8217;est plutôt logique de présumer que l&#8217;autre développeur ne souhaite pas voir apparaître <code class="literal">C4</code> et <code class="literal">C6</code> dans l&#8217;historique. C&#8217;est la raison pour laquelle il avait effectué un rebasage initialement.</p>
</section>
<section class="sect2" title="Rebaser quand vous rebasez">
<h3 id="s_rebase_rebase">Rebaser quand vous rebasez</h3>
<p>Si vous vous retrouvez effectivement dans une situation telle que celle-ci, Git dispose d&#8217;autres fonctions magiques qui peuvent vous aider. Si quelqu&#8217;un de votre équipe pousse de force des changements qui écrasent des travaux sur lesquels vous vous êtes basés, votre challenge est de déterminer ce qui est à vous et ce qui a été réécrit.</p>
<p>Il se trouve qu&#8217;en plus de l&#8217;empreinte SHA du <em>commit</em>, Git calcule aussi une empreinte qui est uniquement basée sur le patch introduit avec le commit. Ceci est appelé un "identifiant de patch" (<em>patch-id</em>).</p>
<p>Si vous tirez des travaux qui ont été réécrits et les rebasez au-dessus des nouveaux <em>commits</em> de votre collègue, Git peut souvent déterminer ceux qui sont uniquement les vôtres et les réappliquer au sommet de votre nouvelle branche.</p>
<p>Par exemple, dans le scénario précédent, si au lieu de fusionner quand nous étions à l&#8217;étape <a id="xref-s_pre_merge_rebase_work" href="#s_pre_merge_rebase_work" class="xref">Quelqu&#8217;un pousse des <em>commits</em> rebasés, en abandonnant les <em>commits</em> sur lesquels vous avez fondé votre travail</a> nous exécutons la commande  <code class="literal">git rebase equipe1/master</code>, Git va :</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">Déterminer quels travaux sont uniques à notre branche (C2, C3, C4, C6, C7)</span>
</li>
<li>
<span class="principal">Déterminer ceux qui ne sont pas des <em>commits</em> de fusion (C2, C3, C4)</span>
</li>
<li>
<span class="principal">Déterminer ceux qui n&#8217;ont pas été réécrits dans la branche de destination (uniquement C2 et C3 puisque C4 est le même <em>patch</em> que C4')</span>
</li>
<li>
<span class="principal">Appliquer ces <em>commits</em> au sommet de <code class="literal">equipe1/master</code></span>
</li>
</ul>
</div>
<p>Ainsi, au lieu du résultat que nous avons observé au chapitre <a id="xref-s_merge_rebase_work" href="#s_merge_rebase_work" class="xref">Vous fusionnez le même travail une nouvelle fois dans un nouveau <em>commit</em> de fusion</a>, nous aurions pu finir avec quelque chose qui ressemblerait davantage à <a id="xref-s_rebase_rebase_work" href="#s_rebase_rebase_work" class="xref">Rebaser au-dessus de travaux rebasés puis que l&#8217;on a poussé en forçant.</a>.</p>
<figure id="s_rebase_rebase_work" class="image">
<div class="content">
<img src="images/perils-of-rebasing-5.png" alt="Rebaser au-dessus de travaux rebasés puis que l'on a poussé en forçant."/>
</div>
<figcaption>Figure 40. Rebaser au-dessus de travaux rebasés puis que l&#8217;on a poussé en forçant.</figcaption>
</figure>
<p>Cela fonctionne seulement si les <em>commits</em> C4 et C4' de votre collègue correspondent presque exactement aux mêmes modifications. Autrement, le rebasage ne sera pas capable de déterminer qu&#8217;il s&#8217;agit d&#8217;un doublon et va ajouter un autre <em>patch</em> similaire à C4 (ce qui échouera probablement puisque les changements sont au moins partiellement déjà présents).</p>
<p>Vous pouvez également simplifier tout cela en lançant un <code class="literal">git pull --rebase</code> au lieu d&#8217;un <code class="literal">git pull</code> normal. Vous pouvez encore le faire manuellement à l&#8217;aide d&#8217;un <code class="literal">git fetch</code> suivi d&#8217;un <code class="literal">git rebase team1/master</code> dans le cas présent.</p>
<p>Si vous utilisez <code class="literal">git pull</code> et voulez faire de <code class="literal">--rebase</code> le traitement par défaut, vous pouvez changer la valeur du paramètre de configuration <code class="literal">pull.rebase</code> par <code class="literal">git config --global pull.rebase true</code>.</p>
<p>Si vous considérez le fait de rebaser comme un moyen de nettoyer et réarranger des <em>commits</em> avant de les pousser et si vous vous en tenez à ne rebaser que des <em>commits</em> qui n&#8217;ont jamais été publiés, tout ira bien.
Si vous tentez de rebaser des <em>commits</em> déjà publiés sur lesquels les gens ont déjà basé leur travail, vous allez au devant de gros problèmes et votre équipe vous en tiendra rigueur.</p>
<p>Si vous ou l&#8217;un de vos collègues y trouve cependant une quelconque nécessité, assurez-vous que tout le monde sache lancer un <code class="literal">git pull --rebase</code> pour essayer de rendre les choses un peu plus faciles.</p>
</section>
<section class="sect2" title="Rebaser ou Fusionner">
<h3 id="_rebaser_ou_fusionner">Rebaser ou Fusionner</h3>
<p>
Maintenant que vous avez vu concrètement ce que signifient rebaser et fusionner, vous devez vous demander ce qu&#8217;il est préférable d&#8217;utiliser.
Avant de pouvoir répondre à cela, revenons quelque peu en arrière et parlons un peu de ce que signifie un historique.</p>
<p>On peut voir l&#8217;historique des <em>commits</em> de votre dépôt comme un <strong>enregistrement de ce qu&#8217;il s&#8217;est réellement passé</strong>.
Il s&#8217;agit d&#8217;un document historique qui a une valeur en tant que tel et ne doit pas être altéré.
Sous cet angle, modifier l&#8217;historique des <em>commits</em> est presque blasphématoire puisque vous <em>mentez</em> sur ce qu&#8217;il s&#8217;est réellement passé.
Dans ce cas, que faire dans le cas d&#8217;une série de <em>commits</em> de fusions désordonnés ?
Cela reflète ce qu&#8217;il s&#8217;est passé et le dépôt devrait le conserver pour la postérité.</p>
<p>Le point de vue inverse consiste à considérer que l&#8217;historique des <em>commits</em> est <strong>le reflet de la façon dont votre projet a été construit</strong>.
Vous ne publieriez jamais le premier brouillon d&#8217;un livre et le manuel de maintenance de votre projet mérite une révision attentive.
Ceci constitue le camp de ceux qui utilisent des outils tels que le rebasage et les branches filtrées pour raconter une histoire de la meilleure des manières pour les futurs lecteurs.</p>
<p>Désormais, nous espérons que vous comprenez qu&#8217;il n&#8217;est pas si simple de répondre à la question portant sur le meilleur outil entre fusion et rebasage.
Git est un outil puissant et vous permet beaucoup de manipulations sur et avec votre historique mais chaque équipe et chaque projet sont différents.
Maintenant que vous savez comment fonctionnent ces deux outils, c&#8217;est à vous de décider lequel correspond le mieux à votre situation en particulier.</p>
<p>De manière générale, la manière de profiter au mieux des deux mondes consiste à rebaser des modifications locales que vous avez effectuées mais qui n&#8217;ont pas encore été partagées avant de les pousser de manière à obtenir un historique propre mais sans jamais rebaser quoi que ce soit que vous ayez déjà poussé quelque part.</p>
</section>
</section>
<section class="sect1" title="Résumé">
<h2 id="_résumé">Résumé</h2>
<p>Nous avons traité les bases des branches et des fusions dans Git.
Vous devriez désormais être à l&#8217;aise pour créer et basculer sur de nouvelles branches, basculer entre branches et fusionner des branches locales.
Vous devriez aussi être capable de partager vos branches en les poussant sur un serveur partagé, de travailler avec d&#8217;autres personnes sur des branches partagées et de re-baser vos branches avant de les partager.
Nous aborderons ensuite tout ce que vous devez savoir pour faire tourner votre propre serveur d&#8217;hébergement de dépôts.</p>
</section>
</section>
</body>
</html>