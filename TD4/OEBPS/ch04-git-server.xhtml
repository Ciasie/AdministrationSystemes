<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
<meta charset="UTF-8"/>
<title>Git sur le serveur</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git sur le serveur" epub:type="chapter" id="ch04-git-server">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>sur</b> <b>le</b> <b>serveur</b></small></h1>
</div>
</header>
<p>
À présent, vous devriez être capable de réaliser la plupart des tâches quotidiennes impliquant Git.
Néanmoins, pour pouvoir collaborer avec d&#8217;autres personnes au moyen de Git, vous allez devoir disposer d&#8217;un dépôt distant Git.
Bien que vous puissiez techniquement tirer et pousser des modifications depuis et vers des dépôts personnels, cette pratique est déconseillée parce qu&#8217;elle introduit très facilement une confusion avec votre travail actuel.
De plus, vous souhaitez que vos collaborateurs puissent accéder à votre dépôt de sources, y compris si vous n&#8217;êtes pas connecté — disposer d&#8217;un dépôt accessible en permanence peut s&#8217;avérer utile.
De ce fait, la méthode canonique pour collaborer consiste à instancier un dépôt intermédiaire auquel tout le monde a accès, que ce soit pour pousser ou tirer.</p>
<p>Un serveur Git est simple à lancer.
Premièrement, vous devez choisir quels protocoles seront supportés.
La première partie de ce chapitre traite des protocoles disponibles et de leurs avantages et inconvénients.
La partie suivante explique certaines configurations typiques de ces protocoles et comment les mettre en œuvre.
Enfin, nous traiterons de quelques types d&#8217;hébergement, si vous souhaitez héberger votre code sur un serveur tiers, sans avoir à installer et maintenir un serveur par vous-même.</p>
<p>Si vous ne voyez pas d&#8217;intérêt à gérer votre propre serveur, vous pouvez sauter directement à la dernière partie de ce chapitre pour détailler les options pour mettre en place un compte hébergé, avant de continuer au chapitre suivant dans lequel les problématiques de développement distribué sont abordées.</p>
<p>Un dépôt distant est généralement un <em>dépôt nu</em> (<em>bare repository</em>) : un dépôt Git qui n&#8217;a pas de copie de travail.
Comme ce dépôt n&#8217;est utilisé que comme centralisateur de collaboration, il n&#8217;y a aucune raison d&#8217;extraire un instantané sur le disque ; seules les données Git sont nécessaires.
Pour simplifier, un dépôt nu est le contenu du répertoire <code class="literal">.git</code> sans fioriture.</p>
<section class="sect1" title="Protocoles">
<h2 id="_protocoles">Protocoles</h2>
<p>Git peut utiliser quatre protocoles réseau majeurs pour transporter des données : local, HTTP, <em>Secure Shell</em> (SSH) et Git.
Nous allons voir leur nature et dans quelles circonstances ils peuvent (ou ne peuvent pas) être utilisés.</p>
<section class="sect2" title="Protocole local">
<h3 id="_protocole_local">Protocole local</h3>
<p></p>
<p>Le protocole de base est le protocole <em>local</em> pour lequel le dépôt distant est un autre répertoire dans le système de fichiers.
Il est souvent utilisé si tous les membres de l&#8217;équipe ont accès à un répertoire partagé via NFS par exemple ou dans le cas moins probable où tous les développeurs travaillent sur le même ordinateur.
Ce dernier cas n&#8217;est pas optimum car tous les dépôts seraient hébergés de fait sur le même ordinateur, rendant ainsi toute défaillance catastrophique.</p>
<p>Si vous disposez d&#8217;un système de fichiers partagé, vous pouvez cloner, pousser et tirer avec un dépôt local.
Pour cloner un dépôt ou pour l&#8217;utiliser comme dépôt distant d&#8217;un projet existant, utilisez le chemin vers le dépôt comme URL.
Par exemple, pour cloner un dépôt local, vous pouvez lancer ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone /opt/git/project.git</code></pre>
</figure>
<p>Ou bien cela :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone file:///opt/git/project.git</code></pre>
</figure>
<p>Git opère légèrement différemment si vous spécifiez explicitement le protocole <code class="literal">file://</code> au début de l&#8217;URL.
Si vous spécifiez simplement le chemin et si la destination se trouve sur le même système de fichiers, Git tente d&#8217;utiliser des liens physiques pour les fichiers communs.
Si vous spécifiez le protocole <code class="literal">file://</code>, Git lance un processus d&#8217;accès à travers le réseau, ce qui est généralement moins efficace.
La raison d&#8217;utiliser spécifiquement le préfixe <code class="literal">file://</code> est la volonté d&#8217;obtenir une copie propre du dépôt, sans aucune référence ou aucun objet supplémentaire qui pourraient résulter d&#8217;un import depuis un autre système de gestion de version ou d&#8217;une action similaire (voir chapitre <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Les tripes de Git</a> pour les tâches de maintenance).
Nous utiliserons les chemins normaux par la suite car c&#8217;est la méthode la plus efficace.</p>
<p>Pour ajouter un dépôt local à un projet Git existant, lancez ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add local_proj /opt/git/project.git</code></pre>
</figure>
<p>Ensuite, vous pouvez pousser vers et tirer depuis ce dépôt distant de la même manière que vous le feriez pour un dépôt accessible sur le réseau.</p>
<section class="sect3" title="Avantages">
<h4 id="_avantages">Avantages</h4>
<p>Les avantages des dépôts accessibles sur le système de fichiers sont qu&#8217;ils sont simples et qu&#8217;ils utilisent les permissions du système de fichiers.
Si vous avez déjà un montage partagé auquel toute votre équipe a accès, déployer un dépôt est extrêmement facile.
Vous placez la copie du dépôt nu à un endroit accessible de tous et positionnez correctement les droits de lecture/écriture de la même manière que pour tout autre partage.
Nous aborderons la méthode pour exporter une copie de dépôt nu à cette fin dans la section suivante <a id="xref-s_git_on_the_server" href="#s_git_on_the_server" class="xref">Installation de Git sur un serveur</a>.</p>
<p>C&#8217;est un choix satisfaisant pour partager rapidement le travail.
Si vous et votre coéquipier travaillez sur le même projet et qu&#8217;il souhaite partager son travail, lancer une commande telle que <code class="literal">git pull /home/john/project</code> est certainement plus simple que de passer par un serveur intermédiaire.</p>
</section>
<section class="sect3" title="Inconvénients">
<h4 id="_inconvénients">Inconvénients</h4>
<p>Les inconvénients de cette méthode sont qu&#8217;il est généralement plus difficile de rendre disponible un partage réseau depuis de nombreux endroits que de simplement gérer des accès réseau.
Si vous souhaitez pousser depuis votre portable à la maison, vous devez monter le partage distant, ce qui peut s&#8217;avérer plus difficile et plus lent que d&#8217;y accéder directement via un protocole réseau.</p>
<p>Il faut aussi mentionner que ce n&#8217;est pas nécessairement l&#8217;option la plus rapide à l&#8217;utilisation si un partage réseau est utilisé.
Un dépôt local n&#8217;est rapide que si l&#8217;accès aux fichiers est rapide.
Un dépôt accessible sur un montage NFS est souvent plus lent qu&#8217;un dépôt accessible via SSH sur le même serveur qui ferait tourner Git avec un accès aux disques locaux.</p>
</section>
</section>
<section class="sect2" title="Protocoles sur HTTP">
<h3 id="_protocoles_sur_http">Protocoles sur HTTP</h3>
<p>Git peut communiquer sur HTTP de deux manières.
Avant Git 1.6.6, il n&#8217;existait qu&#8217;une seule manière qui était très simple et généralement en lecture seule.
Depuis la version 1.6.6, il existe un nouveau protocole plus intelligent qui nécessite que Git puisse négocier les transferts de données de manière similaire à ce qu&#8217;il fait pour SSH.
Ces dernières années, le nouveau protocole HTTP a gagné en popularité du fait qu&#8217;il est plus simple à utiliser et plus efficace dans ses communications.
La nouvelle version est souvent appelée protocole HTTP « intelligent » et l&#8217;ancienne version protocole HTTP « idiot ».
Nous allons voir tout d&#8217;abord le protocole HTTP « intelligent ».</p>
<section class="sect3" title="HTTP Intelligent">
<h4 id="_http_intelligent">HTTP Intelligent</h4>
<p>
Le protocole HTTP « intelligent » se comporte de manière très similaire aux protocoles SSH ou Git mais fonctionne par-dessus les ports HTTP/S et peut utiliser différents mécanismes d&#8217;authentification, ce qui le rend souvent plus facile pour l&#8217;utilisateur que SSH, puisque l&#8217;on peut utiliser des méthodes telles que l&#8217;authentification par utilisateur/mot de passe plutôt que de devoir gérer des clés SSH.</p>
<p>C&#8217;est devenu probablement le moyen le plus populaire d&#8217;utiliser Git, car il peut être utilisé pour du service anonyme, comme le protocole <code class="literal">git://</code> aussi bien que pour pousser avec authentification et chiffrement, comme le protocole SSH.
Au lieu de devoir gérer différentes URL pour ces usages, vous pouvez maintenant utiliser une URL unique pour les deux.
Si vous essayez de pousser et que le dépôt requiert une authentification (ce qui est normal), le serveur peut demander un nom d&#8217;utilisateur et un mot de passe.
De même pour les accès en lecture.</p>
<p>En fait, pour les services tels que GitHub, l&#8217;URL que vous utilisez pour visualiser le dépôt sur le web (par exemple <code class="literal">https://github.com/schacon/simplegit[]</code>) est la même URL utilisable pour le cloner et, si vous en avez les droits, y pousser.</p>
</section>
<section class="sect3" title="HTTP idiot">
<h4 id="_http_idiot">HTTP idiot</h4>
<p>
Si le serveur ne répond pas avec un service Git HTTP intelligent, le client Git essayera de se rabattre sur le protocole HTTP « idiot ».
Le protocole idiot consiste à servir le dépôt Git nu comme des fichiers normaux sur un serveur web.
La beauté du protocole idiot réside dans sa simplicité de mise en place.
Tout ce que vous avez à faire, c&#8217;est de copier les fichiers de votre dépôt nu sous la racine de documents HTTP et de positionner un crochet (<strong>hook</strong>) <code class="literal">post-update</code> spécifique, et c&#8217;est tout (voir <a id="xref--ch08-customizing-git--s_git_hooks" href="ch08-customizing-git.xhtml#s_git_hooks" class="xref">Crochets Git</a>).
Dès ce moment, tous ceux qui peuvent accéder au serveur web sur lequel vous avez déposé votre dépôt peuvent le cloner.
Pour permettre un accès en lecture seule à votre dépôt via HTTP, faites quelque chose comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd /var/www/htdocs/
<span style="font-weight: bold">$</span> git clone --bare /chemin/vers/projet_git projetgit.git
<span style="font-weight: bold">$</span> cd projetgit.git
<span style="font-weight: bold">$</span> mv hooks/post-update.sample hooks/post-update
<span style="font-weight: bold">$</span> chmod a+x hooks/post-update</code></pre>
</figure>
<p>Et voilà !
Le crochet <code class="literal">post-update</code> livré par défaut avec Git lance la commande appropriée (<code class="literal">git update-server-info</code>) pour faire fonctionner correctement le clonage et la récupération HTTP.
Cette commande est lancée quand vous poussez sur ce dépôt (peut-être sur SSH). Ensuite, les autres personnes peuvent cloner via quelque chose comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://exemple.com/projetgit.git</code></pre>
</figure>
<p>Dans ce cas particulier, nous utilisons le chemin <code class="literal">/var/www/htdocs</code> qui est le plus commun pour une configuration Apache, mais vous pouvez utiliser n&#8217;importe quel serveur web statique – placez juste les dépôts nus dans son chemin.
Les données Git sont servies comme de simples fichiers statiques (voir <a href="ch10-git-internals.xhtml" class="xref">Les tripes de Git</a> pour la manière exacte dont elles sont servies).</p>
<p>Généralement, vous choisirez soit de lancer un serveur HTTP intelligent avec des droits en lecture/écriture ou de fournir simplement les fichiers en lecture seule par le protocole idiot.
Il est rare de mélanger les deux types de protocoles.</p>
</section>
<section class="sect3" title="Avantages">
<h4 id="_avantages_2">Avantages</h4>
<p>Nous nous concentrerons sur les avantages de la version intelligente du protocole sur HTTP.</p>
<p>La simplicité vient de l&#8217;utilisation d&#8217;une seule URL pour tous les types d&#8217;accès et de la demande d&#8217;authentification seulement en cas de besoin. Ces deux caractéristiques rendent les choses très faciles pour l&#8217;utilisateur final.
La possibilité de s&#8217;authentifier avec un nom d&#8217;utilisateur et un mot de passe apporte un gros avantage par rapport à SSH puisque les utilisateurs n&#8217;ont plus à générer localement les clés SSH et à télécharger leur clé publique sur le serveur avant de pouvoir interagir avec lui.
Pour les utilisateurs débutants ou pour des utilisateurs utilisant des systèmes où SSH est moins commun, c&#8217;est un avantage d&#8217;utilisabilité majeur.
C&#8217;est aussi un protocole très rapide et efficace, similaire à SSH.</p>
<p>Vous pouvez aussi servir vos dépôts en lecture seule sur HTTPS, ce qui signifie que vous pouvez chiffrer les communications ; ou vous pouvez pousser jusqu&#8217;à faire utiliser des certificats SSL à vos clients.</p>
<p>Un autre avantage est que HTTP/S sont des protocoles si souvent utilisés que les pare-feux d&#8217;entreprise sont souvent paramétrés pour les laisser passer.</p>
</section>
<section class="sect3" title="Inconvénients">
<h4 id="_inconvénients_2">Inconvénients</h4>
<p>Configurer Git sur HTTP/S peut être un peu plus difficile que sur SSH sur certains serveurs.
Mis à part cela, les autres protocoles ont peu d&#8217;avantages sur le protocole HTTP intelligent pour servir Git.</p>
<p>Si vous utilisez HTTP pour pousser de manière authentifiée, fournir vos information d&#8217;authentification est parfois plus compliqué qu&#8217;utiliser des clés sur SSH.
Il existe cependant des outils de mise en cache d&#8217;informations d&#8217;authentification, comme Keychain sur OSX et Credential Manager sur Windows pour rendre cela indolore.
Reportez-vous à <a id="xref--ch07-git-tools--s_credential_caching" href="ch07-git-tools.xhtml#s_credential_caching" class="xref">Stockage des identifiants</a> pour voir comment configurer la mise en cache des mots de passe HTTP sur votre système.</p>
</section>
</section>
<section class="sect2" title="Protocole SSH">
<h3 id="_protocole_ssh">Protocole SSH</h3>
<p>
SSH est un protocole répandu de transport pour Git en auto-hébergement.
Cela est dû au fait que l&#8217;accès SSH est déjà en place à de nombreux endroits et que si ce n&#8217;est pas le cas, cela reste très facile à faire.
Cela est aussi dû au fait que SSH est un protocole authentifié ; et comme il est très répandu, il est généralement facile à mettre en œuvre et à utiliser.</p>
<p>Pour cloner un dépôt Git à travers SSH, spécifiez le préfixe <code class="literal">ssh://</code> dans l&#8217;URL comme ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone ssh://utilisateur@serveur/projet.git</code></pre>
</figure>
<p>Vous pouvez utiliser aussi la syntaxe scp habituelle avec le protocole SSH :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone utilisateur@serveur:projet.git</code></pre>
</figure>
<p>Vous pouvez aussi ne pas spécifier de nom d&#8217;utilisateur et Git utilisera par défaut le nom de login.</p>
<section class="sect3" title="Avantages">
<h4 id="_avantages_3">Avantages</h4>
<p>Les avantages liés à l&#8217;utilisation de SSH sont nombreux.
Premièrement, SSH est relativement simple à mettre en place, les <em>daemons</em> SSH sont facilement disponibles, les administrateurs réseau sont habitués à les gérer et de nombreuses distributions de systèmes d&#8217;exploitation en disposent ou proposent des outils pour les gérer.
Ensuite, l&#8217;accès distant à travers SSH est sécurisé, toutes les données sont chiffrées et authentifiées.
Enfin, comme les protocoles HTTP/S, Git et local, SSH est efficace et permet de comprimer autant que possible les données avant de les transférer.</p>
</section>
<section class="sect3" title="Inconvénients">
<h4 id="_inconvénients_3">Inconvénients</h4>
<p>Le point négatif avec SSH est qu&#8217;il est impossible de proposer un accès anonyme au dépôt.
Les accès sont régis par les permissions SSH, même pour un accès en lecture seule, ce qui s&#8217;oppose à une optique open source.
Si vous souhaitez utiliser Git dans un environnement d&#8217;entreprise, SSH peut bien être le seul protocole nécessaire.
Si vous souhaitez proposer de l&#8217;accès anonyme en lecture seule à vos projets, vous aurez besoin de SSH pour vous permettre de pousser mais un autre protocole sera nécessaire pour permettre à d&#8217;autres de tirer.</p>
</section>
</section>
<section class="sect2" title="Protocole Git">
<h3 id="_protocole_git">Protocole Git</h3>
<p>
Vient ensuite le protocole Git.
Celui-ci est géré par un <em>daemon</em> spécial livré avec Git. Ce <em>daemon</em> (démon, processus en arrière-plan) écoute sur un port dédié (9418) et propose un service similaire au protocole SSH, mais sans aucune sécurisation.
Pour qu&#8217;un dépôt soit publié via le protocole Git, le fichier <code class="literal">git-daemon-export-ok</code> doit exister mais mise à part cette condition sans laquelle le <em>daemon</em> refuse de publier un projet, il n&#8217;y a aucune sécurité.
Soit le dépôt Git est disponible sans restriction en lecture, soit il n&#8217;est pas publié.
Cela signifie qu&#8217;il ne permet pas de pousser des modifications.
Vous pouvez activer la capacité à pousser mais étant donné l&#8217;absence d&#8217;authentification, n&#8217;importe qui sur Internet ayant trouvé l&#8217;URL du projet peut pousser sur le dépôt.
Autant dire que ce mode est rarement recherché.</p>
<section class="sect3" title="Avantages">
<h4 id="_avantages_4">Avantages</h4>
<p>Le protocole Git est souvent le protocole avec la vitesse de transfert la plus rapide.
Si vous devez servir un gros trafic pour un projet public ou un très gros projet qui ne nécessite pas d&#8217;authentification en lecture, il est très probable que vous devriez installer un <em>daemon</em> Git.
Il utilise le même mécanisme de transfert de données que SSH, la surcharge du chiffrement et de l&#8217;authentification en moins.</p>
</section>
<section class="sect3" title="Inconvénients">
<h4 id="_inconvénients_4">Inconvénients</h4>
<p>Le défaut du protocole Git est le manque d&#8217;authentification.
N&#8217;utiliser que le protocole Git pour accéder à un projet n&#8217;est généralement pas suffisant.
Il faut le coupler avec un accès SSH ou HTTPS pour quelques développeurs qui auront le droit de pousser (écrire) et le garder en accès <code class="literal">git://</code> pour la lecture seule.
C&#8217;est aussi le protocole le plus difficile à mettre en place.
Il doit être géré par son propre <em>daemon</em> qui est spécifique.
Il nécessite la configuration d&#8217;un <em>daemon</em> <code class="literal">xinetd</code> ou apparenté, ce qui est loin d&#8217;être simple.
Il nécessite aussi un accès à travers le pare-feu au port 9418 qui n&#8217;est pas un port ouvert en standard dans les pare-feux professionnels.
Derrière les gros pare-feux professionnels, ce port obscur est tout simplement bloqué.</p>
</section>
</section>
</section>
<section class="sect1" title="Installation de Git sur un serveur">
<h2 id="s_git_on_the_server">Installation de Git sur un serveur</h2>
<p>Nous allons à présent traiter de la configuration d&#8217;un service Git gérant ces protocoles sur votre propre serveur.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Les commandes et étapes décrites ci-après s&#8217;appliquent à des installations simplifiées sur un serveur à base de Linux, bien qu&#8217;il soit aussi possible de faire fonctionner ces services sur des serveurs Mac ou Windows.
La mise en place effective d&#8217;un serveur en production au sein d&#8217;une infrastructure englobera vraisemblablement des différences dans les mesures de sécurité et les outils système, mais ceci devrait permettre de se faire une idée générale des besoins.</p>
</div>
</aside>
<p>Pour réaliser l&#8217;installation initiale d&#8217;un serveur Git, il faut exporter un dépôt existant dans un nouveau dépôt nu — un dépôt qui ne contient pas de copie de répertoire de travail.
C&#8217;est généralement simple à faire.
Pour cloner votre dépôt en créant un nouveau dépôt nu, lancez la commande clone avec l&#8217;option <code class="literal">--bare</code>.
Par convention, les répertoires de dépôt nu finissent en <code class="literal">.git</code>, de cette manière :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone --bare mon_project mon_projet.git
Clonage dans le dépôt nu &#39;mon_projet.git&#39;...
fait.</code></pre>
</figure>
<p>Vous devriez maintenant avoir une copie des données de Git dans votre répertoire <code class="literal">mon_project.git</code>.</p>
<p>C&#8217;est grossièrement équivalent à :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp -Rf mon_projet/.git mon_projet.git</code></pre>
</figure>
<p>Il y a quelques légères différences dans le fichier de configuration mais pour l&#8217;utilisation envisagée, c&#8217;est très proche.
La commande extrait le répertoire Git sans répertoire de travail et crée un répertoire spécifique pour l&#8217;accueillir.</p>
<section class="sect2" title="Copie du dépôt nu sur un serveur">
<h3 id="s_bare_repo">Copie du dépôt nu sur un serveur</h3>
<p>À présent que vous avez une copie nue de votre dépôt, il ne reste plus qu&#8217;à la placer sur un serveur et à régler les protocoles.
Supposons que vous avez mis en place un serveur nommé <code class="literal">git.exemple.com</code> auquel vous avez accès par SSH et que vous souhaitez stocker vos dépôts Git dans le répertoire <code class="literal">/srv/git</code>.
En supposant que <code class="literal">/srv/git</code> existe, vous pouvez mettre en place votre dépôt en copiant le dépôt nu :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> scp -r mon_projet.git utilisateur@git.exemple.com:/srv/git</code></pre>
</figure>
<p>À partir de maintenant, tous les autres utilisateurs disposant d&#8217;un accès SSH au serveur et ayant un accès en lecture seule au répertoire <code class="literal">/srv/git</code> peuvent cloner votre dépôt en lançant la commande :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone utilisateur@git.exemple.com:/srv/git/mon_projet.git</code></pre>
</figure>
<p>Si un utilisateur se connecte via SSH au serveur et a accès en écriture au répertoire <code class="literal">/srv/git/mon_projet.git</code>, il aura automatiquement accès pour pousser.</p>
<p>Git ajoutera automatiquement les droits de groupe en écriture à un dépôt si vous lancez la commande <code class="literal">git init</code> avec l&#8217;option <code class="literal">--shared</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh utilisateur@git.exemple.com
<span style="font-weight: bold">$</span> cd /srv/git/mon_projet.git
<span style="font-weight: bold">$</span> git init --bare --shared</code></pre>
</figure>
<p>Vous voyez comme il est simple de prendre un dépôt Git, créer une version nue et la placer sur un serveur auquel vous et vos collaborateurs avez accès en SSH.
Vous voilà prêts à collaborer sur le même projet.</p>
<p>Il faut noter que c&#8217;est littéralement tout ce dont vous avez besoin pour démarrer un serveur Git utile auquel plusieurs personnes ont accès : ajoutez simplement des comptes SSH sur un serveur, et collez un dépôt nu quelque part où tous les utilisateurs ont accès en lecture et écriture.
Vous êtes prêts à travailler, vous n&#8217;avez besoin de rien d&#8217;autre.</p>
<p>Dans les chapitres à venir, nous traiterons de mises en place plus sophistiquées.
Ces sujets incluront l&#8217;élimination du besoin de créer un compte système pour chaque utilisateur, l&#8217;accès public aux dépôts, la mise en place d&#8217;interfaces utilisateur web, etc.
Néanmoins, gardez à l&#8217;esprit que pour collaborer avec quelques personnes sur un projet privé, tout ce qu&#8217;il faut, c&#8217;est un serveur SSH et un dépôt nu.</p>
</section>
<section class="sect2" title="Petites installations">
<h3 id="_petites_installations">Petites installations</h3>
<p>Si vous travaillez dans un petit groupe ou si vous n&#8217;êtes qu&#8217;en phase d&#8217;essai de Git au sein de votre société avec peu de développeurs, les choses peuvent rester simples.
Un des aspects les plus compliqués de la mise en place d&#8217;un serveur Git est la gestion des utilisateurs.
Si vous souhaitez que certains dépôts ne soient accessibles à certains utilisateurs qu&#8217;en lecture seule et en lecture/écriture pour d&#8217;autres, la gestion des accès et des permissions peut devenir difficile à régler.</p>
<section class="sect3" title="Accès SSH">
<h4 id="_accès_ssh">Accès SSH</h4>
<p>
Si vous disposez déjà d&#8217;un serveur auquel tous vos développeurs ont un accès SSH, il est généralement plus facile d&#8217;y mettre en place votre premier dépôt car vous n&#8217;aurez quasiment aucun réglage supplémentaire à faire (comme nous l&#8217;avons expliqué dans le chapitre précédent).
Si vous souhaitez des permissions d&#8217;accès plus complexes, vous pouvez les mettre en place par le jeu des permissions standards sur le système de fichiers du système d&#8217;exploitation de votre serveur.</p>
<p>Si vous souhaitez placer vos dépôts sur un serveur qui ne dispose pas déjà de comptes pour chacun des membres de votre équipe qui aurait accès en écriture, alors vous devrez mettre en place un accès SSH pour eux.
En supposant que pour vos dépôts, vous disposiez déjà d&#8217;un serveur SSH installé et auquel vous avez accès.</p>
<p>Il y a quelques moyens de donner un accès à tout le monde dans l&#8217;équipe.
Le premier est de créer des comptes pour tout le monde, ce qui est logique mais peut s&#8217;avérer lourd.
Vous ne souhaiteriez sûrement pas lancer <code class="literal">adduser</code> et entrer un mot de passe temporaire pour chaque utilisateur.</p>
<p>Une seconde méthode consiste à créer un seul utilisateur Git sur la machine, demander à chaque développeur nécessitant un accès en écriture de vous envoyer une clé publique SSH et d&#8217;ajouter la-dite clé au fichier <code class="literal">~/.ssh/authorized_keys</code> de votre utilisateur Git.
À partir de là, tout le monde sera capable d&#8217;accéder à la machine via l&#8217;utilisateur Git.
Cela n&#8217;affecte en rien les données de <em>commit</em> — les informations de l&#8217;utilisateur SSH par lequel on se connecte n&#8217;affectent pas les données de <em>commit</em> enregistrées.</p>
<p>Une dernière méthode consiste à faire une authentification SSH auprès d&#8217;un serveur LDAP ou tout autre système d&#8217;authentification centralisé que vous utiliseriez déjà.
Tant que chaque utilisateur peut accéder à un shell sur la machine, n&#8217;importe quel schéma d&#8217;authentification SSH devrait fonctionner.</p>
</section>
</section>
</section>
<section class="sect1" title="Génération des clés publiques SSH">
<h2 id="s_generate_ssh_key">Génération des clés publiques SSH</h2>
<p></p>
<p>Cela dit, de nombreux serveurs Git utilisent une authentification par clés publiques SSH.
Pour fournir une clé publique, chaque utilisateur de votre système doit la générer s&#8217;il n&#8217;en a pas déjà.
Le processus est similaire sur tous les systèmes d&#8217;exploitation.
Premièrement, l&#8217;utilisateur doit vérifier qu&#8217;il n&#8217;en a pas déjà une.
Par défaut, les clés SSH d&#8217;un utilisateur sont stockées dans le répertoire <code class="literal">~/.ssh</code> du compte.
Vous pouvez facilement vérifier si vous avez déjà une clé en listant le contenu de ce répertoire :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd ~/.ssh
<span style="font-weight: bold">$</span> ls
authorized_keys2  id_dsa       known_hosts
config            id_dsa.pub</code></pre>
</figure>
<p>Recherchez une paire de fichiers appelés <em>quelquechose</em> et <em>quelquechose</em>`.pub` où le <em>quelquechose</em> en question est généralement <code class="literal">id_dsa</code> ou <code class="literal">id_rsa</code>.
Le fichier en <code class="literal">.pub</code> est la clé publique tandis que l&#8217;autre est la clé privée.
Si vous ne voyez pas ces fichiers (ou n&#8217;avez même pas de répertoire <code class="literal">.ssh</code>), vous pouvez les créer en lançant un programme appelé <code class="literal">ssh-keygen</code> fourni par le paquet SSH sur les systèmes Linux/Mac et MSysGit pour Windows :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/schacon/.ssh/id_rsa):
Created directory &#39;/home/schacon/.ssh&#39;.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/schacon/.ssh/id_rsa.
Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</code></pre>
</figure>
<p>Premièrement, le programme demande confirmation de l&#8217;endroit où vous souhaitez sauvegarder la clé (<code class="literal">.ssh/id_rsa</code>) puis il demande deux fois d&#8217;entrer un mot de passe qui peut être laissé vide si vous ne souhaitez pas devoir le taper quand vous utilisez la clé.</p>
<p>Maintenant, chaque utilisateur ayant suivi ces indications doit envoyer la clé publique à la personne en charge de l&#8217;administration du serveur Git (en supposant que vous utilisez un serveur SSH réglé pour l&#8217;utilisation de clés publiques).
Ils doivent copier le contenu du fichier <code class="literal">.pub</code> et l&#8217;envoyer par courriel.
Les clés publiques ressemblent à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@mylaptop.local</code></pre>
</figure>
<p>Pour un tutoriel plus approfondi sur la création de clé SSH sur différents systèmes d&#8217;exploitation, référez-vous au guide GitHub sur les clés SSH à <a href="https://help.github.com/articles/generating-ssh-keys" class="link">https://help.github.com/articles/generating-ssh-keys</a>.</p>
</section>
<section class="sect1" title="Mise en place du serveur">
<h2 id="s_setting_up_server">Mise en place du serveur</h2>
<p>Parcourons les étapes de la mise en place d&#8217;un accès SSH côté serveur.
Dans cet exemple, vous utiliserez la méthode des <code class="literal">authorized_keys</code> pour authentifier vos utilisateurs.
Nous supposerons également que vous utilisez une distribution Linux standard telle qu&#8217;Ubuntu.
Premièrement, créez un utilisateur <em>git</em> et un répertoire <code class="literal">.ssh</code> pour cet utilisateur.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo adduser git
<span style="font-weight: bold">$</span> su git
<span style="font-weight: bold">$</span> cd
<span style="font-weight: bold">$</span> mkdir .ssh &amp;&amp; chmod 700 .ssh
<span style="font-weight: bold">$</span> touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</code></pre>
</figure>
<p>Ensuite, vous devez ajouter la clé publique d&#8217;un développeur au fichier <code class="literal">authorized_keys</code> de l&#8217;utilisateur Git.
Supposons que vous avez reçu quelques clés par courriel et les avez sauvées dans des fichiers temporaires.
Pour rappel, une clé publique ressemble à ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair</code></pre>
</figure>
<p>Il suffit de les ajouter au fichier <code class="literal">authorized_keys</code> de l&#8217;utilisateur <code class="literal">git</code> dans son répertoire <code class="literal">.ssh</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
<span style="font-weight: bold">$</span> cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
<span style="font-weight: bold">$</span> cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre>
</figure>
<p>Maintenant, vous pouvez créer un dépôt vide nu en lançant la commande <code class="literal">git init</code> avec l&#8217;option <code class="literal">--bare</code>, ce qui initialise un dépôt sans répertoire de travail :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd /opt/git
<span style="font-weight: bold">$</span> mkdir project.git
<span style="font-weight: bold">$</span> cd project.git
<span style="font-weight: bold">$</span> git init --bare
Initialized empty Git repository in /opt/git/project.git/</code></pre>
</figure>
<p>Alors, John, Josie ou Jessica peuvent pousser la première version de leur projet vers ce dépôt en l&#8217;ajoutant en tant que dépôt distant et en lui poussant une branche.
Notons que quelqu&#8217;un doit se connecter par shell au serveur et créer un dépôt nu pour chaque ajout de projet.
Supposons que le nom du serveur soit <code class="literal">gitserveur</code>.
Si vous l&#8217;hébergez en interne et avez réglé le DNS pour faire pointer <code class="literal">gitserveur</code> sur ce serveur, alors vous pouvez utiliser les commandes suivantes telles quelles (en supposant que <code class="literal">monprojet</code> est un projet existant et comprenant des fichiers) :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Sur l<span style="font-style: italic">&#39;ordinateur de John</span>
<span style="font-weight: bold">$</span><span style="font-style: italic"> cd monproject</span>
<span style="font-weight: bold">$</span><span style="font-style: italic"> git init</span>
<span style="font-weight: bold">$</span><span style="font-style: italic"> git add .</span>
<span style="font-weight: bold">$</span><span style="font-style: italic"> git commit -m &#39;</span>première validation<span style="border: 1px solid #FF0000">&#39;</span>
<span style="font-weight: bold">$</span> git remote add origin git@gitserveur:/opt/git/projet.git
<span style="font-weight: bold">$</span> git push origin master</code></pre>
</figure>
<p>À présent, les autres utilisateurs peuvent cloner le dépôt et y pousser leurs modifications aussi simplement :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone git@gitserveur:/opt/git/projet.git
<span style="font-weight: bold">$</span> cd projet
<span style="font-weight: bold">$</span> vim LISEZMOI
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;correction du fichier LISEZMOI&#39;</span>
<span style="font-weight: bold">$</span> git push origin master</code></pre>
</figure>
<p>De cette manière, vous pouvez rapidement mettre en place un serveur Git en lecture/écriture pour une poignée de développeurs.</p>
<p>Il faut aussi noter que pour l&#8217;instant tous ces utilisateurs peuvent aussi se connecter au serveur et obtenir un shell en tant qu&#8217;utilisateur « git ».
Si vous souhaitez restreindre ces droits, il faudra changer le shell pour quelque chose d&#8217;autre dans le fichier <code class="literal">passwd</code>.</p>
<p>Vous pouvez simplement restreindre l&#8217;utilisateur <em>git</em> à des actions Git avec un shell limité appelé <code class="literal">git-shell</code> qui est fourni avec Git.
Si vous configurez ce shell comme shell de login de l&#8217;utilisateur <em>git</em>, l&#8217;utilisateur <em>git</em> ne peut pas avoir de shell normal sur ce serveur.
Pour utiliser cette fonction, spécifiez <code class="literal">git-shell</code> en lieu et place de bash ou csh pour shell de l&#8217;utilisateur.
Pour faire cela, vous devez d&#8217;abord ajouter <code class="literal">git-shell</code> à <code class="literal">/etc/shells</code> s&#8217;il n&#8217;y est pas déjà :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /etc/shells   <span style="font-style: italic"># voir si `git-shell` est déjà déclaré.  Sinon...</span>
<span style="font-weight: bold">$</span> which git-shell   <span style="font-style: italic"># s&#39;assurer que git-shell est installé sur le système</span>
<span style="font-weight: bold">$</span> sudo vim /etc/shells  <span style="font-style: italic"># et ajouter le chemin complet vers git-shell</span></code></pre>
</figure>
<p>Maintenant, vous pouvez éditer le shell de l&#8217;utilisateur en utilisant <code class="literal">chsh &lt;utilisateur&gt; -s &lt;shell&gt;</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo chsh git -s <span style="font-style: italic">`</span>which git-shell<span style="font-style: italic">`</span></code></pre>
</figure>
<p>À présent, l&#8217;utilisateur <em>git</em> ne peut plus utiliser la connexion SSH que pour pousser et tirer sur des dépôts Git, il ne peut plus ouvrir un shell.
Si vous essayez, vous verrez un rejet de login :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh git@gitserveur
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserveur closed.</code></pre>
</figure>
<p>Maintenant, les commandes réseau Git continueront de fonctionner correctement mais les utilisateurs ne pourront plus obtenir de shell.
Comme la sortie l&#8217;indique, vous pouvez aussi configurer un répertoire dans le répertoire personnel de l&#8217;utilisateur « git » qui va personnaliser légèrement le <code class="literal">git-shell</code>.
Par exemple, vous pouvez restreindre les commandes Git que le serveur accepte ou vous pouvez personnaliser le message que les utilisateurs verront s&#8217;ils essaient de se connecter en SSH comme ci-dessus.
Lancer <code class="literal">git help shell</code> pour plus d&#8217;informations sur la personnalisation du shell.</p>
</section>
<section class="sect1" title="Démon (Daemon) Git">
<h2 id="_démon_em_daemon_em_git">Démon (<em>Daemon</em>) Git</h2>
<p>
Dans la suite, nous allons configurer un <em>daemon</em> qui servira des dépôts sur le protocole « Git ».
C&#8217;est un choix répandu pour permettre un accès rapide sans authentification à vos données Git.
Souvenez-vous que du fait de l&#8217;absence d&#8217;authentification, tout ce qui est servi sur ce protocole est public au sein de son réseau.</p>
<p>Mis en place sur un serveur à l&#8217;extérieur de votre pare-feu, il ne devrait être utilisé que pour des projets qui sont destinés à être visibles publiquement par le monde entier.
Si le serveur est derrière le pare-feu, il peut être utilisé pour des projets avec accès en lecture seule pour un grand nombre d&#8217;utilisateurs ou des ordinateurs (intégration continue ou serveur de compilation) pour lesquels vous ne souhaitez pas avoir à gérer des clés SSH.</p>
<p>En tout cas, le protocole Git est relativement facile à mettre en place.
Grossièrement, il suffit de lancer la commande suivante en tant que <em>daemon</em> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</code></pre>
</figure>
<p><code class="literal">--reuseaddr</code> autorise le serveur à redémarrer sans devoir attendre que les anciennes connexions expirent, l&#8217;option <code class="literal">--base-path</code> autorise les utilisateurs à cloner des projets sans devoir spécifier le chemin complet, et le chemin en fin de ligne indique au <em>daemon</em> Git l&#8217;endroit où chercher des dépôts à exporter.
Si vous utilisez un pare-feu, il sera nécessaire de rediriger le port 9418 sur la machine hébergeant le serveur.</p>
<p>Transformer ce processus en <em>daemon</em> peut s&#8217;effectuer de différentes manières qui dépendent du système d&#8217;exploitation sur lequel il est lancé.
Sur une machine Ubuntu, c&#8217;est un script Upstart.
Donc dans le fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>/etc/event.d/local-git-daemon</code></pre>
</figure>
<p>mettez le script suivant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>start on startup
stop on shutdown
exec /usr/bin/git daemon \
    --user=git --group=git \
    --reuseaddr \
    --base-path=/opt/git/ \
    /opt/git/
respawn</code></pre>
</figure>
<p>Par sécurité, ce <em>daemon</em> devrait être lancé par un utilisateur n&#8217;ayant que des droits de lecture seule sur les dépôts — simplement en créant un nouvel utilisateur « git-ro » qui servira à lancer le <em>daemon</em>.
Par simplicité, nous le lancerons avec le même utilisateur « git » qui est utilisé par <code class="literal">git-shell</code>.</p>
<p>Au redémarrage de la machine, votre <em>daemon</em> Git démarrera automatiquement et redémarrera s&#8217;il meurt.
Pour le lancer sans avoir à redémarrer, vous pouvez lancer ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>initctl start local-git-daemon</code></pre>
</figure>
<p>Sur d&#8217;autres systèmes, le choix reste large, allant de <code class="literal">xinetd</code> à un script de système <code class="literal">sysvinit</code> ou à tout autre moyen — tant que le programme est démonisé et surveillé.</p>
<p>Ensuite, il faut spécifier à Git quels dépôts sont autorisés en accès non authentifié au moyen du serveur.
Dans chaque dépôt concerné, il suffit de créer un fichier appelé <code class="literal">git-daemon-export-ok</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd /chemin/au/projet.git
<span style="font-weight: bold">$</span> touch git-daemon-export-ok</code></pre>
</figure>
<p>La présence de ce fichier indique à Git que ce projet peut être servi sans authentification.</p>
</section>
<section class="sect1" title="HTTP intelligent">
<h2 id="_http_intelligent_2">HTTP intelligent</h2>
<p>
Nous avons à présent un accès authentifié par SSH et un accès non authentifié par <code class="literal">git://</code>, mais il existe aussi un protocole qui peut faire les deux à la fois.
La configuration d&#8217;un HTTP intelligent revient simplement à activer sur le serveur un script CGI livré avec Git qui s&#8217;appelle <code class="literal">git-http-backend</code>.
Ce CGI va lire le chemin et les entêtes envoyés par un <code class="literal">git fetch</code> ou un <code class="literal">git push</code> à une URL donnée et déterminer si le client peut communiquer sur HTTP (ce qui est vrai pour tout client depuis la version 1.6.6).
Si le CGI détecte que le client est intelligent, il va commencer à communiquer par protocole intelligent, sinon il repassera au comportement du protocole idiot (ce qui le rend de ce fait compatible avec les vieux clients).</p>
<p>Détaillons une installation de base.
Nous la réaliserons sur un serveur web Apache comme serveur CGI.
Si Apache n&#8217;est pas installé sur votre PC, vous pouvez y remédier avec une commande :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo apt-get install apache2 apache2-utils
<span style="font-weight: bold">$</span> a2enmod cgi alias env</code></pre>
</figure>
<p>Cela a aussi pour effet d&#8217;activer les modules <code class="literal">mod_cgi</code>, <code class="literal">mod_alias</code>, et <code class="literal">mod_env</code> qui sont nécessaires au fonctionnement du serveur.</p>
<p>Ensuite, nous devons ajouter quelques lignes à la configuration d&#8217;Apache pour qu&#8217;il lance <code class="literal">git-http-backend</code> comme gestionnaire de tous les chemins du serveur web sous <code class="literal">/git</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>SetEnv GIT_PROJECT_ROOT /opt/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/</code></pre>
</figure>
<p>Si vous ne définissez pas la variable d&#8217;environnement <code class="literal">GIT_HTTP_EXPORT_ALL</code>, Git ne servira aux utilisateurs non authentifiés que les dépôts comprenant le fichier <code class="literal">git-daemon-export-ok</code>, de la même manière que le <em>daemon</em> Git.</p>
<p>Puis, nous allons indiquer à Apache qu&#8217;il doit accepter les requêtes sur ce chemin avec quelque chose comme :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>&lt;Directory &quot;/usr/lib/git-core*&quot;&gt;
   Options ExecCGI Indexes
   Order allow,deny
   Allow from all
   Require all granted
&lt;/Directory&gt;</code></pre>
</figure>
<p>Enfin, il faut forcer l&#8217;authentification pour l&#8217;écriture, probablement avec un bloc <code class="literal">Auth</code> comme celui-ci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>&lt;LocationMatch &quot;^/git/.*/git-receive-pack$&quot;&gt;
    AuthType Basic
    AuthName &quot;Git Access&quot;
    AuthUserFile /opt/git/.htpasswd
    Require valid-user
&lt;/LocationMatch&gt;</code></pre>
</figure>
<p>Il faudra donc créer un fichier <code class="literal">.htaccess</code> contenant les mots de passe de tous les utilisateurs valides.
Voici un exemple d&#8217;ajout d&#8217;un utilisateur <code class="literal">schacon</code> au fichier :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> htdigest -c /opt/git/.htpasswd <span style="font-style: italic">&quot;Git Access&quot;</span> schacon</code></pre>
</figure>
<p>Il existe des milliers de façons d&#8217;authentifier des utilisateurs avec Apache, il suffira d&#8217;en choisir une et de la mettre en place.
L&#8217;exemple ci-dessus n&#8217;est que le plus simple.
Vous désirerez sûrement gérer tout ceci sous SSL pour que vos données soient chiffrées.</p>
<p>Nous ne souhaitons pas nous appesantir spécifiquement sur la configuration d&#8217;Apache, car on peut utiliser un serveur différent ou avoir besoin d&#8217;une authentification différente.
L&#8217;idée générale reste que Git est livré avec un CGI appelé <code class="literal">git-http-backend</code> qui, après authentification, va gérer toute la négociation pour envoyer et recevoir les données sur HTTP.
Il ne gère pas l&#8217;authentification par lui-même, mais peut être facilement contrôlé à la couche serveur web qui l&#8217;invoque.
Cela peut être réalisé avec n&#8217;importe quel serveur web gérant le CGI, donc celui que vous connaissez le mieux.</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Pour plus d&#8217;informations sur la configuration de l&#8217;authentification dans Apache, référez-vous à la documentation d&#8217;Apache : <a href="http://httpd.apache.org/docs/current/howto/auth.html" class="link">http://httpd.apache.org/docs/current/howto/auth.html</a></p>
</div>
</aside>
</section>
<section class="sect1" title="GitWeb">
<h2 id="_gitweb">GitWeb</h2>
<p>
Après avoir réglé les accès de base en lecture/écriture et en lecture seule pour vos projets, vous souhaiterez peut-être mettre en place une interface web simple de visualisation.
Git fournit un script CGI appelé GitWeb qui est souvent utilisé à cette fin.</p>
<figure id="gitweb" class="image">
<div class="content">
<img src="images/git-instaweb.png" alt="L'interface web de visualisation Gitweb."/>
</div>
<figcaption>Figure 1. L&#8217;interface web de visualisation Gitweb.</figcaption>
</figure>
<p>Si vous souhaitez vérifier à quoi GitWeb ressemblerait pour votre projet, Git fournit une commande pour démarrer une instance temporaire de serveur si vous avez un serveur léger tel que <code class="literal">lighttpd</code> ou <code class="literal">webrick</code> sur votre système.
Sur les machines Linux, <code class="literal">lighttpd</code> est souvent pré-installé et vous devriez pouvoir le démarrer en tapant <code class="literal">git instaweb</code> dans votre répertoire de travail.
Si vous utilisez un Mac, Ruby est installé de base avec Léopard, donc <code class="literal">webrick</code> est une meilleure option.
Pour démarrer <code class="literal">instaweb</code> avec un gestionnaire autre que <code class="literal">lighttpd</code>, vous pouvez le lancer avec l&#8217;option <code class="literal">--httpd</code>.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git instaweb --httpd=webrick
[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</code></pre>
</figure>
<p>Cette commande démarre un serveur HTTP sur le port 1234 et lance automatiquement un navigateur Internet qui ouvre la page d&#8217;accueil.
C&#8217;est vraiment très simple.
Pour arrêter le serveur, il suffit de lancer la même commande, mais avec l&#8217;option <code class="literal">--stop</code> :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git instaweb --httpd=webrick --stop</code></pre>
</figure>
<p>Si vous souhaitez fournir l&#8217;interface web en permanence sur le serveur pour votre équipe ou pour un projet opensource que vous hébergez, il sera nécessaire d&#8217;installer le script CGI pour qu&#8217;il soit appelé par votre serveur web.
Quelques distributions Linux ont un package <code class="literal">gitweb</code> qu&#8217;il suffira d&#8217;installer via <code class="literal">apt</code> ou <code class="literal">dnf</code>, ce qui est une possibilité.
Nous détaillerons tout de même rapidement l&#8217;installation manuelle de GitWeb.
Premièrement, le code source de Git qui fournit GitWeb est nécessaire pour pouvoir générer un script CGI personnalisé :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone git://git.kernel.org/pub/scm/git/git.git
<span style="font-weight: bold">$</span> cd git/
<span style="font-weight: bold">$</span> make GITWEB_PROJECTROOT=<span style="font-style: italic">&quot;/opt/git&quot;</span> prefix=/usr gitweb
    SUBDIR gitweb
    SUBDIR ../
make[2]: `GIT-VERSION-FILE&#39; is up to date.
    GEN gitweb.cgi
    GEN static/gitweb.js
<span style="font-weight: bold">$</span> sudo cp -Rf gitweb /var/www/</code></pre>
</figure>
<p>Notez que vous devez indiquer où trouver les dépôts Git au moyen de la variable <code class="literal">GITWEB_PROJECTROOT</code>.
Maintenant, il faut paramétrer dans Apache l&#8217;utilisation de CGI pour ce script, en spécifiant un nouveau VirtualHost :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>&lt;VirtualHost *:80&gt;
    ServerName gitserver
    DocumentRoot /var/www/gitweb
    &lt;Directory /var/www/gitweb&gt;
        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
        AllowOverride All
        order allow,deny
        Allow from all
        AddHandler cgi-script cgi
        DirectoryIndex gitweb.cgi
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;</code></pre>
</figure>
<p>Une fois de plus, GitWeb peut être géré par tout serveur web capable de prendre en charge CGI ou Perl.
La mise en place ne devrait pas être plus difficile avec un autre serveur.
Après redémarrage du serveur, vous devriez être capable de visiter <code class="literal">http://gitserveur/</code> pour visualiser vos dépôts en ligne.</p>
</section>
<section class="sect1" title="GitLab">
<h2 id="_gitlab">GitLab</h2>
<p>
GitWeb reste tout de même simpliste.
Si vous cherchez un serveur Git plus moderne et complet, il existe quelques solutions libres pertinentes.
Comme GitLab est un des plus populaires, nous allons prendre son installation et son utilisation comme exemple.
Cette solution est plus complexe que l&#8217;option GitWeb et demandera indubitablement plus de maintenance, mais elle est aussi plus complète.</p>
<section class="sect2" title="Installation">
<h3 id="_installation">Installation</h3>
<p>GitLab est une application web reposant sur une base de données, ce qui rend son installation un peu plus lourde que certains autres serveurs Git.
Celle-ci est heureusement très bien documentée et supportée.</p>
<p>GitLab peut s&#8217;installer de différentes manières.
Pour obtenir rapidement quelque chose qui tourne, vous pouvez télécharger une image de machine virtuelle ou un installateur rapide depuis <a href="https://bitnami.com/stack/gitlab" class="link">https://bitnami.com/stack/gitlab</a>, puis configurer plus finement selon vos besoins.
Une touche particulière incluse par Bitnami concerne l&#8217;écran d&#8217;identification (accessible via <code class="literal">alt + →</code>) qui vous indique l&#8217;adresse IP, l&#8217;utilisateur et le mot de passe par défaut de l&#8217;instance GitLab installée.</p>
<figure id="bitnami" class="image">
<div class="content">
<img src="images/bitnami.png" alt="L'écran d’identification de la machine virtuelle du GitLab de Bitnami."/>
</div>
<figcaption>Figure 2. L&#8217;écran d’identification de la machine virtuelle du GitLab de Bitnami.</figcaption>
</figure>
<p>Pour toute autre méthode, suivez les instructions du readme du <em>GitLab Community Edition</em>, qui est consultable à <a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master" class="link">https://gitlab.com/gitlab-org/gitlab-ce/tree/master</a>.
Vous y trouverez une aide pour installer GitLab en utilisant une recette Chef, une machine virtuelle sur Digital Ocean, ou encore via RPM ou DEB (qui, au moment de la rédaction du présent livre sont en bêta).
Il existe aussi des guides « non-officiels » pour faire fonctionner GitLab avec des systèmes d&#8217;exploitation ou de base données non standards, un script d&#8217;installation totalement manuel et d&#8217;autres guides couvrant d&#8217;autres sujets.</p>
</section>
<section class="sect2" title="Administration">
<h3 id="_administration">Administration</h3>
<p>L&#8217;interface d&#8217;administration de GitLab passe par le web.
Pointez simplement votre navigateur sur le nom d&#8217;hôte ou l&#8217;adresse IP où GitLab est hébergé et identifiez-vous comme administrateur.
L&#8217;utilisateur par défaut est <code class="literal">admin@local.host</code> et le mot de passe par défaut est <code class="literal">5iveL!fe</code> (qu&#8217;il vous sera demandé de changer dès la première connexion).
Une fois identifié, cliquez sur l’icône « Admin area » dans le menu en haut à droite.</p>
<figure id="gitlab_menu" class="image">
<div class="content">
<img src="images/gitlab-menu.png" alt="L’entrée « Admin area » dans le menu GitLab."/>
</div>
<figcaption>Figure 3. L&#8217;entrée « Admin area » dans le menu GitLab.</figcaption>
</figure>
<section class="sect3" title="Utilisateurs">
<h4 id="_utilisateurs">Utilisateurs</h4>
<p>Les utilisateurs dans GitLab sont des comptes qui correspondent à des personnes.
Les comptes utilisateurs ne sont pas très complexes ; ce sont principalement des collections d&#8217;informations personnelles rattachées à chaque information d&#8217;identification.
Chaque compte utilisateur fournit un <strong>espace de nommage</strong>, qui est un rassemblement logique des projets appartenant à cet utilisateur.
Si l&#8217;utilisateur <code class="literal">jane</code> a un projet appelé <code class="literal">projet</code>, l&#8217;URL du projet est <a href="http://serveur/jane/projet" class="link">http://serveur/jane/projet</a>.</p>
<figure id="gitlab_users" class="image">
<div class="content">
<img src="images/gitlab-users.png" alt="L'écran d'administration des utilisateurs GitLab."/>
</div>
<figcaption>Figure 4. L&#8217;écran d&#8217;administration des utilisateurs GitLab.</figcaption>
</figure>
<p>Il existe deux manières de supprimer un utilisateur.
Bloquer (<code class="literal">Blocking</code>) un utilisateur l&#8217;empêche de s&#8217;identifier sur l&#8217;instance Gitlab, mais toutes les données sous l&#8217;espace de nom de cet utilisateur sont préservées, et les commits signés avec l&#8217;adresse courriel de cet utilisateur renverront à son profil.</p>
<p>Détruire (<code class="literal">Destroying</code>) un utilisateur, par contre, l&#8217;efface complètement de la base de données et du système de fichiers.
Tous les projets et les données situées dans son espace de nom sont effacés et tous les groupes qui lui appartiennent sont aussi effacés.
Il s&#8217;agit clairement d&#8217;une action plus destructive et permanente, et son usage est assez rare.</p>
</section>
<section class="sect3" title="Groupes">
<h4 id="s_gitlab_groups_section">Groupes</h4>
<p>Un groupe GitLab est un assemblage de projets, accompagné des informations de droits d&#8217;accès à ces projets.
Chaque groupe a un espace de nom de projet (de la même manière que les utilisateurs), donc si le groupe <code class="literal">formation</code> a un projet <code class="literal">matériel</code>, son URL sera <a href="http://serveur/formation/matériel" class="link">http://serveur/formation/matériel</a>.</p>
<figure id="gitlab_groups" class="image">
<div class="content">
<img src="images/gitlab-groups.png" alt="L'écran d'administration des groupes GitLab."/>
</div>
<figcaption>Figure 5. L&#8217;écran d&#8217;administration des groupes GitLab.</figcaption>
</figure>
<p>Chaque groupe est associé à des utilisateurs, dont chacun dispose d&#8217;un niveau de permissions sur les projets du groupe et sur le groupe lui-même.
Ces niveaux s&#8217;échelonnent de <em>invité</em> : <code class="literal">Guest</code> (tickets et discussions seulement) à <em>propriétaire</em> : <code class="literal">Owner</code> (contrôle complet du groupe, ses membres et ses projets).
Les types de permissions sont trop nombreux pour être énumérés ici, mais GitLab fournit un lien très utile sur son écran d&#8217;administration.</p>
</section>
<section class="sect3" title="Projets">
<h4 id="_projets">Projets</h4>
<p>Un projet GitLab correspond grossièrement à un dépôt Git unique.
Tous les projets appartiennent à un espace de nom unique, que ce soit un utilisateur ou un groupe.
Si le projet appartient à un utilisateur, le propriétaire du projet contrôle directement les droits d&#8217;accès au projet ; si le projet appartient à un groupe, le niveau de permission de l&#8217;utilisateur pour le groupe est aussi pris en compte.</p>
<p>Tous les projets ont un niveau de visibilité qui permet de contrôler qui a accès en lecture aux pages et au dépôt de ce projet.
Si un projet est privé (<em>Private</em>), l&#8217;accès au projet doit être explicitement accordé par le propriétaire du projet à chaque utilisateur.
Un projet interne (<em>Internal</em>) est visible par tout utilisateur identifié, et un projet public (<em>Public</em>) est un projet visible par tout le monde.
Notez que ces droits contrôlent aussi bien les accès pour git <code class="literal">fetch</code> que les accès à l&#8217;interface utilisateur web du projet.</p>
</section>
<section class="sect3" title="Crochets (Hooks)">
<h4 id="_crochets_em_hooks_em">Crochets (<em>Hooks</em>)</h4>
<p>GitLab inclut le support pour les crochets, tant au niveau projet que système.
Pour ces deux niveaux, le serveur GitLab lance des requêtes HTTP POST contenant un JSON de description lorsque certains événements précis arrivent.
C&#8217;est une excellent moyen de connecter vos dépôts Git et votre instance GitLab avec le reste de vos automatisations de développement, telles que serveurs d&#8217;intégration continue, forum de discussion et outils de déploiement.</p>
</section>
</section>
<section class="sect2" title="Usage de base">
<h3 id="_usage_de_base">Usage de base</h3>
<p>La première chose à faire avec GitLab est de créer un nouveau projet.
Pour cela, il suffit de cliquer sur l’icône <code class="literal">+</code> sur la barre d&#8217;outils.
On vous demande le nom du projet, à quel espace de nom il appartient, et son niveau de visibilité.
La plupart des configurations demandées ici ne sont pas permanentes et peuvent être réajustées plus tard grâce à l&#8217;interface de paramétrage.
Cliquez sur <code class="literal">Create Project</code> pour achever la création.</p>
<p>Une fois le projet créé, on peut le connecter à un dépôt Git local.
Chaque projet est accessible sur HTTPS ou SSH, qui peuvent donc être utilisés pour un dépôt distant.
Les URLs sont visibles en haut de la page du projet.
Pour un dépôt local existant, cette commande crée un dépôt distant nommé <code class="literal">gitlab</code> pointant vers l&#8217;hébergement distant :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add gitlab https://serveur/espace_de_nom/projet.git</code></pre>
</figure>
<p>Si vous n&#8217;avez pas de copie locale du dépôt, vous pouvez simplement taper ceci :</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://serveur/espace_de_nom/projet.git</code></pre>
</figure>
<p>L&#8217;interface utilisateur web donne accès à différentes vues utiles du dépôt lui-même.
La page d&#8217;accueil de chaque projet montre l&#8217;activité récente et des liens alignés en haut vous mènent aux fichiers du projet et au journal des <em>commits</em>.</p>
</section>
<section class="sect2" title="Coopérer">
<h3 id="_coopérer">Coopérer</h3>
<p>Le moyen le plus simple de coopérer sur un projet GitLab consiste à donner à un autre utilisateur un accès direct en écriture sur le dépôt Git.
Vous pouvez ajouter un utilisateur à un projet en sélectionnant la section <code class="literal">Members</code> des paramètres du projet et en associant le nouvel utilisateur à un niveau d&#8217;accès (les différents niveaux d&#8217;accès sont abordés dans <a id="xref-s_gitlab_groups_section" href="#s_gitlab_groups_section" class="xref">Groupes</a>).
En donnant un niveau d&#8217;accès <code class="literal">Developer</code> ou plus à un utilisateur, cet utilisateur peut pousser des <em>commits</em> et des branches directement sur le dépôt sans restriction.</p>
<p>Un autre moyen plus découplé de collaborer est d&#8217;utiliser des requêtes de tirage (<em>pull request</em>).
Cette fonction permet à n&#8217;importe quel utilisateur qui peut voir le projet d&#8217;y contribuer de manière contrôlée.
Les utilisateurs avec un accès direct peuvent simplement créer une branche, pousser des <em>commits</em> dessus et ouvrir une requête de tirage depuis leur branche vers <code class="literal">master</code> ou toute autre branche.
Les utilisateurs qui n&#8217;ont pas la permission de pousser sur un dépôt peuvent en faire un <em>fork</em> (créer leur propre copie), pousser des <em>commits</em> sur cette copie et ouvrir une requête de tirage depuis leur <em>fork</em> vers le projet principal.
Ce modèle permet au propriétaire de garder le contrôle total sur ce qui entre dans le dépôt et quand, tout en autorisant les contributions des utilisateurs non fiables.</p>
<p>Les requêtes de fusion (<em>merge requests</em>) et les problèmes (<em>issues</em>) sont les principaux moyens pour mener des discussions au long cours dans GitLab.
Chaque requête de fusion permet une discussion ligne par ligne sur les modifications proposées (qui permettent un sorte de revue de code légère), ainsi qu&#8217;un fil de discussion général.
Requêtes de fusion et problèmes peuvent être assignés à des utilisateurs ou assemblés en jalons (<em>milestones</em>).</p>
<p>Cette section se concentre principalement sur les parties de GitLab dédiées à Git, mais c&#8217;est un système assez mature qui fournit beaucoup d&#8217;autres fonctions qui peuvent aider votre équipe à coopérer.
Parmi celles-ci figurent les wikis, les murs de discussion et des outils de maintenance du système.
Un des bénéfices de GitLab est que, une fois le serveur paramétré et en marche, vous n&#8217;aurez pas besoin de bricoler un fichier de configuration ou d&#8217;accéder au serveur via SSH ; la plupart des tâches générales ou d&#8217;administration peuvent se réaliser à travers l&#8217;interface web.</p>
</section>
</section>
<section class="sect1" title="Git hébergé">
<h2 id="_git_hébergé">Git hébergé</h2>
<p>Si vous ne vous ne voulez pas vous investir dans la mise en place de votre propre serveur Git, il reste quelques options pour héberger vos projets Git sur un site externe dédié à l&#8217;hébergement.
Cette méthode offre de nombreux avantages : un site en hébergement est généralement rapide à créer et facilite le démarrage de projets, et n&#8217;implique pas de maintenance et de surveillance de serveur.
Même si vous montez et faites fonctionner votre serveur en interne, vous souhaiterez sûrement utiliser un site d&#8217;hébergement public pour votre code open source — cela rend généralement plus facile l&#8217;accès et l&#8217;aide par la communauté.</p>
<p>Aujourd&#8217;hui, vous avez à disposition un nombre impressionnant d&#8217;options d&#8217;hébergement, chacune avec différents avantages et inconvénients.
Pour une liste à jour, référez-vous à la page GitHosting sur le wiki principal de Git : <a href="https://git.wiki.kernel.org/index.php/GitHosting" class="link">https://git.wiki.kernel.org/index.php/GitHosting</a>.</p>
<p>Nous traiterons de l&#8217;utilisation de GitHub en détail dans <a id="xref--ch06-github" href="ch06-github.xhtml" class="xref">GitHub</a> du fait que c&#8217;est le plus gros hébergement de Git sur Internet et que vous pourriez avoir besoin d&#8217;y interagir pour des projets hébergés à un moment, mais il existe aussi d&#8217;autres plates-formes d&#8217;hébergement si vous ne souhaitez pas mettre en place votre propre serveur Git.</p>
</section>
<section class="sect1" title="Résumé">
<h2 id="_résumé">Résumé</h2>
<p>Vous disposez de plusieurs moyens de mettre en place un dépôt Git distant pour pouvoir collaborer avec d&#8217;autres et partager votre travail.</p>
<p>Gérer votre propre serveur vous donne une grande maîtrise et vous permet de l&#8217;installer derrière un pare-feu, mais un tel serveur nécessite généralement une certaine quantité de travail pour l&#8217;installation et la maintenance.
Si vous placez vos données sur un serveur hébergé, c&#8217;est très simple à installer et maintenir.
Cependant vous devez pouvoir héberger votre code sur des serveurs tiers et certaines politiques d&#8217;organisation ne le permettent pas.</p>
<p>Choisir la meilleure solution ou combinaison de solutions pour votre cas ou celui de votre société ne devrait pas poser de problème.</p>
</section>
</section>
</body>
</html>